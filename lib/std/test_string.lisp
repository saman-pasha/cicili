(import "string.lisp" nil nil)

(Slice      "" ByteVector uchar 256 () () ())
(String     "" String     char  256 () () ())

(source "./tests/string_test.c" (:std #t :compile #t :link "-L{$CWD} cicili_string.lo string_test.lo -o string_test")

        (include "cicili_string.h")

        (main
              (let
                  ((String * a . #'(-> String new "hello"))
                   (String * b . #'(-> String new "world"))
                   (String * formatted . #'(-> String newFormat "value: %d, %s" 42 "test"))
                   (String * helloWorld . #'(-> a concat b))
                   (String * upper . #'(-> a toUpper))
                   (String * lower . #'(-> upper toLower))
                   (String * trimmed . #'(-> (-> String new "   padded   ") trim))
                   (String * replaced . #'(-> (-> String new "a-b-c-d") replace #\- #\_))
                   (String * substr . #'(-> helloWorld substring 3 4))
                   (String * prefix . #'(-> String new "hel"))
                   (String * suffix . #'(-> String new "rld"))
                   (bool eq1 . #'(-> a equals a))
                   (bool eq2 . #'(-> a equals b))
                   (size_t index . #'(-> a find #\l))
                   (bool sw . #'(-> a startsWith prefix))
                   (bool ew . #'(-> helloWorld endsWith suffix)))

                (format #t "a: %s\n" ($ a arr))
                (format #t "b: %s\n" ($ b arr))
                (format #t "helloWorld: %s\n" ($ helloWorld arr))
                (format #t "formatted: %s\n" ($ formatted arr))
                (format #t "upper: %s\n" ($ upper arr))
                (format #t "lower: %s\n" ($ lower arr))
                (format #t "trimmed: [%s]\n" ($ trimmed arr))
                (format #t "replaced: %s\n" ($ replaced arr))
                (format #t "substring(3,4): %s\n" ($ substr arr))
                (format #t "a equals a: %s\n" (? eq1 "true" "false"))
                (format #t "a equals b: %s\n" (? eq2 "true" "false"))
                (format #t "find 'l' in a: %zu\n" index)
                (format #t "a starts with 'hel': %s\n" (? sw "true" "false"))
                (format #t "helloWorld ends with 'rld': %s\n" (? ew "true" "false"))

                (-> a free)
                (-> b free)
                (-> helloWorld free)
                (-> formatted free)
                (-> upper free)
                (-> lower free)
                (-> trimmed free)
                (-> replaced free)
                (-> substr free)
                (-> prefix free)
                (-> suffix free)

                (return 0))))
