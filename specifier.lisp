(in-package :lcc)

;;;; specifier
(defclass sp ()
  ((name          :initarg :name      :accessor name)
   (construct     :initarg :construct :accessor construct)
   (const         :initarg :const     :accessor const)
   (typeof        :initarg :typeof    :accessor typeof)
   (modifier      :initarg :modifier  :accessor modifier)
   (const-ptr     :initarg :const-ptr :accessor const-ptr)
   (array-def     :initarg :array-def :accessor array-def)
   (default       :initarg :default   :accessor default)
   (attrs         :initarg :attrs     :accessor attrs)
   (anonymous     :initarg :anonymous :initform nil :accessor anonymous)
   (body          :initform nil :accessor body)
   (params        :initform nil :accessor params)
   (lambdas       :initform nil :accessor lambdas)
   (inners        :initform nil :accessor inners)))

(defun make-specifier (name construct const typeof modifier const-ptr array-def default attrs &optional (anonymous nil))
  (let ((instance (make-instance 'sp
				                 :name      name
				                 :construct construct
				                 :const     const
				                 :typeof    typeof
				                 :modifier  modifier
				                 :const-ptr const-ptr
				                 :array-def array-def
				                 :default   default
				                 :attrs     attrs
				                 :anonymous anonymous)))
    (cond ((eql construct '|@LET|)
	       (setf (params  instance)     (make-hash-table :test 'eql)))
	      ((eql construct '|@FUNC|)
	       (setf (params  instance)     (make-hash-table :test 'eql))
 	       (setf (inners  instance)     (make-hash-table :test 'eql))) ; contains lambdas
	      ((eql construct '|@METHOD|)
	       (setf (params  instance)     (make-hash-table :test 'eql))
 	       (setf (inners  instance)     (make-hash-table :test 'eql))) ; contains lambdas
	      ((eql construct '|@ENUM|)
 	       (setf (inners  instance)     (make-hash-table :test 'eql)))
	      ((eql construct '|@STRUCT|)
	       (setf (params  instance)     (make-hash-table :test 'eql))
	       (setf (inners  instance)     (make-hash-table :test 'eql)))
	      ((eql construct '|@UNION|)
	       (setf (params  instance)     (make-hash-table :test 'eql))
	       (setf (inners  instance)     (make-hash-table :test 'eql)))
	      ((eql construct '|@GUARD|)
	       (setf (inners  instance)     (make-hash-table :test 'eql)))
	      ((eql construct '|@TARGET|)
	       (setf (inners  instance)     (make-hash-table :test 'eql)))
	      (t t))
    instance))


(defun add-param (spec parent)
  (if (gethash (name spec) (params parent))
      (error (format nil "paramter exists: ~A for ~A" spec parent))
      (setf (gethash (name spec) (params parent)) spec)))

(defun add-inner (spec parent)
  (if (gethash (name spec) (inners parent))
      (error (format nil "inner exists: ~A in ~A" spec parent))
      (setf (gethash (name spec) (inners parent)) spec)))
  
;;;; specifier
(defmethod print-object ((spec sp) stream)
  (print-unreadable-object (spec stream :type t :identity t)
    (princ
     (format nil
       "~A ~:[~A ~;~*~]~:[~A ~;~*~]~:[~A ~;~*~]~:[~A ~;~*~]~:[~A ~;~*~]~:[~{~A~} ~;~*~]~:[= ~A ~;~*~]~:[{~{~A~^ ~}}~;~*~]~:[~;A~]"
	   (construct spec)
       (null (name spec))      (name spec)
       (null (const spec))     (const spec)
       (null (typeof spec))    (typeof spec)
       (null (modifier spec))  (modifier spec)
       (null (const-ptr spec)) (const-ptr spec)
	   (null (array-def spec)) (array-def spec)
       (null (default spec))   (default spec)
	   (null (attrs spec))     (attrs spec)
       (anonymous spec))
     stream)))

(defun copy-specifiers (table)
  (if (null table)
      (make-hash-table)
      (let ((new-table (make-hash-table
                        :test (hash-table-test table)
                        :size (hash-table-size table)
		                :rehash-size (hash-table-rehash-size table)
		                :rehash-threshold (hash-table-rehash-threshold table))))
        (maphash #'(lambda(key value)
                     (setf (gethash key new-table) value))
                 table)
        new-table)))

(defun print-specifier (spec &optional (lvl 0))
  (format t
          "~A~A ~A ~:[~A ~;~*~]~:[~A ~;~*~]~:[~A ~;~*~]~:[~A ~;~*~]~:[~{~A~} ~;~*~]~:[= ~A ~;~*~]~:[{~{~A~^ ~}}~;~*~]~:[~;A~]~%"
	      (indent lvl) (construct spec) (name spec) (null (const spec)) (const spec) (null (typeof spec)) (typeof spec)
	      (null (modifier spec)) (modifier spec) (null (const-ptr spec)) (const-ptr spec)
	      (null (array-def spec)) (array-def spec) (null (default spec)) (default spec)
	      (null (attrs spec)) (attrs spec) (anonymous spec))
  (let ((params  (params  spec))
	    (inners  (inners  spec)))
    (when params  (print-specifiers params  (+ 1 lvl)))
    (when inners  (print-specifiers inners  (+ 1 lvl)))))

(defun print-specifiers (table &optional (lvl 0))
  (maphash #'(lambda (k v) (print-specifier v lvl)) table))

(defun specify-name< (name)
  (if (is-name name) name
      (error (format nil "wrong name ~S" name))))

(defun specify-receiver< (name)
  (let ((parts (str:split "->" (string name))))
    (unless (= (length parts) 2) (error (format nil "wrong receiver ~S" name)))
    (let ((receiver (intern (nth 0 parts)))
          (method (intern (nth 1 parts))))
      (if (and (is-name receiver) (is-name method))
          (cons receiver method)
          (error (format nil "wrong receiver ~S" name))))))

(defun specify-type-name< (name)
  (cond ((key-eq name '|uchar|)  "unsigned char")
	    ((key-eq name '|ushort|) "unsigned short")
	    ((key-eq name '|uint|)   "unsigned int")
	    ((key-eq name '|ulong|)  "unsigned long")
	    ((key-eq name '|llong|)  "long long")
	    ((key-eq name '|ullong|) "unsigned long long")
	    ((key-eq name '|i8|)     "int8_t")
	    ((key-eq name '|u8|)     "uint8_t")
	    ((key-eq name '|i16|)    "int16_t")
	    ((key-eq name '|u16|)    "uint16_t")
	    ((key-eq name '|i32|)    "int32_t")
	    ((key-eq name '|u32|)    "uint32_t")
	    ((key-eq name '|i64|)    "int64_t")
	    ((key-eq name '|u64|)    "uint64_t")
	    ((key-eq name '|i128|)   "__int128")
	    ((key-eq name '|u128|)   "unsigned __int128")
	    ((key-eq name '|real|)   "long double")
	    (t (specify-name< name))))

(defun specify-type< (desc &optional noVar)
  (let ((len (if (listp desc) (length desc) 1))
	    (const nil)
	    (type nil)
	    (modifier nil)
	    (const-ptr nil)
	    (variable nil)
	    (array nil)
	    (status 0))
    (cond ((symbolp desc) (setq type desc))
	      ((= len 1) (setq type (nth 0 desc)))
	      ((= len 2) (if (key-eq (nth 0 desc) '|const|)
			             (progn
			               (setq const (nth 0 desc))
			               (setq type (nth 1 desc)))
		                 (if (find (nth 1 desc) *modifiers* :test #'key-eq)
			                 (progn
			                   (setq type (nth 0 desc))
			                   (setq modifier (nth 1 desc)))
			                 (if (is-array (nth 1 desc))
			                     (progn
			                       (setq type (nth 0 desc))
			                       (setq array (nth 1 desc)))
			                     (progn
			                       (setq type (nth 0 desc))
			                       (setq variable (nth 1 desc)))))))
	      ((= len 3) (if (key-eq (nth 0 desc) '|func|)
                         (progn
                           (setq type (nth 0 desc))
		                   (setq modifier '|*|)
                           (setq variable (nth 1 desc))
				           (setq array (specify-function desc (list '(|decl|)))))
                         (if (key-eq (nth 0 desc) '|const|)
			                 (if (find (nth 2 desc) *modifiers* :test #'key-eq) 
			                     (progn
			                       (setq const (nth 0 desc))
			                       (setq type (nth 1 desc))
			                       (setq modifier (nth 2 desc)))
			                     (if (is-array (nth 2 desc))
			                         (progn
				                       (setq const (nth 0 desc))
				                       (setq type (nth 1 desc))
				                       (setq array (nth 2 desc)))
			                         (progn
			                           (setq const (nth 0 desc))
			                           (setq type (nth 1 desc))
			                           (setq variable (nth 2 desc)))))
		                     (if (find (nth 1 desc) *modifiers* :test #'key-eq)
			                     (if (key-eq (nth 2 desc) '|const|)
			                         (progn
				                       (setq type (nth 0 desc))
				                       (setq modifier (nth 1 desc))
				                       (setq const-ptr (nth 2 desc)))
			                         (if (is-array (nth 2 desc))
				                         (progn
				                           (setq type (nth 0 desc))
				                           (setq modifier (nth 1 desc))
				                           (setq array (nth 2 desc)))
			                             (progn
				                           (setq type (nth 0 desc))
				                           (setq modifier (nth 1 desc))
				                           (setq variable (nth 2 desc)))))
			                     (progn
			                       (setq type (nth 0 desc))
			                       (setq variable (nth 1 desc))
			                       (setq array (nth 2 desc)))))))
	      ((= len 4) (if (key-eq (nth 0 desc) '|func|)
                         (progn
                           (setq type (nth 0 desc))
		                   (setq modifier '|*|)
                           (setq variable (nth 1 desc))
				           (setq array (specify-function desc (list '(|decl|)))))
                         (if (key-eq (nth 0 desc) '|const|)
                             (if (key-eq (nth 1 desc) '|func|)
                                 (progn
                                   (setq const (nth 0 desc))
                                   (setq type (nth 1 desc))
		                           (setq modifier '|*|)
                                   (setq variable (nth 2 desc))
				                   (setq array (specify-function (cdr desc) (list '(|decl|)))))
                                 (if (find (nth 2 desc) *modifiers* :test #'key-eq)
			                         (if (key-eq (nth 3 desc) '|const|)
				                         (progn
				                           (setq const (nth 0 desc))
				                           (setq type (nth 1 desc))
				                           (setq modifier (nth 2 desc))
				                           (setq const-ptr (nth 3 desc)))
			                             (if (is-array (nth 3 desc))
				                             (progn
				                               (setq const (nth 0 desc))
				                               (setq type (nth 1 desc))
				                               (setq modifier (nth 2 desc))
				                               (setq array (nth 3 desc)))
				                             (progn
				                               (setq const (nth 0 desc))
				                               (setq type (nth 1 desc))
				                               (setq modifier (nth 2 desc))
				                               (setq variable (nth 3 desc)))))
		                             (if (key-eq (nth 2 desc) '|const|)
			                             (if (is-array (nth 3 desc))
			                                 (progn
				                               (setq type (nth 0 desc))
				                               (setq modifier (nth 1 desc))
				                               (setq const-ptr (nth 2 desc))
				                               (setq array (nth 3 desc)))
			                                 (progn
			                                   (setq type (nth 0 desc))
			                                   (setq modifier (nth 1 desc))
			                                   (setq const-ptr (nth 2 desc))
			                                   (setq variable (nth 3 desc))))
                                         (if (is-array (nth 3 desc))
			                                 (progn
                                               (setq const (nth 0 desc))
				                               (setq type (nth 1 desc))
				                               (setq variable (nth 2 desc))
                                               (setq array (nth 3 desc)))
			                                 (progn
			                                   (setq type (nth 0 desc))
			                                   (setq modifier (nth 1 desc))
			                                   (setq variable (nth 2 desc))
			                                   (setq array (nth 3 desc)))))))
                             (if (find (nth 1 desc) *modifiers* :test #'key-eq)
			                     (if (key-eq (nth 2 desc) '|const|)
			                         (if (is-array (nth 3 desc))
				                         (progn
				                           (setq type (nth 0 desc))
				                           (setq modifier (nth 1 desc))
				                           (setq const-ptr (nth 2 desc))
                                           (setq array (nth 3 desc)))
				                         (progn
				                           (setq type (nth 0 desc))
				                           (setq modifier (nth 1 desc))
				                           (setq const-ptr (nth 2 desc))
                                           (setq variable (nth 3 desc))))
                                     (progn
                                       (setq type (nth 0 desc))
				                       (setq modifier (nth 1 desc))
				                       (setq variable (nth 2 desc))
                                       (setq array (nth 3 desc))))
                                 (progn
                                   (setq type (nth 0 desc))
				                   (setq variable (nth 1 desc))
                                   (setq array (list (nth 2 desc) (nth 3 desc))))))))
	       ((= len 5) (if (key-eq (nth 0 desc) '|const|)
                          (if (key-eq (nth 1 desc) '|func|)
                              (progn
                                (setq const (nth 0 desc))
                                (setq type (nth 1 desc))
		                        (setq modifier '|*|)
		                        (setq variable (nth 2 desc))
				                (setq array (specify-function (cdr desc) (List '(|decl|)))))
                              (if (is-array (nth 4 desc))
                                  (if (is-array (nth 3 desc))
			                          (progn
                                        (setq const (nth 0 desc))
                                        (setq type (nth 1 desc))
				                        (setq variable (nth 2 desc))
                                        (setq array (list (nth 3 desc) (nth 4 desc))))
                                      (progn
                                        (setq const (nth 0 desc))
			                            (setq type (nth 1 desc))
			                            (setq modifier (nth 2 desc))
			                            (setq variable (nth 3 desc))
                                        (setq array (nth 4 desc))))
                                  (progn
			                        (setq const (nth 0 desc))
			                        (setq type (nth 1 desc))
			                        (setq modifier (nth 2 desc))
			                        (setq const-ptr (nth 3 desc))
			                        (setq variable (nth 4 desc)))))
			              (progn
			                (setq type (nth 0 desc))
			                (setq modifier (nth 1 desc))
			                (setq const-ptr (nth 2 desc))
                            (setq variable (nth 3 desc))
			                (setq array (nth 4 desc)))))
	      ((= len 6) (progn
		               (setq const (nth 0 desc))
		               (setq type (nth 1 desc))
		               (setq modifier (nth 2 desc))
		               (setq const-ptr (nth 3 desc))
		               (setq variable (nth 4 desc))
		               (setq array (nth 5 desc))))
	      (t (setq status -1)))
    (unless (or (null const)     (key-eq const '|const|)) (setq status -2))
    (unless (or (null modifier)  (key-eq modifier '&) (key-eq modifier '*) (key-eq modifier '**)) (setq status -3))
    (unless (or (null const-ptr) (key-eq const-ptr '|const|)) (setq status -4))
    (unless (or (null const-ptr) (key-eq modifier '*) (key-eq modifier '**)) (setq status -5))
    (when noVar (unless (null variable) (setq status -6)))
    (if (key-eq type '|func|)
        (progn
          (when (null array) (setq status -7))
          (setq array (list array)))
        (if (and (= (length array) 2) (is-array (car array)) (is-array (cadr array)))
            (setq array (list (specify-expr (nth 1 (car array))) (specify-expr (nth 1 (cadr array)))))
            (when (= (length array) 3)
              (setq array (list (specify-expr (nth 1 array)))))))
    (when   (< status 0) (error (format nil "wrong type descriptor ~D ~A" status desc)))
    (values const type modifier const-ptr variable array)))

(defun specify-type-value< (desc)
  (let ((l (cdr (last desc)))
	    (wl (without-last desc)))
    (cond ((and (listp l) (> (length desc) 2) (key-eq (nth (- (length desc) 2) desc) 'FUNCTION)) ; #' function initializer
	       (setq l (nth (- (length desc) 1) desc))
	       (multiple-value-bind (const type modifier const-ptr variable array)
		       (specify-type< (without-last wl))
		     (values const type modifier const-ptr variable array l)))
          ((and (listp l) (> (length desc) 2) (key-eq (nth (- (length desc) 2) desc) 'QUOTE)) ; ' list and lambda initializer
           (let* ((def (nthcdr (- (length desc) 2) desc))
                  (quoted (cadr def)))
             (if (key-eq (car quoted) '|lambda|)
                 (progn ; lambda initializer
                   (multiple-value-bind (const type modifier const-ptr variable array)
		               (specify-type< (without-last wl))
		             (values const type modifier const-ptr variable array def)))
                 (progn ; list initializer
	               (setq l (nthcdr (- (length desc) 2) desc))
		           (multiple-value-bind (const type modifier const-ptr variable array)
		               (specify-type< (without-last wl))
		             (values const type modifier const-ptr variable array l))))))
	      ((listp l) (specify-type< desc))
	      (t (multiple-value-bind (const type modifier const-ptr variable array)
	             (specify-type< wl)
	           (values const type modifier const-ptr variable array l))))))

(defun specify-nil-expr ()
  (make-specifier '|NULL| '|@ATOM| nil '|@SYMBOL| nil nil nil nil '()))

(defun specify-number-expr (def)
  (make-specifier def '|@ATOM| nil '|@NUMBER| nil nil nil nil '()))

(defun specify-character-expr (def)
  (if (eql def #\Null)
      (make-specifier "'\\0'" '|@ATOM| nil '|@CHAR| nil nil nil nil '())
      (make-specifier def     '|@ATOM| nil '|@CHAR| nil nil nil nil '())))

(defun specify-string-expr (def)
  (make-specifier (format nil "\"~A\"" def) '|@ATOM| nil '|@STRING| nil nil nil nil '()))

(defun specify-symbol-expr (def)
  (make-specifier def '|@ATOM| nil '|@SYMBOL| nil nil nil nil '()))

(defun specify-atom-expr (def)
  (cond ((null       def) (make-specifier nil '|@NIL| nil nil nil nil nil nil '())) ; ignore nil values like ([ NIL ])
        ((key-eq     def '|nil|) (specify-nil-expr))
        ((numberp    def)        (specify-number-expr def))
	    ((characterp def)        (specify-character-expr def))
	    ((stringp    def)        (specify-string-expr def))
        ((and (symbolp def) (is-symbol def))
	     (if (eql (char (symbol-name def) 0) #\0) ; 0x12af..
	         (specify-symbol-expr def)
             (specify-symbol-expr def))) ; name
        ((symbolp    def)        (specify-symbol-expr def)) ; operators
	    (t (error (format nil "syntax error \"~A\"" def)))))

(defun specify-code-expr (def)
  (make-specifier nil '|@CODE| nil nil nil nil nil def '()))

(defun specify-list-expr (def)
  (make-specifier nil '|@LIST| nil nil nil nil nil (loop for item in def collect (specify-expr item)) '()))

(defun specify-unary-expr (def)
  (unless (= (length def) 2) (error (format nil "wrong unary form ~A" def)))
  (let* ((oprt (car def))
	     (name (symbol-name oprt))
	     (is-postfix nil))
    (when (eql (char name (- (length name) 1)) #\#)
      (setq oprt (subseq name 0 (- (length name) 1)))
      (setq is-postfix t))
    (cond ((key-eq oprt '|not|)       (setq oprt '|!|))
	      ((key-eq oprt '|cof|)       (setq oprt '|*|))
          ((key-eq oprt '|aof|)       (setq oprt '|&|)))
    (if is-postfix
        (make-specifier oprt '|@UNARY| nil nil t   nil nil (specify-expr (cadr def)) '()) ; --#
        (make-specifier oprt '|@UNARY| nil nil nil nil nil (specify-expr (cadr def)) '()))))

(defun specify-operator-expr (def)
  (when (< (length def) 3) (error (format nil "wrong operator form ~A" def)))
  (let ((opr (car def))
	    (oprnds '()))
    (cond ((key-eq opr '|and|)    (setq opr '|&&|))
	      ((key-eq opr '|or|)     (setq opr '|\|\||))
	      ((key-eq opr '|bitand|) (setq opr '|&|))
	      ((key-eq opr '|bitor|)  (setq opr '|\||))
	      ((key-eq opr '|xor|)    (setq opr '|^|)))
    (dolist (oprnd (cdr def))
      (push opr oprnds)
      (push oprnd oprnds))
    (make-specifier opr '|@OPR| nil nil nil nil nil
                    (loop for frm in (cdr (reverse oprnds))
                          collect (specify-expr frm)) '())))

(defun specify-assignment-expr (def)
  (unless (= (length def) 3) (error (format nil "wrong assignment form ~A" def)))
  (let ((opr (car def))
	    (oprnds '()))
    (dolist (oprnd (cdr def))
      (push opr oprnds)
      (push oprnd oprnds))
    (make-specifier opr '|@ASSIGN| nil nil nil nil nil
                    (loop for frm in (cdr (reverse oprnds))
                          collect (specify-expr frm))'())))

(defun specify-nth-expr (def)
  (unless (= (length def) 3) (error (format nil "wrong nth form ~A" def)))
  (make-specifier (specify-expr (nth 1 def)) '|@NTH| nil nil nil nil nil (specify-expr (nth 2 def)) '()))

(defun specify-?-expr (def)
  (unless (= (length def) 4) (error (format nil "wrong ? form ~A" def)))
  (make-specifier (specify-expr (nth 1 def)) '|@?| nil nil nil nil nil
                  (list (specify-expr (nth 2 def)) (specify-expr (nth 3 def))) '()))

(defun specify-cast-expr (def)
  (unless (= (length def) 3) (error (format nil "wrong cast form ~A" def)))
  (multiple-value-bind (const type modifier const-ptr variable array)
	  (specify-type< (nth 1 def))
    (make-specifier variable '|@CAST| const type modifier const-ptr array (specify-expr (nth 2 def)) '())))

(defun specify-$-expr (def)
  (unless (= (length def) 3) (error (format nil "wrong access member $ form ~A" def)))
  (unless (is-symbol (nth 2 def)) (error (format nil "wrong access member name ~A" def)))
  (make-specifier (specify-expr (nth 1 def)) '|@$| nil nil nil nil nil (specify-symbol-expr (nth 2 def)) '()))

(defun specify-->-expr (def)
  (when (< (length def) 3) (error (format nil "wrong access method -> form ~A" def)))
  (unless (is-symbol (nth 2 def)) (error (format nil "wrong access method name ~A" def)))
  (let ((method-var (make-specifier (specify-expr (nth 1 def)) '|@->| nil nil nil nil nil
                                    (specify-symbol-expr (nth 2 def)) '())))
    (setf (body method-var) (specify-list-expr (nthcdr 3 def)))
    method-var))

(defun specify-sizeof-expr (def)
  (when (< (length def) 2) (error (format nil "syntax error ~A" def)))
  (multiple-value-bind (const type modifier const-ptr variable array)
      (specify-type< (nthcdr 1 def))
    (make-specifier variable '|@SIZEOF| const type modifier const-ptr array nil nil)))

(defun specify-call-expr (def)
  (make-specifier (specify-expr (nth 0 def)) '|@CALL| nil nil nil nil nil
                  (if (> (length def) 1) (loop for item in (nthcdr 1 def) collect (specify-expr item)) nil) '()))

(defun specify-expr (def)
  (cond ((key-eq  def '|nil|) (specify-nil-expr))
        ((atom    def)        (specify-atom-expr def))
        (t (let ((func (car def)))
	         (cond ((key-eq func '|code|)   (specify-code-expr (cadr def)))
                   ((key-eq func 'FUNCTION) (specify-expr      (cadr def)))
		           ((key-eq func 'QUOTE)
                    (let ((quoted (cadr def)))
                      (if (key-eq (car quoted) '|lambda|) ; lambda
                          (let* ((fname (name *function-spec*))
                                 (lname (if (str:starts-with-p "__lccLambda_" (symbol-name fname))
                                            (gensym (format nil "~A_" fname))
                                            (gensym (format nil "__lccLambda_~A_" fname))))
                                 (func-spec (specify-function (append (list '|lambda| lname) (cdr quoted)) '())))
                            (add-inner func-spec *function-spec*)
                            (specify-symbol-expr lname))
                          (specify-list-expr quoted))))   ; list
		           ((and (> (length def) 2) (key-eq func '\|) (key-eq (cadr def) '\|))
		            (specify-operator-expr (push '\|\| (cddr def))))
		           ((and (> (length def) 2) (key-eq func '\|)) (specify-operator-expr def))
		           ((and (= (length def) 2) (find func *unaries*   :test #'key-eq)) (specify-unary-expr def))
		           ((and (> (length def) 2) (find func *operators* :test #'key-eq)) (specify-operator-expr def))
		           ((key-eq func '|nth|)    (specify-nth-expr    def))
		           ((key-eq func '|?|)      (specify-?-expr      def)) 
		           ((key-eq func '|cast|)   (specify-cast-expr   def))
                   ((key-eq func '|$|)      (specify-$-expr      def)) ; member access operator
                   ((key-eq func '|->|)     (specify-->-expr     def)) ; method access operator
                   ((key-eq func '|sizeof|) (specify-sizeof-expr def))
		           (t (specify-call-expr def)))))))

(defun specify-variable (def attrs)
  (let* ((is-auto     nil)
	     (is-register nil)
	     (is-static   nil)
	     (is-extern   nil)
	     (type  (cdr def)))
    (dolist (attr attrs)
      (let ((name (car attr)))
	    (cond ((key-eq name '|auto|)     (setq is-auto t))
	          ((key-eq name '|register|) (setq is-register t))
	          ((key-eq name '|static|)   (setq is-static t))
	          ((key-eq name '|extern|)   (setq is-extern t))
	          (t (error (format nil "unknown variable attribute ~A" attr))))))
    (multiple-value-bind (const type modifier const-ptr variable array default)
        (specify-type-value< type)
      (let ((attributes '()))
	    (when is-extern   (push '|extern|   attributes))
	    (when is-static   (push '|static|   attributes))
	    (when is-register (push '|register| attributes))
	    (when is-auto     (push '|auto|     attributes))
	    (make-specifier variable '|@VAR| const type modifier const-ptr array
                        (if (null default) nil (specify-expr default)) attributes)))))

(defun specify-body (def)
  (let ((body-specifier (make-specifier nil '@|BODY| nil nil nil nil nil nil nil)))
    (dolist (form def)
      (push
          (cond ((key-eq  form '|nil|) (specify-nil-expr))
                ((atom    form)        (specify-atom-expr   form))
	            (t (let ((func (car form)))
	                 (cond ((listp func) (error (format nil "function name or operator is missing ~A" form)))
		                   ((and (= (length form) 2) (find func *unaries*     :test #'key-eq))
                            (specify-unary-expr form))
		                   ((and (= (length form) 3) (find func *assignments* :test #'key-eq))
                            (specify-assignment-expr form))
		                   ((key-eq func '|let|)      (specify-let           form)) 
		                   ((key-eq func '|block|)    (specify-block         form)) 
		                   ((key-eq func '|set|)      (specify-set-expr      form))
		                   ((key-eq func '|return|)   (specify-return-expr   form))
		                   ((key-eq func '|break|)    (specify-symbol-expr   form))
		                   ((key-eq func '|continue|) (specify-symbol-expr   form))
		                   ((key-eq func '|if|)       (specify-if            form)) 
		                   ((key-eq func '|switch|)   (spacify-switch        form)) 
		                   ((key-eq func '|while|)    (specify-while         form)) 
		                   ((key-eq func '|do|)       (specify-do            form)) 
		                   ((key-eq func '|for|)      (specify-for           form)) 
		                   ((key-eq func '|for-each|) (specify-for-each      form)) 
		                   (t (specify-expr form))))))
          (body body-specifier)))
    (setf (body body-specifier) (reverse (body body-specifier)))
    body-specifier))

(defun specify-let (def)
  (when (or (< (length def) 2) (not (listp (nth 1 def)))) (error (format nil "wrong let form ~A" def)))
  (let ((let-var (make-specifier (gensym "lcc#Let") '|@LET| nil nil nil nil nil nil '())))
    (let ((is-auto     nil)
	      (is-register nil)
	      (is-static   nil)
          (is-alloc    nil)
          (has-defer   nil))
      (dolist (type-desc (nth 1 def))
        (unless (and (not (null type-desc)) (listp type-desc))
          (error (format nil "wrong variable definition form ~A" type-desc)))
        (cond ((and (key-eq (car type-desc) '|auto|)     (= (length (cdr type-desc)) 0)) (setq is-auto t))
	          ((and (key-eq (car type-desc) '|register|) (= (length (cdr type-desc)) 0)) (setq is-register t))
	          ((and (key-eq (car type-desc) '|static|)   (= (length (cdr type-desc)) 0)) (setq is-static t))
	          ((key-eq (car type-desc)      '|defer|)
               (let ((quoted (cadr type-desc)))
                 (unless (and (= (length type-desc) 2) (key-eq '|lambda| (caadr quoted)))
                   (error (format nil "wrong defer definition ~A" type-desc)))
                 (setq has-defer quoted)))
	          (t (multiple-value-bind (const typeof modifier const-ptr variable array value)
		             (specify-type-value< type-desc)
		           (when (and (listp value) (key-eq (first value) '|alloc|))
                     (setq is-alloc t)
		             (when (or (= (length value) 1) (> (length value) 3))
		               (error (format nil "wrong alloc form ~A" value)))
		             (if (= (length value) 2)
		                 (setq value (list '|cast| (remove nil (list const typeof modifier const-ptr))
					                       (list '|malloc| (nth 1 value))))
		                 (setq value (list '|cast| (remove nil (list const typeof modifier const-ptr))
				                           (list '|calloc| (nth 1 value) (nth 2 value))))))
		           (let ((attributes '()))
		             (when is-static   (push (cons '|static|   t) attributes))
		             (when is-register (push (cons '|register| t) attributes))
		             (when is-auto     (push (cons '|auto|     t) attributes))
		             (when is-alloc    (push (cons '|alloc|    t) attributes))
		             (when has-defer   (push (cons '|defer|    (specify-expr has-defer)) attributes))
                     (add-param
                         (make-specifier variable '|@VAR| const typeof modifier const-ptr array
                                         (if (null value) nil (specify-expr value)) attributes)
                       let-var)))))))
    (setf (body let-var) (specify-body (nthcdr 2 def)))
    let-var))

(defun specify-block (def)
  (let ((block-var (make-specifier (gensym "lcc#Block") '|@BLOCK| nil nil nil nil nil nil '())))
    (setf (body block-var) (specify-body (cdr def)))
    block-var))

(defun specify-set-expr (def)
  (when (= (rem (length (cdr def)) 2) 1) (error (format nil "wrong set form ~A" def)))
  (let* ((len (length (cdr def)))
         (items (loop for i from 0 to (1- len)
                      for (x y) on (cdr def)
                      when (and (= (mod i 2) 0) (not (null y)))
                      collect (list (specify-expr x) (specify-expr y)))))
    (make-specifier nil '|@SET| nil nil nil nil nil items '())))

(defun specify-return-expr (def)
  (make-specifier nil '|@RETURN| nil nil nil nil nil (specify-expr (nth 1 def)) '()))

(defun specify-if (def)
  (when (or (< (length def) 3) (> (length def) 4)) (error (format nil "wrong if form ~A" def)))
  (let* ((condition (specify-expr (nth 1 def)))
         (if-var (make-specifier condition '|@IF| nil nil nil nil nil nil '())))
    (setf (body if-var) (specify-body (list (nth 2 def))))
    (when (> (length def) 3)
      (setf (default if-var) (specify-body (list (nth 3 def)))))
    if-var))

(defun specify-switch (def)
  (when (< (length def) 2) (error (format nil "wrong switch form ~A" def)))
  (let* ((expre (specify-expr (nth 1 def)))
         (switch-var (make-specifier expre '|@SWITCH| nil nil nil nil nil nil '()))
         (cases '()))
    (dolist (ch-form (nthcdr 2 def))
      (cond ((key-eq (car ch-form) '|case|)
             (setq expre (specify-expr (cadr ch-form)))
             (let ((case-var (make-specifier expre '|@CASE| nil nil nil nil nil nil '())))
               (setf (body case-var) (specify-body (nthcdr 2 ch-form)))
               (push cases case-var)))
	        ((key-eq (car ch-form) '|default|)
             (let ((case-var (make-specifier expre '|@DEFAULT| nil nil nil nil nil nil '())))
               (setf (body case-var) (specify-body (nthcdr 1 ch-form)))
               (push cases case-var)))
	        (t (error (format nil "only case or default form ~A" ch-form)))))
    (setf (inners switch-var) (reverse cases))
    switch-var))

(defun specify-while (def)
  (when (< (length def) 2) (error (format nil "wrong while form ~A" def)))
  (let* ((condition (specify-expr (nth 1 def)))
         (while-var (make-specifier condition '|@WHILE| nil nil nil nil nil nil '())))
    (setf (body while-var) (specify-body (nthcdr 2 def)))
    while-var))

(defun specify-do (def)
  (when (< (length def) 2) (error (format nil "wrong while form ~A" def)))
  (let* ((condition (specify-expr (nth 1 def)))
         (do-var (make-specifier condition '|@DO| nil nil nil nil nil nil '())))
    (setf (body do-var) (specify-body (nthcdr 2 def)))
    do-var))

(defun specify-for (def)
  (when (or (< (length def) 3) (not (listp (nth 1 def)))) (error (format nil "wrong for form ~A" def)))
  (let* ((condition (specify-expr (nth 2 def)))
         (for-var (make-specifier condition '|@FOR| nil nil nil nil nil nil '()))
         (vars '()))
    (dolist (type (nth 1 def))
      (unless (and (not (null type)) (listp type)) (error (format nil "wrong variable definition form ~A" type)))
      (push vars (specify-type-value< type)))
    (setf (params for-var) (reverse vars))
    (setf (body   for-var) (specify-body (nthcdr 3 def)))
    for-var))

(defun specify-for-each (def)
  (when (or (< (length def) 4) (not (listp (nth 1 def)))) (error (format nil "wrong for each form ~A" def)))
  (let* ((counter (gensym "__lccVar"))
         (vari    (specify-expr (nth 1 def)))
         (argv    (specify-expr (nth 2 def)))
         (argc    (specify-expr (nth 3 def)))
         (for-var (make-specifier vari '|@FOREACH| nil counter nil nil argv argc '())))
    (setf (body for-var) (specify-body (nthcdr 4 def)))
    for-var))

(defun specify-function (def attrs)
  (let* ((is-static nil)
	     (is-declare nil)
	     (is-inline nil)
	     (is-extern nil)
         (is-method (if (key-eq (car def) '|method|) t nil))
	     (name (if is-method (specify-receiver< (nth 1 def)) (specify-name< (nth 1 def))))
	     (params (nth 2 def))
	     (r-> (nth 3 def))
	     (has-returns (and (consp r->) (key-eq (car r->) '|out|)))
	     (returns (if has-returns r->
		              (if (key-eq name '|main|) '(|out| |int|) '(|out| |void|))))
	     (body (if has-returns (nthcdr 4 def) (nthcdr 3 def)))
         (function-specifier nil))
    (dolist (attr attrs)
      (let ((name (car attr)))
	    (cond ((key-eq name '|static|)  (setq is-static t))
	          ((key-eq name '|decl|)    (setq is-declare t))
	          ((key-eq name '|inline|)  (setq is-inline t))
	          ((key-eq name '|extern|)  (setq is-extern t))
	          (t (error (format nil "unknown function attribute ~A" attr))))))
    (when (and is-declare is-inline) (error (format nil "inline functions should be defined ~A" def)))
    (when (< (length def) 3) (error (format nil "wrong function definition ~A" def)))
    (when (and is-declare body) (error (format nil "function declaration with body '~A' ~A" name (first body))))
    (let ((attributes '())
          (tmp-specifier nil))
	  (when is-extern   (push '|extern|   attributes))
	  (when is-inline   (push '|inline|   attributes))
	  (when is-static   (push '|static|   attributes))
	  (when is-declare  (push '|decl|     attributes))
	  (multiple-value-bind (const type modifier const-ptr variable array)
	      (specify-type< (cdr returns) t)
        (setq function-specifier (make-specifier name
                                   (if is-method '|@METHOD| '|@FUNC|)
                                   const type modifier const-ptr array nil attributes))
        (setq tmp-specifier *function-spec*)
        (setf *function-spec* function-specifier))
      (setf (body function-specifier) (specify-body body))
      (loop for param in params
            for i from 0 to (length params)
            do (let ((is-anonymous nil))
	              (multiple-value-bind (const type modifier const-ptr variable array default)
	                  (specify-type-value< param)
	                (when (or (null variable) (key-eq '_ variable))
                      (setq variable (gensym (format nil "_lccParam_~D" i))))
	                  ; (setq is-anonymous t))
                    (add-param
                        (make-specifier variable '@|PARAM| const type modifier const-ptr array nil nil is-anonymous)
                      function-specifier))))
      (setf *function-spec* tmp-specifier))
    function-specifier))

(defun specify-preprocessor (def attrs)
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (when (> (length def) 2) (error (format nil "wrong preprocessor definition ~A" def)))
  (let* ((preproc-specifier (make-specifier (specify-symbol-expr (car def)) '|@PREPROC| nil nil nil nil nil nil nil)))
    (setf (body preproc-specifier) (specify-expr (cadr def)))
    preproc-specifier))

(defun specify-include (def attrs)
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (when (< (length def) 2) (error (format nil "wrong include definition ~A" def)))
  (let ((heads (cdr def))
        (include-var (make-specifier (cadr def) '|@INCLUDE| nil nil nil nil nil nil nil)))
    (dolist (head heads)
      (unless (or (symbolp head) (stringp head)) (error "wrong inclusion")))
    (setf (params include-var) heads)
    include-var))

(defun specify-typedef (def attrs)
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (when (< (length def) 3) (error (format nil "syntax error ~A" def)))
  (multiple-value-bind (const type modifier const-ptr variable array)
      (specify-type< (nthcdr 1 def))
	(when (null variable) (error (format nil "syntax error ~A" def)))
    (make-specifier variable '|@TYPEDEF| const type modifier const-ptr array nil nil)))

(defun specify-enum (def attrs)
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (let* ((is-anonymous (or (= (length def) 1) (not (symbolp (nth 1 def)))))
	     (name (if is-anonymous (gensym "lcc#ENUM") (specify-name< (nth 1 def))))
	     (constants (if is-anonymous (nthcdr 1 def) (nthcdr 2 def)))
	     (enum-specifier (make-specifier name '|@ENUM| nil nil nil nil nil nil nil)))
    (setf (anonymous enum-specifier) is-anonymous)
    (loop for const in constants
	      with l = (length constants)
	      for i from 0 to l
	      do (progn
	           (unless (and (consp const) (symbolp (car const))) (error (format nil "syntax error ~A" const)))
	           (let ((key (car const))
		             (value (cdr const)))
		         (unless (or (null value) (numberp value) (symbolp value)) (error (format nil "syntax error ~A" const)))
		         (add-inner (make-specifier (specify-expr key) '|@VAR| nil nil nil nil nil
                                       (if (null value) nil (specify-expr value)) nil) enum-specifier))))
    enum-specifier))

(defun specify-struct (def attrs &key ((:nested is-nested) nil))
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (let* ((is-anonymous (or (= (length def) 1) (not (symbolp (nth 1 def)))))
	     (name (if is-anonymous (gensym "lcc#STRUCT") (specify-name< (nth 1 def))))
	     (clauses (if is-anonymous (nthcdr 1 def) (nthcdr 2 def)))
	     (struct-specifier (make-specifier name '|@STRUCT| nil nil nil nil nil nil nil)))
    (when (and is-anonymous (not is-nested)) (error (format nil "only nested structs could be anonymous")))
    (when (and (not is-anonymous) is-nested) (error (format nil "nested structs should be anonymous")))
    (setf (anonymous struct-specifier) is-anonymous)
    (let ((attributes '())
	      (declares '()))
      (dolist (clause clauses)
	    (if (consp clause)
	        (let ((construct (car clause)))
	          (cond ((find (char (symbol-name construct) 0) "@#")
		             (add-inner (specify-preprocessor clause attributes) struct-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|static|)   (push clause attributes))
		            ((key-eq construct '|decl|)     (push clause attributes))
		            ((key-eq construct '|inline|)   (push clause attributes))
		            ((key-eq construct '|auto|)     (push clause attributes))
		            ((key-eq construct '|register|) (push clause attributes))
		            ((key-eq construct '|extern|)   (push clause attributes))
		            ((key-eq construct '|member|)
		             (add-inner (specify-variable clause attributes) struct-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|enum|)
		             (add-inner (specify-enum     clause attributes) struct-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|struct|)
		             (add-inner (specify-struct   clause attributes :nested t) struct-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|union|)
		             (add-inner (specify-union    clause attributes :nested t) struct-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|declare|)
		             (when (= (length clause) 1)
		               (error (format nil "declare needs a name of variable for anonymous struct")))
		             (push clause declares))
		            (t (error (format nil "unknown clause ~A in struct ~A" construct name)))))
	        (error (format nil "syntax error ~A" clause))))
      (when (and (not is-anonymous) (> (length declares) 0))
	    (error (format nil "declare must be inside anonymous struct ~A" name)))
      (dolist (decl (reverse declares))
        (let ((var-spec (specify-variable (push '|var| decl) '())))
          (setf (construct var-spec) '|@DECLARE|)
	      (add-param var-spec struct-specifier)
          (setf (typeof var-spec) '||))))
    struct-specifier))

(defun specify-union (def attrs &key ((:nested is-nested) nil))
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (let* ((is-anonymous (or (= (length def) 1) (not (symbolp (nth 1 def)))))
	     (name (if is-anonymous (gensym "lcc#UNION") (specify-name< (nth 1 def))))
	     (clauses (if is-anonymous (nthcdr 1 def) (nthcdr 2 def)))
	     (union-specifier (make-specifier name '|@UNION| nil nil nil nil nil nil nil)))
    (when (and is-anonymous (not is-nested)) (error (format nil "only nested unions could be anonymous")))
    (setf (anonymous union-specifier) is-anonymous)
    (let ((attributes '())
	      (declares '()))
      (dolist (clause clauses)
	    (if (consp clause)
	        (let ((construct (car clause)))
	          (cond ((find (char (symbol-name construct) 0) "@#")
		             (add-inner (specify-preprocessor clause attributes) union-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|member|)
		             (add-inner (specify-variable clause attributes) union-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|struct|)
		             (add-inner (specify-struct   clause attributes :nested t) union-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|union|)
		             (add-inner (specify-union    clause attributes :nested t) union-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|declare|)
		             (when (= (length clause) 1)
		               (error (format nil "declare needs a name of variable for anonymous union")))
		             (push clause declares))
		            (t (error (format nil "unknown clause ~A in union ~A" construct name)))))
	        (error (format nil "syntax error ~A" clause))))
      (when (and (not is-anonymous) (> (length declares) 0))
	    (error (format nil "declare must be inside anonymous union ~A" name)))
      (dolist (decl (reverse declares))
        (let ((var-spec (specify-variable (push '|var| decl) '())))
          (setf (construct var-spec) '|@DECLARE|)
	      (add-param var-spec union-specifier)
          (setf (typeof var-spec) '||))))
      union-specifier))

(defun specify-guard (def attrs)
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (let* ((name (specify-name< (nth 1 def)))
	     (clauses (nthcdr 2 def))
	     (guard-specifier (make-specifier name '|@GUARD| nil nil nil nil nil nil nil)))
    (let ((attributes '()))
      (dolist (clause clauses)
	    (if (consp clause)
	        (let ((construct (car clause)))
	          (cond ((find (char (symbol-name construct) 0) "@#")
		             (add-inner (specify-preprocessor clause attributes) guard-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|static|)   (push clause attributes))
		            ((key-eq construct '|decl|)     (push clause attributes))
		            ((key-eq construct '|inline|)   (push clause attributes))
		            ((key-eq construct '|auto|)     (push clause attributes))
		            ((key-eq construct '|register|) (push clause attributes))
		            ((key-eq construct '|extern|)   (push clause attributes))
		            ((key-eq construct '|include|)  (setq attributes '()))
		            ((key-eq construct '|guard|)
		             (add-inner (specify-guard    clause attributes) guard-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|var|)
		             (add-inner (specify-variable clause attributes) guard-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|func|)
		             (add-inner (specify-function clause attributes) guard-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|method|)
		             (add-inner (specify-function clause attributes) guard-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|enum|)
		             (add-inner (specify-enum     clause attributes) guard-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|struct|)
		             (add-inner (specify-struct   clause attributes) guard-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|union|)
		             (add-inner (specify-union    clause attributes) guard-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|typedef|)
		             (add-inner (specify-typedef  clause attributes) guard-specifier)
		             (setq attributes '()))
		            (t (error (format nil "unknown clause ~A in guard ~A" construct name)))))
	        (error (format nil "syntax error ~A" clause)))))
    guard-specifier))
