(in-package :cicili)

;;;; specifier
(defclass sp ()
  ((name          :initarg :name      :accessor name)
   (construct     :initarg :construct :accessor construct)
   (const         :initarg :const     :accessor const)
   (typeof        :initarg :typeof    :accessor typeof)
   (modifier      :initarg :modifier  :accessor modifier)
   (const-ptr     :initarg :const-ptr :accessor const-ptr)
   (array-def     :initarg :array-def :accessor array-def)
   (default       :initarg :default   :accessor default)
   (keys          :initform nil :accessor keys) ; resolver keys
   (module        :initform nil :accessor module)
   (unique        :initform nil :accessor unique)
   (attrs         :initarg :attrs     :accessor attrs)
   (anonymous     :initarg :anonymous :initform nil :accessor anonymous)
   (body          :initform nil :accessor body)
   (params        :initform nil :accessor params)
   (lambdas       :initform nil :accessor lambdas)
   (inners        :initform nil :accessor inners)))

(defun make-specifier (name construct const typeof modifier const-ptr array-def default attrs &optional (anonymous nil))
  (let ((instance (make-instance 'sp
				                 :name      name
				                 :construct construct
				                 :const     const
				                 :typeof    typeof
				                 :modifier  modifier
				                 :const-ptr const-ptr
				                 :array-def array-def
				                 :default   default
				                 :attrs     attrs
				                 :anonymous anonymous)))
    (setf (keys instance) (make-hash-table :test 'eql))
    
    (cond ((eql construct '|@ATOM|)
           (when (and *module-path* (eql typeof '|@SYMBOL|))
             (setf (module instance) *module-path*)
             (setf (unique instance) (free-name *module-path* name)))
 	       (setf (inners  instance)     (make-hash-table :test 'eql))) ; contains type inline struct
          ((eql construct '|@TYPEDEF|)
           (setf (inners  instance)     (make-hash-table :test 'eql))) ; contains type inline struct
          ((eql construct '|@VAR|)
           (when *module-path*
             (setf (module instance) *module-path*)
             (setf (unique instance) (free-name *module-path* name)))
 	       (setf (inners  instance)     (make-hash-table :test 'eql))) ; contains type inline struct
          ((eql construct '|@LET|)
	       (setf (params  instance)     (make-hash-table :test 'eql)))
          ((eql construct '|@LETN|)
	       (setf (params  instance)     (make-hash-table :test 'eql)))
	      ((eql construct '|@FOR|)
	       (setf (params  instance)     (make-hash-table :test 'eql)))
	      ((eql construct '|@FUNC|)
           (when *module-path*
             (setf (module instance) *module-path*)
             (setf (unique instance)
                   (if (symbolp name)
                       (free-name *module-path* name)
                       (intern (make-shared-name (symbol-name (free-name *module-path* (car name))) (cdr name))))))
	       (setf (params  instance)     (make-hash-table :test 'eql))
 	       (setf (inners  instance)     (make-hash-table :test 'eql))) ; contains lambdas
	      ((eql construct '|@METHOD|)
           (when *module-path*
             (setf (module instance) *module-path*)
             (setf (unique instance)
                   (intern (make-method-name (symbol-name (free-name *module-path* (car name))) (cdr name)))))
	       (setf (params  instance)     (make-hash-table :test 'eql))
 	       (setf (inners  instance)     (make-hash-table :test 'eql))) ; contains lambdas
	      ((eql construct '|@ENUM|)
           (when *module-path*
             (setf (module instance) *module-path*)
             (setf (unique instance) (free-name *module-path* name)))
 	       (setf (inners  instance)     (make-hash-table :test 'eql)))
	      ((eql construct '|@STRUCT|)
           (when *module-path*
             (setf (module instance) *module-path*)
             (setf (unique instance) (free-name *module-path* name)))
	       (setf (params  instance)     (make-hash-table :test 'eql))
	       (setf (inners  instance)     (make-hash-table :test 'eql)))
	      ((eql construct '|@UNION|)
           (when *module-path*
             (setf (module instance) *module-path*)
             (setf (unique instance) (free-name *module-path* name)))
	       (setf (params  instance)     (make-hash-table :test 'eql))
	       (setf (inners  instance)     (make-hash-table :test 'eql)))
	      ((eql construct '|@GUARD|)
	       (setf (inners  instance)     (make-hash-table :test 'eql)))
	      ((eql construct '|@MODULE|)
           (when *module-path*
             (setf (module instance) *module-path*)
             (setf (unique instance) (free-name *module-path* name)))
           (setf (inners  instance)     (make-hash-table :test 'eql)))
	      ((eql construct '|@TARGET|)
	       (setf (inners  instance)     (make-hash-table :test 'eql)))
	      (t t))
    instance))

(defun add-param (spec parent)
  (if (gethash (name spec) (params parent))
      (error (format nil "paramter exists: ~A for ~A" spec parent))
      (setf (gethash (name spec) (params parent)) spec)))

(defun add-inner (spec parent)
  (let ((name (name spec)))
    (when (find-if #'(lambda (attr) (if (key-eq '|decl| (car attr)) t nil)) (attrs spec))
      (setq name (intern (format nil "~A-~A" '|decl| (name spec)))))
    (if (gethash name (inners parent))
        (error (format nil "inner exists: ~A in ~A" spec parent))
        (setf (gethash name (inners parent)) spec))))
  
;;;; specifier
(defmethod print-object ((spec sp) stream)
  (print-unreadable-object (spec stream :type t :identity t)
    (princ
     (format nil
       "~A ~:[~A ~;~*~]~:[~A ~;~*~]~:[~A ~;~*~]~:[~A ~;~*~]~:[~A ~;~*~]~:[~{~A~} ~;~*~]~:[= ~A ~;~*~]~:[{~{~A~^ ~}}~;~*~]~:[~;A~]"
	   (construct spec)
       (null (name spec))      (name spec)
       (null (const spec))     (const spec)
       (null (typeof spec))    (typeof spec)
       (null (modifier spec))  (modifier spec)
       (null (const-ptr spec)) (const-ptr spec)
	   (null (array-def spec)) (array-def spec)
       (null (default spec))   (default spec)
	   (null (attrs spec))     (attrs spec)
       (anonymous spec))
     stream)))

(defun copy-specifiers (table)
  (if (null table)
      (make-hash-table)
      (let ((new-table (make-hash-table
                        :test (hash-table-test table)
                        :size (hash-table-size table)
		                :rehash-size (hash-table-rehash-size table)
		                :rehash-threshold (hash-table-rehash-threshold table))))
        (maphash #'(lambda(key value)
                     (setf (gethash key new-table) value))
                 table)
        new-table)))

(defun print-specifier (spec &optional (lvl 0))
  (format t
          "~A~A ~A ~:[~A ~;~*~]~:[~A ~;~*~]~:[~A ~;~*~]~:[~A ~;~*~]~:[~{~A~} ~;~*~]~:[= ~A ~;~*~]~:[{~{~A~^ ~}}~;~*~]~:[~;A~]~%"
	      (indent lvl) (construct spec) (name spec) (null (const spec)) (const spec) (null (typeof spec)) (typeof spec)
	      (null (modifier spec)) (modifier spec) (null (const-ptr spec)) (const-ptr spec)
	      (null (array-def spec)) (array-def spec) (null (default spec)) (default spec)
	      (null (attrs spec)) (attrs spec) (anonymous spec))
  (let ((params  (params  spec))
	    (inners  (inners  spec)))
    (when params  (print-specifiers params  (+ 1 lvl)))
    (when inners  (print-specifiers inners  (+ 1 lvl)))))

(defun print-specifiers (table &optional (lvl 0))
  (maphash #'(lambda (k v) (print-specifier v lvl)) table))

(defun specify-decl-name< (name)
  (let ((name (intern (substitute #\_ #\^ (symbol-name name)))))
    (if (is-decl-name name) name
        (error (format nil "wrong name ~S" name)))))

(defun specify-name< (name)
  (let ((name (intern (substitute #\_ #\^ (symbol-name name)))))
    (if (is-name name) (specify-typeof< name)
        (error (format nil "wrong name ~S" name)))))

(defun specify-receiver< (name)
  (let ((parts (str:split "->" (string name))))
    (unless (= (length parts) 2) (error (format nil "wrong receiver ~S" name)))
    (let ((receiver (intern (nth 0 parts)))
          (method (intern (nth 1 parts))))
      (if (and (is-name receiver) (is-symbol method))
          (cons (specify-name< receiver) (specify-name< method))
          (error (format nil "wrong receiver ~S" name))))))

(defun specify-type-name< (name)
  (cond ((key-eq name '|uchar|)  "unsigned char")
	    ((key-eq name '|ushort|) "unsigned short")
	    ((key-eq name '|uint|)   "unsigned int")
	    ((key-eq name '|ulong|)  "unsigned long")
	    ((key-eq name '|llong|)  "long long")
	    ((key-eq name '|ullong|) "unsigned long long")
	    ((key-eq name '|i8|)     "int8_t")
	    ((key-eq name '|u8|)     "uint8_t")
	    ((key-eq name '|i16|)    "int16_t")
	    ((key-eq name '|u16|)    "uint16_t")
	    ((key-eq name '|i32|)    "int32_t")
	    ((key-eq name '|u32|)    "uint32_t")
	    ((key-eq name '|i64|)    "int64_t")
	    ((key-eq name '|u64|)    "uint64_t")
	    ((key-eq name '|i128|)   "__int128")
	    ((key-eq name '|u128|)   "unsigned __int128")
	    ((key-eq name '|real|)   "long double")
	    ((key-eq name '|auto|)   "__auto_type")
	    (t (specify-name< name))))

(defun specify-name-with-module< (symbol)
  (let* ((str-name (symbol-name symbol))
         (count$ (str:count-substring "/" str-name)))
    (cond ((str:starts-with-p "/" str-name)
           (intern str-name))
          ((> count$ 0) (free-name (map 'list #'intern (str:split "/" str-name)) nil))
          (t symbol))))

;;; type part of any declaration
(defun specify-typeof< (type)
  (if (atom type)
      (if (typep type 'sp)
          (progn
            (setf (name type) (specify-name-with-module< (name type)))
            type)
          (specify-name-with-module< type))
      (let ((ty (car type)))
        (cond ((or (key-eq '|struct| ty) (key-eq '|union| ty))
               (list ty (specify-name-with-module< (cadr type))))
              ((key-eq '|typeof| ty) (specify-typeof-expr type))
              ((key-eq '|t<>| ty)    (specify-expr type))
              ((key-eq '$$ ty)       (specify-expr type))
              ((key-eq '|code| ty)   (specify-expr type))
              ((and (null *function-spec*) *typedef-spec* (key-eq 'QUOTE ty)) ; inline struct global typedef
               (let* ((sname (gensym "__ciciliS_"))
                      (struct-spec (specify-struct (append (list '|struct| sname) (cadr type)) '() :inline t)))
                 (add-inner struct-spec *typedef-spec*)
                 (list '|struct| (if *module-path* (free-name *module-path* sname) sname))))
              ((and (null *function-spec*) *variable-spec* (key-eq 'QUOTE ty)) ; inline struct global var
               (let* ((sname (gensym "__ciciliS_"))
                      (struct-spec (specify-struct (append (list '|struct| sname) (cadr type)) '() :inline t)))
                 (add-inner struct-spec *variable-spec*)
                 (list '|struct| (if *module-path* (free-name *module-path* sname) sname))))
              ((and *function-outp* *function-spec* (key-eq 'QUOTE ty)) ; inline struct as function out type
               (let* ((fname (name *function-spec*))
                      (cname (if (listp fname) (make-method-name (car fname) (cdr fname)) (symbol-name fname)))
                      (sname (if (str:starts-with-p "__ciciliS_" cname)
                                 (intern (format nil "~A_" cname))
                                 (intern (format nil "__ciciliS_~A_" cname))))
                      (struct-spec (specify-struct (append (list '|struct| sname) (cadr type)) '() :inline t)))
                 (setf (default struct-spec) t) ; means struct as out type
                 (add-inner struct-spec *function-spec*)
                 (list '|struct| (if *module-path* (free-name *module-path* sname) sname))))
              ((and *function-spec* (key-eq 'QUOTE ty)) ; inline struct inside function body
               (let* ((sname (gensym "__ciciliS_"))
                      (struct-spec (specify-struct (append (list '|struct| sname) (cadr type)) '() :inline t)))
                 (add-inner struct-spec *function-spec*)
                 (list '|struct| (if *module-path* (free-name *module-path* sname) sname))))
              (t (let ((bd (expand-macros type)))
                   (if (eq bd type)
                       type
                       (specify-typeof< bd))))
              ))))

(defun specify-type< (def)
  (let* ((desc (expand-macros def))
         (len (if (listp desc) (length desc) 1))
	     (const nil)
	     (type nil)
	     (modifier nil)
	     (const-ptr nil)
	     (variable nil)
	     (array nil)
	     (status 0))

    ;; code has unextractable content
    (when (and (listp desc) (key-eq (car desc) '|code|))
      (return-from specify-type< (values nil (specify-code-expr desc) nil nil nil nil)))
    
    (cond ((symbolp desc) (setq type desc))
	      ((= len 1) (setq type (nth 0 desc)))
	      ((= len 2) (if (key-eq (nth 0 desc) '|const|)
			             (progn
			               (setq const (nth 0 desc))
			               (setq type (nth 1 desc)))
		                 (if (find (nth 1 desc) *modifiers* :test #'key-eq)
			                 (progn
			                   (setq type (nth 0 desc))
			                   (setq modifier (nth 1 desc)))
			                 (if (is-array (nth 1 desc))
			                     (progn
			                       (setq type (nth 0 desc))
			                       (setq array (nth 1 desc)))
			                     (progn
			                       (setq type (nth 0 desc))
			                       (setq variable (nth 1 desc)))))))
	      ((= len 3) (if (key-eq (nth 0 desc) '|func|)
                         (progn
                           (setq type (nth 0 desc))
		                   (setq modifier '|*|)
                           (setq variable (nth 1 desc))
				           (setq array (specify-function desc (list '(|decl|)))))
                         (if (key-eq (nth 0 desc) '|const|)
			                 (if (find (nth 2 desc) *modifiers* :test #'key-eq) 
			                     (progn
			                       (setq const (nth 0 desc))
			                       (setq type (nth 1 desc))
			                       (setq modifier (nth 2 desc)))
			                     (if (is-array (nth 2 desc))
			                         (progn
				                       (setq const (nth 0 desc))
				                       (setq type (nth 1 desc))
				                       (setq array (nth 2 desc)))
			                         (progn
			                           (setq const (nth 0 desc))
			                           (setq type (nth 1 desc))
			                           (setq variable (nth 2 desc)))))
		                     (if (find (nth 1 desc) *modifiers* :test #'key-eq)
			                     (if (key-eq (nth 2 desc) '|const|)
			                         (progn
				                       (setq type (nth 0 desc))
				                       (setq modifier (nth 1 desc))
				                       (setq const-ptr (nth 2 desc)))
			                         (if (is-array (nth 2 desc))
				                         (progn
				                           (setq type (nth 0 desc))
				                           (setq modifier (nth 1 desc))
				                           (setq array (nth 2 desc)))
			                             (progn
				                           (setq type (nth 0 desc))
				                           (setq modifier (nth 1 desc))
				                           (setq variable (nth 2 desc)))))
			                     (progn
			                       (setq type (nth 0 desc))
			                       (setq variable (nth 1 desc))
			                       (setq array (nth 2 desc)))))))
	      ((= len 4) (if (key-eq (nth 0 desc) '|func|)
                         (progn
                           (setq type (nth 0 desc))
		                   (setq modifier '|*|)
                           (setq variable (nth 1 desc))
				           (setq array (specify-function desc (list '(|decl|)))))
                         (if (key-eq (nth 0 desc) '|const|)
                             (if (key-eq (nth 1 desc) '|func|)
                                 (progn
                                   (setq const (nth 0 desc))
                                   (setq type (nth 1 desc))
		                           (setq modifier '|*|)
                                   (setq variable (nth 2 desc))
				                   (setq array (specify-function (cdr desc) (list '(|decl|)))))
                                 (if (find (nth 2 desc) *modifiers* :test #'key-eq)
			                         (if (key-eq (nth 3 desc) '|const|)
				                         (progn
				                           (setq const (nth 0 desc))
				                           (setq type (nth 1 desc))
				                           (setq modifier (nth 2 desc))
				                           (setq const-ptr (nth 3 desc)))
			                             (if (is-array (nth 3 desc))
				                             (progn
				                               (setq const (nth 0 desc))
				                               (setq type (nth 1 desc))
				                               (setq modifier (nth 2 desc))
				                               (setq array (nth 3 desc)))
				                             (progn
				                               (setq const (nth 0 desc))
				                               (setq type (nth 1 desc))
				                               (setq modifier (nth 2 desc))
				                               (setq variable (nth 3 desc)))))
		                             (if (key-eq (nth 2 desc) '|const|)
			                             (if (is-array (nth 3 desc))
			                                 (progn
				                               (setq type (nth 0 desc))
				                               (setq modifier (nth 1 desc))
				                               (setq const-ptr (nth 2 desc))
				                               (setq array (nth 3 desc)))
			                                 (progn
			                                   (setq type (nth 0 desc))
			                                   (setq modifier (nth 1 desc))
			                                   (setq const-ptr (nth 2 desc))
			                                   (setq variable (nth 3 desc))))
                                         (if (is-array (nth 3 desc))
			                                 (progn
                                               (setq const (nth 0 desc))
				                               (setq type (nth 1 desc))
				                               (setq variable (nth 2 desc))
                                               (setq array (nth 3 desc)))
			                                 (progn
			                                   (setq type (nth 0 desc))
			                                   (setq modifier (nth 1 desc))
			                                   (setq variable (nth 2 desc))
			                                   (setq array (nth 3 desc)))))))
                             (if (find (nth 1 desc) *modifiers* :test #'key-eq)
			                     (if (key-eq (nth 2 desc) '|const|)
			                         (if (is-array (nth 3 desc))
				                         (progn
				                           (setq type (nth 0 desc))
				                           (setq modifier (nth 1 desc))
				                           (setq const-ptr (nth 2 desc))
                                           (setq array (nth 3 desc)))
				                         (progn
				                           (setq type (nth 0 desc))
				                           (setq modifier (nth 1 desc))
				                           (setq const-ptr (nth 2 desc))
                                           (setq variable (nth 3 desc))))
                                     (progn
                                       (setq type (nth 0 desc))
				                       (setq modifier (nth 1 desc))
				                       (setq variable (nth 2 desc))
                                       (setq array (nth 3 desc))))
                                 (progn
                                   (setq type (nth 0 desc))
				                   (setq variable (nth 1 desc))
                                   (setq array (list (nth 2 desc) (nth 3 desc))))))))
	       ((= len 5) (if (key-eq (nth 0 desc) '|const|)
                          (if (key-eq (nth 1 desc) '|func|)
                              (progn
                                (setq const (nth 0 desc))
                                (setq type (nth 1 desc))
		                        (setq modifier '|*|)
		                        (setq variable (nth 2 desc))
				                (setq array (specify-function (cdr desc) (List '(|decl|)))))
                              (if (is-array (nth 4 desc))
                                  (if (is-array (nth 3 desc))
			                          (progn
                                        (setq const (nth 0 desc))
                                        (setq type (nth 1 desc))
				                        (setq variable (nth 2 desc))
                                        (setq array (list (nth 3 desc) (nth 4 desc))))
                                      (progn
                                        (setq const (nth 0 desc))
			                            (setq type (nth 1 desc))
			                            (setq modifier (nth 2 desc))
			                            (setq variable (nth 3 desc))
                                        (setq array (nth 4 desc))))
                                  (progn
			                        (setq const (nth 0 desc))
			                        (setq type (nth 1 desc))
			                        (setq modifier (nth 2 desc))
			                        (setq const-ptr (nth 3 desc))
			                        (setq variable (nth 4 desc)))))
			              (progn
			                (setq type (nth 0 desc))
			                (setq modifier (nth 1 desc))
			                (setq const-ptr (nth 2 desc))
                            (setq variable (nth 3 desc))
			                (setq array (nth 4 desc)))))
	      ((= len 6) (progn
		               (setq const (nth 0 desc))
		               (setq type (nth 1 desc))
		               (setq modifier (nth 2 desc))
		               (setq const-ptr (nth 3 desc))
		               (setq variable (nth 4 desc))
		               (setq array (nth 5 desc))))
	      (t (setq status -1)))

    (setq type (specify-typeof< type))
    (unless (or (null const)     (key-eq const '|const|)) (setq status -2))
    (unless (or (null modifier)
              (key-eq modifier '&)
              (key-eq modifier '*)
              (key-eq modifier '**)
              (key-eq modifier '***))
      (setq status -3))
    (unless (or (null const-ptr) (key-eq const-ptr '|const|)) (setq status -4))
    (unless (or (null const-ptr)
              (key-eq modifier '*)
              (key-eq modifier '**)
              (key-eq modifier '***))
      (setq status -5))
    ;; (when noVar (unless (null variable) (setq status -6)))
    (if (key-eq type '|func|) ; func type
        (progn
          (when (null array) (setq status -7))
          (setq array (list array)))
        (if (and (= (length array) 2) (is-array (car array)) (is-array (cadr array)))
            (setq array (list (specify-expr (nth 1 (car array))) (specify-expr (nth 1 (cadr array)))))
            (when (= (length array) 3)
              (setq array (list (specify-expr (nth 1 array)))))))
    (when   (< status 0) (error (format nil "wrong type descriptor ~D ~A" status desc)))
    (values const (when type (specify-name< type))
            modifier const-ptr (when variable (specify-name< variable)) array)))

(defun specify-type-value< (desc)
  (let ((l (cdr (last desc)))
	    (wl (without-last desc)))
    (cond ((and (listp l) (> (length desc) 2) (key-eq (nth (- (length desc) 2) desc) 'FUNCTION)) ; #' function initializer
	       (setq l (nth (- (length desc) 1) desc))
	       (multiple-value-bind (const type modifier const-ptr variable array)
		       (specify-type< (without-last wl))
		     (values const type modifier const-ptr variable array l)))
          ((and (listp l) (> (length desc) 2) (key-eq (nth (- (length desc) 2) desc) 'QUOTE)) ; ' list and lambda initializer
           (let* ((def (nthcdr (- (length desc) 2) desc))
                  (quoted (cadr def)))
             (cond ((key-eq (car quoted) '|lambda|) ; lambda initializer
                    (multiple-value-bind (const type modifier const-ptr variable array)
		                (specify-type< (without-last wl))
		              (values const type modifier const-ptr variable array def)))
                   ((key-eq (car quoted) '|lambda*|) ; lambda* initializer
                    (multiple-value-bind (const type modifier const-ptr variable array)
		                (specify-type< (without-last wl))
		              (values const type modifier const-ptr variable array def)))
                   ((key-eq (car quoted) '|closure*|) ; closure* initializer
                    (multiple-value-bind (const type modifier const-ptr variable array)
		                (specify-type< (without-last wl))
		              (values const type modifier const-ptr variable array def)))
                   (t ; list initializer
	                (setq l (nthcdr (- (length desc) 2) desc))
		            (multiple-value-bind (const type modifier const-ptr variable array)
		                (specify-type< (without-last wl))
		              (values const type modifier const-ptr variable array l))))))
	      ((listp l) ; without default
           (multiple-value-bind (const type modifier const-ptr variable array)
               (specify-type< desc)
             (values const type modifier const-ptr variable array nil)))
	      (t (multiple-value-bind (const type modifier const-ptr variable array)
	             (specify-type< wl)
	           (values const type modifier const-ptr variable array l))))))

(defun specify-nil-expr ()
  (make-specifier '|NULL| '|@ATOM| nil '|@SYMBOL| nil nil nil nil '()))

(defun specify-number-expr (def)
  (make-specifier def '|@ATOM| nil '|@NUMBER| nil nil nil nil '()))

(defun specify-character-expr (def)
  (if (eql def #\Null)
      (make-specifier "\\0" '|@ATOM| nil '|@CHAR| nil nil nil nil '())
      (make-specifier def   '|@ATOM| nil '|@CHAR| nil nil nil nil '())))

(defun specify-string-expr (def)
  (make-specifier (format nil "\"~A\"" def) '|@ATOM| nil '|@STRING| nil nil nil nil '()))

(defun specify-symbol-expr (def)
  (make-specifier (specify-name< def) '|@ATOM| nil '|@SYMBOL| nil nil nil nil '()))

(defun specify-atom-expr (def)
  (cond ((null       def) (make-specifier nil '|@NIL| nil nil nil nil nil nil '())) ; ignore nil values like ([ NIL ])
        ((key-eq     def '|nil|) (specify-nil-expr))
        ((key-eq     def '|NIL|) (specify-nil-expr))
        ((numberp    def)        (specify-number-expr def))
	    ((characterp def)        (specify-character-expr def))
	    ((stringp    def)        (specify-string-expr def))
        ((and (symbolp def) (is-symbol def))
	     (if (eql (char (symbol-name def) 0) #\0) ; 0x12af..
	         (specify-symbol-expr def)
             (specify-symbol-expr def))) ; name
        ((symbolp def) (specify-symbol-expr def)) ; operators
	    (t (error (format nil "syntax error \"~A\"" def)))))

(defun specify-code-expr (def)
  (unless (= (length def) 2) (error (format nil "wrong code form ~A" def)))
  (let ((pure (cadr def)))
    (cond ((atom pure)
           (make-specifier nil '|@CODE| nil nil nil nil nil pure '()))
	      ((key-eq (car pure) 'QUOTE)
           (make-specifier nil '|@CODE| nil nil nil nil nil
                           (loop for item in (cadr pure)
                                 collect (if (atom item)
                                             (make-specifier nil '|@CODE| nil nil nil nil nil item '())
                                             (specify-code-expr item))) '()))
          ((key-eq (car pure) '|code|)
           (specify-code-expr pure))
          (t (error (format nil "wrong code form ~A" def))))))

(defun specify-list-expr (def)
  (make-specifier nil '|@LIST| nil nil nil nil nil (loop for item in def collect (specify-expr item)) '()))

(defun specify-unary-expr (def)
  (unless (= (length def) 2) (error (format nil "wrong unary form ~A" def)))
  (let* ((oprt (car def))
	     (name (symbol-name oprt))
	     (is-postfix nil))
    (cond ((key-eq oprt '|not|) (setq oprt '|!|))
	      ((key-eq oprt '|cof|) (setq oprt '|*|))
          ((key-eq oprt '|aof|) (setq oprt '|&|))
          ((key-eq oprt '|stringize|) (setq oprt '|#|))  ; maybe inside a macro
          ((key-eq oprt '|1+|)  (setq oprt '|++|) (setq is-postfix t))
	      ((key-eq oprt '|1-|)  (setq oprt '|--|) (setq is-postfix t)))
    (if is-postfix
        (make-specifier oprt '|@UNARY| nil nil t   nil nil (specify-expr (cadr def)) '()) ; 1+ 1-
        (make-specifier oprt '|@UNARY| nil nil nil nil nil (specify-expr (cadr def)) '()))))

(defun specify-operator-expr (def)
  (when (< (length def) 3) (error (format nil "wrong operator form ~A" def)))
  (let ((opr (car def))
	    (oprnds '()))
    (cond ((key-eq opr '|and|)    (setq opr '|&&|))
	      ((key-eq opr '|or|)     (setq opr '|\|\||))
	      ((key-eq opr '|bitand|) (setq opr '|&|))
	      ((key-eq opr '|bitor|)  (setq opr '|\||))
	      ((key-eq opr '|xor|)    (setq opr '|^|)))
    (dolist (oprnd (cdr def))
      (push opr oprnds)
      (push oprnd oprnds))
    (make-specifier opr '|@OPR| nil nil nil nil nil
                    (loop for frm in (cdr (reverse oprnds))
                          for i from 0 to (length oprnds)
                          collect (if (= (mod i 2) 0)
                                      (specify-expr frm)
                                      (make-specifier frm '|@SYMBOL| nil '|@SYMBOL| nil nil nil nil '()))) '())))

(defun specify-assignment-expr (def)
  (unless (= (length def) 3) (error (format nil "wrong assignment form ~A" def)))
  (let ((opr (car def))
	    (oprnds '()))
    (dolist (oprnd (cdr def))
      (push opr oprnds)
      (push oprnd oprnds))
    (make-specifier opr '|@ASSIGN| nil nil nil nil nil
                    (loop for frm in (cdr (reverse oprnds))
                          collect (specify-expr frm))'())))

(defun specify-nth-expr (def)
  (unless (= (length def) 3) (error (format nil "wrong nth form ~A" def)))
  (make-specifier (specify-expr (nth 1 def)) '|@NTH| nil nil nil nil nil (specify-expr (nth 2 def)) '()))

(defun specify-?-expr (def)
  (unless (= (length def) 4) (error (format nil "wrong ? form ~A" def)))
  (make-specifier (specify-expr (nth 1 def)) '|@?| nil nil nil nil nil
                  (list (specify-expr (nth 2 def)) (specify-expr (nth 3 def))) '()))

(defun specify-cast-expr (def)
  (unless (= (length def) 3) (error (format nil "wrong cast form ~A" def)))
  (let ((ty (nth 1 def)))
    (multiple-value-bind (const type modifier const-ptr variable array)
	    (specify-type<
            (specify-typeof< (if (and (listp ty) (key-eq '|typeof| (car ty))) (list ty) ty)))
      (make-specifier
          (specify-decl-name< variable)
        '|@CAST| const type modifier const-ptr array (specify-expr (nth 2 def)) '()))))

(defun specify-$-expr (def)
  (let ((len (length def))
        (member (car (last def))))
    (unless (>= len 3) (error (format nil "wrong access member $ form ~A" def)))
    (unless (is-symbol member) (error (format nil "wrong access member name ~A" def)))
    (make-specifier (if (> len 3)
                        (specify-expr (without-last def))
                        (specify-expr (car (last (without-last def)))))
      '|@$| nil nil nil nil nil
      (specify-symbol-expr member) '())))

(defun specify-->-expr (def no-call)
  (if no-call ; -->
      (unless (= (length def) 3) (error (format nil "wrong access method name --> form ~A" def)))
      (when   (< (length def) 3) (error (format nil "wrong access method -> form ~A" def))))
  (let ((method-var (make-specifier (specify-expr (expand-macros (nth 1 def)))
                      (if no-call '|@-->| '|@->|) nil nil nil nil nil
                      (specify-expr (expand-macros (nth 2 def))) '())))
    (setf (body method-var) (specify-list-expr (nthcdr 3 def)))
    method-var))

(defun specify-=>-expr (def)
  (when (< (length def) 3) (error (format nil "wrong access member function => form ~A" def)))
  ;; (unless (is-symbol (nth 2 def)) (error (format nil "wrong access method name ~A" def)))
  (let ((method-var (make-specifier (specify-expr (nth 1 def)) '|@=>| nil nil nil nil nil
                                    ;; (specify-symbol-expr (nth 2 def)) '())))
                                    (specify-expr (nth 2 def)) '())))
    (setf (body method-var) (specify-list-expr (nthcdr 3 def)))
    method-var))

(defun specify-sizeof-expr (def)
  (when (< (length def) 2) (error (format nil "sizeof syntax error ~A" def)))
  (if (listp (second def))
      (make-specifier nil '|@SIZEOF| nil nil nil nil nil (specify-expr (expand-macros (second def))) '())
      (multiple-value-bind (const type modifier const-ptr variable array)
          (specify-type< (cdr def))
        (make-specifier (specify-decl-name< variable) '|@SIZEOF| const type modifier const-ptr array nil '()))))

(defun specify-typeof-expr (def)
  (when (< (length def) 2) (error (format nil "typeof syntax error ~A" def)))
  (make-specifier nil '|@TYPEOF| nil nil nil nil nil (specify-expr (expand-macros (cadr def))) '()))

;; (((<> a b) 1) 2)
;; ((<> a b) 1)
;; (<> a b)
;; a_b
;; (a_b 1)
;; if returns a_b_0
;; then       (a_b_0 2) ; curry lambda call form
;; else       (a_b 1 2)

;; (((p0 2) 3) 4)
;; ((p0 2) 3)
;; (p0 2)
;; p1
(defun specify-call-expand (def)
  (let ((def (expand-macros def)))
    (if (symbolp def)
        def
        (let ((expr
                  (let ((symb (nth 0 def)))
                    (if (symbolp symb)
                        (if (> (length def) 1)
                            (let ((app (expand-macros (list symb (nth 1 def)))))
                              (if (symbolp app)
                                  (if (> (length def) 2)
                                      (specify-call-expand (append (list app) (nthcdr 2 def))))
                                  app)
                              def))
                        def)
                    (let ((app (specify-call-expand symb)))
                      (if (eql app symb)
                          def
                          (specify-call-expand (append (list app) (nthcdr 1 def))))))))
          (let ((result (expand-macros expr)))
            (if (eql expr result)
                result
                (specify-call-expand result)))))))
        
(defun specify-call-expr (def) ; consumes all args whether output of a lambda or a fn specification be another macro
  (when (key-eq (car def) '|aof|) (error (format nil "'address of' aka 'aof' takes only one argument ~A" def)))
  (let ((app (specify-call-expand def)))
    (if (eql app def)
        (if (symbolp app)
            (error (format nil "invalid call ~A from ~A" app def))
            (make-specifier (specify-expr (nth 0 app)) '|@CALL| nil nil nil nil nil
                            (if (> (length app) 1)
                                (loop for item in (nthcdr 1 app)
                                      collect (specify-expr item))
                                nil)
                            '()))
        (specify-expr app))))

;; var clause only allowed as global vars but inside macros for complex situation
;; use let clause instead
(defun specify-variable (def attrs)
  (let* ((is-register nil)
	     (is-volatile nil)
	     (is-thread-l nil) ; thread-local
	     (is-static   nil)
         (is-declare  nil)
	     (is-extern   nil)
         (is-alloc    nil)
         (has-defer   nil)
	     (type  (cdr def)))

    (dolist (attr attrs)
      (let ((name (car attr)))
	    (cond ((key-eq name '|register|)     (setq is-register t))
	          ((key-eq name '|volatile|)     (setq is-volatile t))
	          ((key-eq name '|thread-local|) (setq is-thread-l t))
	          ((key-eq name '|static|)       (setq is-static   t))
	          ((key-eq name '|decl|)         (setq is-declare  t))
	          ((key-eq name '|extern|)       (setq is-extern   t))
              ((key-eq name '|defer|)
               (let ((quoted (cadr attr)))
                 (if (null quoted)
                     (setq has-defer (cddr attr))
                     (if (and (key-eq '|true| quoted) (null (cddr attr)))
                         (setq has-defer t)
                         (error (format nil "wrong defer definition ~A, #t means pure free" attr))))))
	          (t (error (format nil "unknown variable attribute ~A" attr))))))
    
    (let ((tmp-variable-spec *variable-spec*)
          (var-spec (make-specifier nil '|@VAR| nil nil nil nil nil nil ()))) ; name and unique name further be replaced
      (setf *variable-spec* var-spec)
      (multiple-value-bind (const typeof modifier const-ptr variable array value)
		  (specify-type-value< type)
        (setf (name var-spec) (specify-decl-name< variable))
        (if *module-path* (setf (unique var-spec) (free-name *module-path* (name var-spec))))
        (setf (const var-spec) const)
        (setf (typeof var-spec) typeof)
        (setf (modifier var-spec) modifier)
        (setf (const-ptr var-spec) const-ptr)
        (setf (array-def var-spec) array)
        (when (and (listp value) (key-eq (first value) '|alloc|))
          (setq is-alloc t)
		  (when (or (= (length value) 1) (> (length value) 3))
		    (error (format nil "wrong alloc form ~A" value)))
		  (if (= (length value) 2)
		      (setq value (list '|cast| (remove nil (list const typeof modifier const-ptr))
					            (list '|malloc| (nth 1 value))))
		      (setq value (list '|cast| (remove nil (list const typeof modifier const-ptr))
				                (list '|calloc| (nth 1 value) (nth 2 value))))))
        (setf (default var-spec) (if (null value)
                                     nil
                                     (let ((app (specify-expr value)))
                                       (if (symbolp app)
                                           (specify-call-expr (list app))
                                           app))))

	    (let ((attributes '()))
	      (when is-extern   (push (cons '|extern|       t) attributes))
		  (when is-static   (push (cons '|static|       t) attributes))
		  (when is-declare  (push (cons '|decl|         t) attributes))
		  (when is-register (push (cons '|register|     t) attributes))
		  (when is-volatile (push (cons '|volatile|     t) attributes))
		  (when is-thread-l (push (cons '|thread-local| t) attributes))
		  (when (or (eq has-defer t) (and is-alloc (null has-defer)))
            (push (cons '|alloc| t) attributes)
            (when (or (null has-defer) (eq has-defer t)) ; auto deferment
              (push (cons '|defer| 
                          (specify-expr
                              `'(|lambda|
                                 (,(remove nil
                                   `(,const ,typeof
                                     ,(cond
                                        ((key-eq '|*|  modifier) '|**|)
                                        ((key-eq '|**| modifier) '|***|)
                                        (t (error (format nil "not suitable for auto deferral"))))
                                     ,const-ptr ,variable ,array)))
                                 (|free| (|cast| (|void| *) (|cof| ,variable))))))
                    attributes)))
		  (when (and has-defer (not (eq has-defer t)))
            (let ((ptr-name (intern (format nil "~A_ptr" variable))))
              (push (cons '|defer|
                          (specify-expr
                              `'(|lambda|
                                 (,(remove nil
                                   `(,const ,typeof
                                     ,(cond
                                        ((null  modifier) '|*|)
                                        ((key-eq '|*|  modifier) '|**|)
                                        ((key-eq '|**| modifier) '|***|)
                                        (t (error (format nil "not suitable for deferment"))))
                                     ,const-ptr ,ptr-name ,array)))
                                 ,@has-defer)))
                    attributes)))
          (setf (attrs var-spec) attributes)
          (setf *variable-spec* tmp-variable-spec)
          var-spec)))))

(defun specify-let (def &optional as-expr)
  (when (or (< (length def) 2) (not (listp (nth 1 def)))) (error (format nil "wrong let form ~A" def)))
  (let ((let-var (make-specifier (gensym "cicili#Let") (if as-expr '|@LETN| '|@LET|) nil nil nil nil nil nil '())))
    (let ((is-static   nil)
          (is-register nil)
          (is-volatile nil)
	      (is-thread-l nil)
          (is-alloc    nil)
          (has-defer   nil))
      (dolist (type-desc (nth 1 def))
        (unless (and (not (null type-desc)) (listp type-desc))
          (error (format nil "wrong variable definition form ~A" type-desc)))
	    (cond ((and (key-eq (car type-desc) '|register|)     (= (length (cdr type-desc)) 0)) (setq is-register t))
              ((and (key-eq (car type-desc) '|volatile|)     (= (length (cdr type-desc)) 0)) (setq is-volatile t))
              ((and (key-eq (car type-desc) '|thread-local|) (= (length (cdr type-desc)) 0)) (setq is-thread-l t))
	          ((and (key-eq (car type-desc) '|static|)       (= (length (cdr type-desc)) 0)) (setq is-static   t))
	          ((key-eq (car type-desc) '|defer|)
               (let ((quoted (cadr type-desc)))
                 (if (null quoted)
                     (setq has-defer (cddr type-desc))
                     (if (and (key-eq '|true| quoted) (null (cddr type-desc)))
                         (setq has-defer t)
                         (error (format nil "wrong defer definition ~A, #t means pure free" type-desc))))))
              (t (multiple-value-bind (const typeof modifier const-ptr variable array value)
		             (specify-type-value< type-desc)
                   (when (key-eq typeof '|var|) (error (format nil "var keyword as a type ~A" type-desc)))

		           (let ((attributes '())
                         (has-atsign (and (symbolp typeof) (equal (char (symbol-name typeof) 0) #\@))))
                     (when has-atsign (setq typeof (intern (str:replace-first "@" "" (symbol-name typeof)))))
		             (when (and (listp value) (key-eq (first value) '|alloc|))
                       (setq is-alloc t)
		               (when (or (= (length value) 1) (> (length value) 3))
		                 (error (format nil "wrong alloc form ~A" value)))
		               (if (= (length value) 2)
		                   (setq value (list '|cast| (remove nil (list const typeof modifier const-ptr))
					                         (list '|malloc| (nth 1 value))))
		                   (setq value (list '|cast| (remove nil (list const typeof modifier const-ptr))
				                             (list '|calloc| (nth 1 value) (nth 2 value))))))
		             (when is-static   (push (cons '|static|       t) attributes))
		             (when is-register (push (cons '|register|     t) attributes))
		             (when is-volatile (push (cons '|volatile|     t) attributes))
		             (when is-thread-l (push (cons '|thread-local| t) attributes))
		             (when (or has-atsign (eq has-defer t) (and is-alloc (null has-defer)))
                       (push (cons '|alloc| t) attributes)
                       (when (or has-atsign (null has-defer) (eq has-defer t)) ; auto deferment
                         (push (cons '|defer| 
                                     (specify-expr
                                         `'(|lambda|
                                            (,(remove nil
                                              `(,const ,typeof
                                                  ,(cond
                                                     ((key-eq '|*|  modifier) '|**|)
                                                     ((key-eq '|**| modifier) '|***|)
                                                     (t (error (format nil "not suitable for auto deferral"))))
                                                  ,const-ptr ,variable ,array)))
                                            ,(if has-atsign
                                                 `(|->| (|cof| ,variable) |free|)
                                                 `(|free| (|cast| (|void| *) (|cof| ,variable)))))))
                               attributes)))
		             (when (and has-defer (not (eq has-defer t)))
                       (let ((ptr-name (intern (format nil "~A_ptr" variable))))
                         (push (cons '|defer|
                                     (specify-expr
                                         `'(|lambda|
                                            (,(remove nil
                                              `(,const ,typeof
                                                ,(cond
                                                   ((null  modifier) '|*|)
                                                   ((key-eq '|*|  modifier) '|**|)
                                                   ((key-eq '|**| modifier) '|***|)
                                                   (t (error (format nil "not suitable for deferment"))))
                                                ,const-ptr ,ptr-name ,array)))
                                            ,(remove nil `(|var| ,const ,typeof ,modifier ,const-ptr
                                                             ,variable ,array . #'(|cof| ,ptr-name)))
                                            ,@has-defer)))
                               attributes)))

                     (add-param
                         (make-specifier (specify-decl-name< variable) '|@VAR| const typeof modifier const-ptr array
                                         (if (null value)
                                             nil
                                             (let ((app (specify-expr value)))
                                               (if (symbolp app)
                                                   (specify-call-expr (list app))
                                                   app)))
                                             attributes)
                       let-var))
                   (setq is-static   nil)
                   (setq is-register nil)
                   (setq is-volatile nil)
                   (setq is-thread-l nil)
                   (setq is-alloc    nil)
                   (setq has-defer   nil))))))
    (setf (body let-var) (specify-body (nthcdr 2 def)))
    let-var))

(defun specify-block (def)
  (let ((block-var (make-specifier (gensym "cicili#Block") '|@BLOCK| nil nil nil nil nil nil '())))
    (setf (body block-var) (specify-body (cdr def)))
    block-var))

(defun specify-progn (def)
  (let ((progn-var (make-specifier (gensym "cicili#Progn") '|@PROGN| nil nil nil nil nil nil '())))
    (setf (body progn-var) (specify-body (cdr def)))
    progn-var))

(defun specify-set-expr (def)
  (when (= (rem (length (cdr def)) 2) 1) (error (format nil "wrong set form ~A" def)))
  (let* ((len (length (cdr def)))
         (items (loop for i from 0 to (1- len)
                      for (x y) on (cdr def)
                      when (and (= (mod i 2) 0) (not (null y)))
                      collect (list (specify-expr x) (specify-expr y)))))
    (make-specifier nil '|@SET| nil nil nil nil nil items '())))

(defun specify-return-expr (def)
  (when (> (length def) 2) (error (format nil "wrong return form ~A" def)))
  (let ((output (expand-macros (nth 1 def))))
    (if (and *function-spec* (or (listp (typeof *function-spec*)) (and (listp output) (key-eq (car output) '|QUOTE|))))
        (make-specifier nil '|@RETURN| nil nil nil nil nil
                        (specify-cast-expr (list '|cast|
                                                 (remove nil (list
                                                              (const *function-spec*)
                                                              (typeof *function-spec*)
                                                              (modifier *function-spec*)
                                                              (const-ptr *function-spec*)
                                                              (array-def *function-spec*)))
                                                 output)) '())
        (let* ((out-tmp (if (null output) nil (specify-expr output)))
               (out (if (symbolp out-tmp)
                        (specify-call-expr (list out-tmp))
                        out-tmp)))
          (when (and (listp output)
                  (key-eq (car output) '|closure|)
                  *function-spec* (key-eq (typeof *function-spec*) '|auto|))
            (setf (typeof *function-spec*) (list '|struct| (name (car (body out))))))
          (make-specifier nil '|@RETURN| nil nil nil nil nil out '())))))

(defun specify-if (def)
  (when (or (< (length def) 3) (> (length def) 4)) (error (format nil "wrong if form ~A" def)))
  (let* ((condition (specify-if-condition (nth 1 def)))
         (if-var (make-specifier condition '|@IF| nil nil nil nil nil nil '())))
    (setf (default if-var) (specify-body (list (nth 2 def))))
    (when (> (length def) 3)
      (setf (body if-var) (specify-body (list (nth 3 def)))))
    if-var))

(defun specify-switch (def)
  (when (< (length def) 2) (error (format nil "wrong switch form ~A" def)))
  (let* ((expre (specify-expr (nth 1 def)))
         (switch-var (make-specifier expre '|@SWITCH| nil nil nil nil nil nil '()))
         (cases '()))
    (dolist (ch-form (nthcdr 2 def))
      (cond ((key-eq (car ch-form) '|case|)
             (setq expre (specify-expr (cadr ch-form)))
             (let ((case-var (make-specifier expre '|@CASE| nil nil nil nil nil nil '())))
               (setf (body case-var) (specify-body (nthcdr 2 ch-form)))
               (push case-var cases)))
	        ((key-eq (car ch-form) '|default|)
             (let ((case-var (make-specifier expre '|@DEFAULT| nil nil nil nil nil nil '())))
               (setf (body case-var) (specify-body (nthcdr 1 ch-form)))
               (push case-var cases)))
	        (t (error (format nil "only case or default form ~A" ch-form)))))
    (setf (default switch-var) (reverse cases))
    switch-var))

(defun specify-while (def)
  (when (< (length def) 2) (error (format nil "wrong while form ~A" def)))
  (let* ((condition (specify-expr (nth 1 def)))
         (while-var (make-specifier condition '|@WHILE| nil nil nil nil nil nil '())))
    (setf (body while-var) (specify-body (nthcdr 2 def)))
    while-var))

(defun specify-do (def)
  (when (< (length def) 2) (error (format nil "wrong while form ~A" def)))
  (let* ((condition (specify-expr (car (last def))))
         (do-var (make-specifier condition '|@DO| nil nil nil nil nil nil '())))
    (setf (body do-var) (specify-body (cdr (without-last def))))
    do-var))

(defun specify-for (def)
  (when (or (< (length def) 3) (not (listp (nth 1 def)))) (error (format nil "wrong for form ~A" def)))
  (let* ((is-register nil)
         (condition (specify-expr (nth 2 def)))
         (for-var (make-specifier condition '|@FOR| nil nil nil nil nil (specify-body (nth 3 def)) '())))
    (dolist (type-desc (nth 1 def))
      (unless (and (not (null type-desc)) (listp type-desc))
        (error (format nil "wrong variable definition form ~A" type-desc)))
      (cond ((and (key-eq (car type-desc) '|register|) (= (length (cdr type-desc)) 0)) (setq is-register t))
	        (t (multiple-value-bind (const typeof modifier const-ptr variable array value)
		           (specify-type-value< type-desc)
		         (let ((attributes '()))
		           (when is-register (push (cons '|register| t) attributes))
                   (add-param
                       (if (null variable)
                           (make-specifier (specify-decl-name< typeof) '|@VAR| const variable modifier const-ptr array
                                           (if (null value) nil (specify-expr value)) attributes)
                           (make-specifier (specify-decl-name< variable) '|@VAR| const typeof modifier const-ptr array
                                           (if (null value) nil (specify-expr value)) attributes))
                     for-var))))))
    (setf (body for-var) (specify-body (nthcdr 4 def)))
    for-var))

(defun specify-if-condition (cond)
    (if (atom cond)
        (specify-expr cond)
        (if (atom (car cond))
            (specify-expr cond)
            (loop for c in cond
                  collect (if (key-eq (car cond) '|var|)
                              (specify-expr (cdr c) '())
                              (specify-expr c))))))

(defun specify-cond (def)
  (when (< (length def) 2) (error (format nil "wrong cond form ~A" def)))
  (let ((cond-var (make-specifier nil '|@COND| nil nil nil nil nil nil '()))
        (nodes (loop for node in (cdr def)
                     collect (list (specify-if-condition (car node)) (specify-body (cdr node))))))
    (setf (body cond-var) nodes)
    cond-var))

(defun specify-macrolet (def)
  (when (< (length def) 2) (error (format nil "wrong macrolet form ~A" def)))
  (dolist (macro (nth 1 def))
    (let* ((mdef (push 'DEFMACRO macro))
           (symb (eval mdef)))
      (add-macro (symbol-name symb) symb)))
  (let ((body (specify-body (nthcdr 2 def))))
    (dolist (macro (nth 1 def))
      (unintern (car macro)))
    body))

(defun specify-function-name< (name)
  (if (listp name) ; method or shared
      (let ((recv (car name))
            (mthd (cdr name)))

        (if (and (symbolp recv) (key-eq recv '<>))
            (specify-decl-name< (if (listp mthd) (apply '<> mthd) mthd))
            (progn
              (when (listp recv)
                (if (key-eq (car recv) '<>)
                    (setq recv (apply '<> (cdr recv)))
                    (error (format nil "generic names are produced by '<>', ~A" name))))
              (when (and (listp mthd) (key-eq (car mthd) '<>))
                (setq mthd (apply '<> (cdr mthd))))
              (cons (specify-decl-name< recv) (specify-decl-name< mthd)))))
      (specify-decl-name< name)))

(defun specify-function (def attrs)
  (let* ((name (specify-function-name< (nth 1 def)))
         (is-static  (if (key-eq name '|main|) t nil))
	     (is-declare  nil)
	     (is-inline   nil)
	     (is-extern   nil)
	     (is-volatile nil)
	     (do-resolve  nil)
	     (is-method (if (key-eq (car def) '|method|) t nil))
         (is-shared (and (listp name) (not is-method)))
	     (params (nth 2 def))
	     (r-out (nth 3 def))
	     (has-out (and (consp r-out) (key-eq (car r-out) '|out|)))
	     (returns (if is-shared
                      (if (str:starts-with-p "new" (string-downcase (symbol-name (cdr name))))
                          (if has-out
                              (error (format nil "constructor has out: ~A" def))
                              (list '|out| (car name) '|*|))
                          (if has-out r-out '(|out| |void|)))
                      (if has-out r-out
		                  (if (key-eq name '|main|) '(|out| |int|) '(|out| |void|)))))
	     (body (if has-out (nthcdr 4 def) (nthcdr 3 def)))
         (function-specifier nil))
    
    (dolist (attr attrs)
      (let ((name (car attr)))
	    (cond ((key-eq name '|static|)   (setq is-static   t))
	          ((key-eq name '|decl|)     (setq is-declare  t))
	          ((key-eq name '|inline|)   (setq is-inline   t))
	          ((key-eq name '|extern|)   (setq is-extern   t))
	          ((key-eq name '|volatile|) (setq is-volatile t))
	          ((key-eq name '|resolve|)  (setq do-resolve  (cadr attr)))
	          (t (error (format nil "unknown function attribute ~A" attr))))))
    (when (and is-declare is-inline) (error (format nil "inline functions should be defined ~A" def)))
    (when (< (length def) 3) (error (format nil "wrong function definition ~A" def)))
    (when (and is-declare body)
      (error (format nil "function declaration with body, may be 'out' missed '~A' ~A" name (first body))))
    (let ((attributes    '())
          (tmp-specifier nil)
          (tmp-outp      nil))
	  (when is-extern   (push (cons '|extern|   t) attributes))
	  (when is-volatile (push (cons '|volatile| t) attributes))
	  (when is-inline   (push (cons '|inline|   t) attributes))
	  (when is-static   (push (cons '|static|   t) attributes))
	  (when is-declare  (push (cons '|decl|     t) attributes))
	  (when do-resolve  (push (cons '|resolve|  do-resolve) attributes))
      ;; guard *function-spec* for inline structs and lambdas
      (setq function-specifier (make-specifier name (if is-method '|@METHOD| '|@FUNC|)
                                               nil nil nil nil nil nil attributes)) ;; for specify out
      (setq tmp-specifier *function-spec*)
      (setq tmp-outp      *function-outp*)
      (setf *function-spec* function-specifier)
      (setf *function-outp* t)

      (multiple-value-bind (const type modifier const-ptr variable array)
	      (specify-type< (cdr returns))
        (setf *function-outp* tmp-outp)
        (setf (const function-specifier) const)
        (setf (typeof function-specifier) type)
        (setf (modifier function-specifier) modifier)
        (setf (const-ptr function-specifier) const-ptr)
        (setf (array-def function-specifier) array))
      
      (setf (body function-specifier) (specify-body body))
	  (when is-method
        (add-param
            (make-specifier (specify-decl-name< '|this|) '|@PARAM| nil
                            (if *module-path*
                                (free-name *module-path* (car name))
                                (car name))
                            '|*| nil nil nil '())
        function-specifier))
      (loop for param in params
            for i from 0 to (length params)
            do (let ((is-anonymous nil))
                 (unless (listp param) (error (format nil "parameter should be a list ~A for ~A" param def)))

	             (multiple-value-bind (const type modifier const-ptr variable array)
	                 (specify-type< param)
	               (cond ((or (null variable) (key-eq '_ variable))
                          (setq variable (gensym (format nil "_ciciliParam_~D" i))))
                         ((key-eq '$$$ variable)
                          (setq variable '|...|)))
                   ;; (setq is-anonymous t))
                   ;; functoin pointer params become volatile too
                   (when (and is-volatile (key-eq type '|func|))
                     (setf (attrs (car array)) (push (cons '|volatile| t) (attrs (car array))))
                     (loop for func-prm being the hash-value of (params (car array))
                       do (setf (attrs func-prm) (push (cons '|volatile| t) (attrs func-prm)))))
                   
                   (add-param
                       (make-specifier
                           (specify-decl-name< variable)
                         '@|PARAM| const type modifier const-ptr array nil
                         (if is-volatile (list (cons '|volatile| t)) nil) is-anonymous)
                     function-specifier))))
      (setf *function-spec* tmp-specifier)) ; end of guard, revert *function-spec*
    function-specifier))

(defun specify-preprocessor (def attrs)
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (when (> (length def) 3) (error (format nil "wrong preprocessor definition ~A" def)))
  (let ((preproc-specifier
            (make-specifier (gensym "cicili#PreProc")
              '|@PREPROC| (specify-symbol-expr (car def)) nil nil nil nil nil nil)))
    (setf (char (symbol-name (name (const preproc-specifier))) 0) #\#)
    (unless (null (cadr  def)) (setf (typeof  preproc-specifier) (specify-expr (cadr  def))))
    (unless (null (caddr def)) (setf (default preproc-specifier) (specify-expr (caddr def))))
    preproc-specifier))

(defun specify-include (def attrs)
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (when (< (length def) 2) (error (format nil "wrong include definition ~A" def)))
  (let ((heads (cdr def))
        (include-var (make-specifier (gensym "cicili#Include") '|@INCLUDE| nil nil nil nil nil nil nil)))
    (dolist (head heads)
      (unless (or (symbolp head) (stringp head)) (error "wrong inclusion")))
    (setf (params include-var) heads)
    include-var))

(defun specify-typedef (def attrs)
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (when (< (length def) 3) (error (format nil "syntax error ~A" def)))
  (let ((tmp-typedef-spec *typedef-spec*)
        (typedef-spec (make-specifier nil '|@TYPEDEF| nil nil nil nil nil nil nil)))
    (setf *typedef-spec* typedef-spec)
    (multiple-value-bind (const type modifier const-ptr variable array)
        (specify-type< (nthcdr 1 def))
	  (when (null variable) (error (format nil "syntax error ~A" def)))
      (setf (name typedef-spec) (specify-decl-name< (EXPAND-MACROS variable)))
      (if *module-path* (setf (unique typedef-spec) (free-name *module-path* (name typedef-spec))))
      (setf (const typedef-spec) const)
      (setf (typeof typedef-spec) type)
      (setf (modifier typedef-spec) modifier)
      (setf (const-ptr typedef-spec) const-ptr)
      (setf (array-def typedef-spec) array)
      (setf *typedef-spec* tmp-typedef-spec)
      typedef-spec)))

(defun specify-enum (def attrs &key ((:nested is-nested) nil))
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (let* ((is-anonymous (or (= (length def) 1) (not (symbolp (nth 1 def)))))
	     (name (specify-decl-name< (if is-anonymous (gensym "ciciliEnum") (nth 1 def))))
	     (constants (if is-anonymous (nthcdr 1 def) (nthcdr 2 def)))
	     (enum-specifier (make-specifier name '|@ENUM| nil nil nil nil nil nil nil)))
    (setf (anonymous enum-specifier) is-anonymous)
    (loop for const in constants
	      with l = (length constants)
	      for i from 0 to l
	      do (progn
	           (unless (and (consp const) (symbolp (car const))) (error (format nil "syntax error ~A" const)))
	           (let ((key (car const))
		             (value (cdr const)))
		         (unless (or (null value) (numberp value) (symbolp value)) (error (format nil "syntax error ~A" const)))
		         (add-inner (make-specifier (specify-expr key) '|@VAR| nil nil nil nil nil
                                       (if (null value) nil (specify-expr value)) nil) enum-specifier))))
    enum-specifier))

(defun specify-struct (def attrs &key ((:nested is-nested) nil) ((:inline is-inline) nil))
  (when (and is-nested (> (length attrs) 0)) (error (format nil "wrong attributes ~A" attrs)))
  (let* ((is-static  nil)
	     (is-declare nil)
         (is-anonymous (or (= (length def) 1)
                         (not (or (and (listp (nth 1 def)) (key-eq (car (nth 1 def)) '<>))
                                (symbolp (nth 1 def))))))
	     (name (specify-decl-name< (if is-anonymous
                                       (gensym "ciciliStruct")
                                       (if (and (listp (nth 1 def)) (key-eq (car (nth 1 def)) '<>))
                                           (apply '<> (cdr (nth 1 def)))
                                           (nth 1 def)))))
	     (clauses (if is-anonymous (nthcdr 1 def) (nthcdr 2 def)))
	     (struct-specifier (make-specifier name '|@STRUCT| nil nil nil nil nil nil nil)))
    (when (and is-anonymous (not is-nested)) (error (format nil "only nested structs could be anonymous")))
    ;; (when (and (not is-anonymous) is-nested) (error (format nil "nested structs should be anonymous")))
    (setf (anonymous struct-specifier) is-anonymous)

    (dolist (attr attrs)
      (let ((name (car attr)))
	    (cond ((key-eq name '|static|)  (setq is-static  t))
	          ((key-eq name '|decl|)    (setq is-declare t))
	          (t (error (format nil "unknown struct attribute ~A" attr))))))

    (let ((struct-attrs '())
          (attributes '())
	      (declares '()))

      (when is-static  (push (cons '|static| t) struct-attrs))
	  (when is-declare (push (cons '|decl| t) struct-attrs))
      (setf (attrs struct-specifier) struct-attrs)
      
      (dolist (clause clauses)
	    (if (consp clause)
	        (let ((construct (car clause)))
	          (cond (is-inline ; inline structs dont have any other inners types but type definitions
                        (multiple-value-bind (const type modifier const-ptr variable array default)
	                        (specify-type-value< clause)
                          (let ((param-spec
                                    (make-specifier
                                        (specify-decl-name< variable)
                                      '@|PARAM| const type modifier const-ptr array default attributes is-anonymous)))
                            (setq attributes '())
	                        (add-inner param-spec struct-specifier))))
                    
                    ((find (char (symbol-name construct) 0) "@#")
		             (add-inner (specify-preprocessor clause attributes) struct-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|static|)   (push clause attributes))
		            ((key-eq construct '|decl|)     (push clause attributes))
		            ((key-eq construct '|inline|)   (push clause attributes))
		            ((key-eq construct '|register|) (push clause attributes))
		            ((key-eq construct '|extern|)   (push clause attributes))
		            ((key-eq construct '|volatile|) (push clause attributes))
                    ;; members
		            ((key-eq construct '|member|)
                     (multiple-value-bind (const type modifier const-ptr variable array default)
	                     (specify-type-value< (cdr clause))
                       (let ((param-spec
                                 (make-specifier
                                     (specify-decl-name< variable)
                                   '@|PARAM| const type modifier const-ptr array default nil))
                             (attrs '()))

                         (let ((is-volatile nil))
                           (dolist (attr attributes)
                             (when (key-eq (car attr) '|volatile|) (setq is-volatile t))
                             (push (cons (car attr) t) attrs))
                           (setf (attrs param-spec) attrs)
                           
                           ;; functoin pointer params become volatile too
                           (when (and is-volatile (key-eq type '|func|))
                             (setf (attrs (car array)) (push (cons '|volatile| t) (attrs (car array))))
                             (loop for func-prm being the hash-value of (params (car array))
                                   do (setf (attrs func-prm) (push (cons '|volatile| t) (attrs func-prm))))))
                         
                         (setq attributes '())
	                     (add-inner param-spec struct-specifier))))
                    
		            ((key-eq construct '|enum|)
		             (add-inner (specify-enum     clause attributes :nested t) struct-specifier) (setq attributes '()))
		            ((key-eq construct '|struct|)
		             (add-inner (specify-struct   clause attributes :nested t) struct-specifier) (setq attributes '()))
		            ((key-eq construct '|union|)
		             (add-inner (specify-union    clause attributes :nested t) struct-specifier) (setq attributes '()))
		            ((key-eq construct '|declare|)
		             (when (= (length clause) 1)
		               (error (format nil "declare needs a name of variable for anonymous struct")))
		             (push clause declares))
		            (t (error (format nil "unknown clause ~A in struct ~A" construct name)))))
	        (error (format nil "syntax error ~A" clause))))
      (when (and (not is-anonymous) (> (length declares) 0))
	    (error (format nil "declare must be inside anonymous struct ~A" name)))
      (dolist (decl (reverse declares))
        (let ((var-spec (specify-variable (push '|var| decl) '())))
          (setf (construct var-spec) '|@DECLARE|)
	      (add-param var-spec struct-specifier)
          (setf (typeof var-spec) '||))))
    struct-specifier))

(defun specify-union (def attrs &key ((:nested is-nested) nil))
  (when (and is-nested (> (length attrs) 0)) (error (format nil "wrong attributes ~A" attrs)))
  (let* ((is-anonymous (or (= (length def) 1) (not (symbolp (nth 1 def)))))
	     (name (specify-decl-name< (if is-anonymous (gensym "ciciliUnion") (nth 1 def))))
	     (clauses (if is-anonymous (nthcdr 1 def) (nthcdr 2 def)))
	     (union-specifier (make-specifier name '|@UNION| nil nil nil nil nil nil nil)))
    (when (and is-anonymous (not is-nested)) (error (format nil "only nested unions could be anonymous")))
    (setf (anonymous union-specifier) is-anonymous)
    (let ((attributes '())
	      (declares '()))
      (dolist (clause clauses)
	    (if (consp clause)
	        (let ((construct (car clause)))
	          (cond ((find (char (symbol-name construct) 0) "@#")
		             (add-inner (specify-preprocessor clause attributes) union-specifier) (setq attributes '()))
		            ((key-eq construct '|member|)
		             (add-inner (specify-variable clause attributes) union-specifier) (setq attributes '()))
		            ((key-eq construct '|struct|)
		             (add-inner (specify-struct   clause attributes :nested t) union-specifier) (setq attributes '()))
		            ((key-eq construct '|union|)
		             (add-inner (specify-union    clause attributes :nested t) union-specifier) (setq attributes '()))
		            ((key-eq construct '|declare|)
		             (when (= (length clause) 1)
		               (error (format nil "declare needs a name of variable for anonymous union")))
		             (push clause declares))
		            (t (error (format nil "unknown clause ~A in union ~A" construct name)))))
	        (error (format nil "syntax error ~A" clause))))
      (when (and (not is-anonymous) (> (length declares) 0))
	    (error (format nil "declare must be inside anonymous union ~A" name)))
      (dolist (decl (reverse declares))
        (let ((var-spec (specify-variable (push '|var| decl) '())))
          (setf (construct var-spec) '|@DECLARE|)
	      (add-param var-spec union-specifier)
          (setf (typeof var-spec) '||))))
      union-specifier))

(defun specify-guard (def attrs)
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (let* ((name (specify-decl-name< (expand-macros (nth 1 def))))
	     (clauses (nthcdr 2 def))
	     (guard-specifier (make-specifier name '|@GUARD| nil nil nil nil nil nil nil)))
    (let ((attributes '()))
      (dolist (clause clauses)
	    (if (consp clause)
	        (let ((construct (car clause)))
	          (cond ((find (char (symbol-name construct) 0) "@#")
		             (add-inner (specify-preprocessor clause attributes) guard-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|static|)       (push clause attributes))
		            ((key-eq construct '|decl|)         (push clause attributes))
		            ((key-eq construct '|inline|)       (push clause attributes))
		            ((key-eq construct '|register|)     (push clause attributes))
		            ((key-eq construct '|extern|)       (push clause attributes))
		            ((key-eq construct '|volatile|)     (push clause attributes))
		            ((key-eq construct '|thread-local|) (push clause attributes))
		            ((key-eq construct '|resolve|)      (push clause attributes))
		            ((key-eq construct '|defer|)        (push clause attributes))
		            ((key-eq construct '|include|)
		             (add-inner (specify-include  clause attributes) guard-specifier) (setq attributes '()))
		            ((key-eq construct '|var|)
		             (add-inner (specify-variable clause attributes) guard-specifier) (setq attributes '()))
		            ((key-eq construct '|func|)
		             (add-inner (specify-function clause attributes) guard-specifier) (setq attributes '()))
		            ((key-eq construct '|method|)
		             (add-inner (specify-function clause attributes) guard-specifier) (setq attributes '()))
		            ((key-eq construct '|enum|)
		             (add-inner (specify-enum     clause attributes) guard-specifier) (setq attributes '()))
		            ((key-eq construct '|struct|)
		             (add-inner (specify-struct   clause attributes) guard-specifier) (setq attributes '()))
		            ((key-eq construct '|union|)
		             (add-inner (specify-union    clause attributes) guard-specifier) (setq attributes '()))
		            ((key-eq construct '|typedef|)
		             (add-inner (specify-typedef  clause attributes) guard-specifier) (setq attributes '()))
		            ((key-eq construct '|guard|)
		             (add-inner (specify-guard    clause attributes) guard-specifier) (setq attributes '()))
		            ((key-eq construct '|module|)
		             (add-inner (specify-module   clause attributes) guard-specifier) (setq attributes '()))
		            (t (add-inner (specify-expr   clause) guard-specifier))))
	        (error (format nil "syntax error ~A" clause)))))
    guard-specifier))
