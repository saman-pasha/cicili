(in-package :cicili)

;;;; specifier
(defclass sp ()
  ((name          :initarg :name      :accessor name)
   (construct     :initarg :construct :accessor construct)
   (const         :initarg :const     :accessor const)
   (typeof        :initarg :typeof    :accessor typeof)
   (modifier      :initarg :modifier  :accessor modifier)
   (const-ptr     :initarg :const-ptr :accessor const-ptr)
   (array-def     :initarg :array-def :accessor array-def)
   (default       :initarg :default   :accessor default)
   (keys          :initform nil :accessor keys) ; resolver keys
   (module        :initform nil :accessor module)
   (unique        :initform nil :accessor unique)
   (attrs         :initarg :attrs     :accessor attrs)
   (anonymous     :initarg :anonymous :initform nil :accessor anonymous)
   (body          :initform nil :accessor body)
   (params        :initform nil :accessor params)
   (lambdas       :initform nil :accessor lambdas)
   (inners        :initform nil :accessor inners)))

(defun make-specifier (name construct const typeof modifier const-ptr array-def default attrs &optional (anonymous nil))
  (let ((instance (make-instance 'sp
				                 :name      name
				                 :construct construct
				                 :const     const
				                 :typeof    typeof
				                 :modifier  modifier
				                 :const-ptr const-ptr
				                 :array-def array-def
				                 :default   default
				                 :attrs     attrs
				                 :anonymous anonymous)))
    (setf (keys instance) (make-hash-table :test 'eql))
    
    (cond ((eql construct '|@VAR|)
           (when *module-path*
             (setf (module instance) *module-path*)
             (setf (unique instance) (free-name *module-path* name)))
 	       (setf (inners  instance)     (make-hash-table :test 'eql))) ; contains type inline struct
          ((eql construct '|@LET|)
	       (setf (params  instance)     (make-hash-table :test 'eql)))
          ((eql construct '|@LETN|)
	       (setf (params  instance)     (make-hash-table :test 'eql)))
	      ((eql construct '|@FOR|)
	       (setf (params  instance)     (make-hash-table :test 'eql)))
	      ((eql construct '|@FUNC|)
           (when *module-path*
             (setf (module instance) *module-path*)
             (setf (unique instance)
                   (if (symbolp name)
                       (free-name *module-path* name)
                       (intern (format nil "~A_s_~A" (symbol-name (free-name *module-path* (car name))) (cdr name))))))
	       (setf (params  instance)     (make-hash-table :test 'eql))
 	       (setf (inners  instance)     (make-hash-table :test 'eql))) ; contains lambdas
	      ((eql construct '|@METHOD|)
             (setf (module instance) *module-path*)
             (setf (unique instance)
                   (intern (format nil "~A_m_~A" (symbol-name (free-name *module-path* (car name))) (cdr name))))
	       (setf (params  instance)     (make-hash-table :test 'eql))
 	       (setf (inners  instance)     (make-hash-table :test 'eql))) ; contains lambdas
	      ((eql construct '|@ENUM|)
           (when *module-path*
             (setf (module instance) *module-path*)
             (setf (unique instance) (free-name *module-path* name)))
 	       (setf (inners  instance)     (make-hash-table :test 'eql)))
	      ((eql construct '|@STRUCT|)
           (when *module-path*
             (setf (module instance) *module-path*)
             (setf (unique instance) (free-name *module-path* name)))
	       (setf (params  instance)     (make-hash-table :test 'eql))
	       (setf (inners  instance)     (make-hash-table :test 'eql)))
	      ((eql construct '|@UNION|)
           (when *module-path*
             (setf (module instance) *module-path*)
             (setf (unique instance) (free-name *module-path* name)))
	       (setf (params  instance)     (make-hash-table :test 'eql))
	       (setf (inners  instance)     (make-hash-table :test 'eql)))
	      ((eql construct '|@GUARD|)
	       (setf (inners  instance)     (make-hash-table :test 'eql)))
	      ((eql construct '|@GHOST|)
	       (setf (inners  instance)     (make-hash-table :test 'eql)))
	      ((eql construct '|@MODULE|)
           (when *module-path*
             (setf (module instance) *module-path*)
             (setf (unique instance) (free-name *module-path* name)))
           (setf (inners  instance)     (make-hash-table :test 'eql)))
	      ((eql construct '|@TARGET|)
	       (setf (inners  instance)     (make-hash-table :test 'eql)))
	      (t t))
    instance))

(defun add-param (spec parent)
  (if (gethash (name spec) (params parent))
      (error (format nil "paramter exists: ~A for ~A" spec parent))
      (setf (gethash (name spec) (params parent)) spec)))

(defun add-inner (spec parent)
  (let ((name (name spec)))
    (when (find-if #'(lambda (attr) (if (key-eq '|decl| (car attr)) t nil)) (attrs spec))
      (setq name (intern (format nil "~A-~A" '|decl| (name spec)))))
    (if (gethash name (inners parent))
        (error (format nil "inner exists: ~A in ~A" spec parent))
        (setf (gethash name (inners parent)) spec))))
  
;;;; specifier
(defmethod print-object ((spec sp) stream)
  (print-unreadable-object (spec stream :type t :identity t)
    (princ
     (format nil
       "~A ~:[~A ~;~*~]~:[~A ~;~*~]~:[~A ~;~*~]~:[~A ~;~*~]~:[~A ~;~*~]~:[~{~A~} ~;~*~]~:[= ~A ~;~*~]~:[{~{~A~^ ~}}~;~*~]~:[~;A~]"
	   (construct spec)
       (null (name spec))      (name spec)
       (null (const spec))     (const spec)
       (null (typeof spec))    (typeof spec)
       (null (modifier spec))  (modifier spec)
       (null (const-ptr spec)) (const-ptr spec)
	   (null (array-def spec)) (array-def spec)
       (null (default spec))   (default spec)
	   (null (attrs spec))     (attrs spec)
       (anonymous spec))
     stream)))

(defun copy-specifiers (table)
  (if (null table)
      (make-hash-table)
      (let ((new-table (make-hash-table
                        :test (hash-table-test table)
                        :size (hash-table-size table)
		                :rehash-size (hash-table-rehash-size table)
		                :rehash-threshold (hash-table-rehash-threshold table))))
        (maphash #'(lambda(key value)
                     (setf (gethash key new-table) value))
                 table)
        new-table)))

(defun print-specifier (spec &optional (lvl 0))
  (format t
          "~A~A ~A ~:[~A ~;~*~]~:[~A ~;~*~]~:[~A ~;~*~]~:[~A ~;~*~]~:[~{~A~} ~;~*~]~:[= ~A ~;~*~]~:[{~{~A~^ ~}}~;~*~]~:[~;A~]~%"
	      (indent lvl) (construct spec) (name spec) (null (const spec)) (const spec) (null (typeof spec)) (typeof spec)
	      (null (modifier spec)) (modifier spec) (null (const-ptr spec)) (const-ptr spec)
	      (null (array-def spec)) (array-def spec) (null (default spec)) (default spec)
	      (null (attrs spec)) (attrs spec) (anonymous spec))
  (let ((params  (params  spec))
	    (inners  (inners  spec)))
    (when params  (print-specifiers params  (+ 1 lvl)))
    (when inners  (print-specifiers inners  (+ 1 lvl)))))

(defun print-specifiers (table &optional (lvl 0))
  (maphash #'(lambda (k v) (print-specifier v lvl)) table))

(defun specify-decl-name< (name)
  (if (is-decl-name name) name
      (error (format nil "wrong name ~S" name))))

(defun specify-name< (name)
  (if (is-name name) (specify-typeof< name)
      (error (format nil "wrong name ~S" name))))

(defun specify-receiver< (name)
  (let ((parts (str:split "->" (string name))))
    (unless (= (length parts) 2) (error (format nil "wrong receiver ~S" name)))
    (let ((receiver (intern (nth 0 parts)))
          (method (intern (nth 1 parts))))
      (if (and (is-name receiver) (is-symbol method))
          (cons (specify-name< receiver) (specify-name< method))
          (error (format nil "wrong receiver ~S" name))))))

(defun specify-type-name< (name)
  (cond ((key-eq name '|uchar|)  "unsigned char")
	    ((key-eq name '|ushort|) "unsigned short")
	    ((key-eq name '|uint|)   "unsigned int")
	    ((key-eq name '|ulong|)  "unsigned long")
	    ((key-eq name '|llong|)  "long long")
	    ((key-eq name '|ullong|) "unsigned long long")
	    ((key-eq name '|i8|)     "int8_t")
	    ((key-eq name '|u8|)     "uint8_t")
	    ((key-eq name '|i16|)    "int16_t")
	    ((key-eq name '|u16|)    "uint16_t")
	    ((key-eq name '|i32|)    "int32_t")
	    ((key-eq name '|u32|)    "uint32_t")
	    ((key-eq name '|i64|)    "int64_t")
	    ((key-eq name '|u64|)    "uint64_t")
	    ((key-eq name '|i128|)   "__int128")
	    ((key-eq name '|u128|)   "unsigned __int128")
	    ((key-eq name '|real|)   "long double")
	    ((key-eq name '|auto|)   "__auto_type")
	    (t (specify-name< name))))

(defun specify-name-with-module< (symbol)
  (let* ((str-name (symbol-name symbol))
         (count$ (str:count-substring "/" str-name)))
    (cond ((str:starts-with-p "/" str-name)
           (intern (str:substring 1 t str-name)))
          ((> count$ 0) (free-name (map 'list #'intern (str:split "/" str-name)) nil))
          (t symbol))))

(defun specify-typeof< (type)
  (if (atom type)
      (if (typep type 'sp)
          (progn
            (setf (name type) (specify-name-with-module< (name type)))
            type)
          (specify-name-with-module< type))
      (let ((ty (car type)))
        (cond ((or (key-eq '|struct| ty) (key-eq '|union| ty))
               (list ty (specify-name-with-module< (cadr type))))
              ((key-eq '|typeof| ty) (specify-typeof-expr type))
              ((and (null *function-spec*) *variable-spec* (key-eq 'QUOTE ty)) ; inline struct global var
               (let* ((sname (gensym "__ciciliS_"))
                      (struct-spec (specify-struct (append (list '|struct| sname) (cadr type)) '() :inline t)))
                 (add-inner struct-spec *variable-spec*)
                 (list '|struct| (if *module-path* (free-name *module-path* sname) sname))))
              ((and *function-outp* *function-spec* (key-eq 'QUOTE ty)) ; inline struct as function out type
               (let* ((fname (name *function-spec*))
                      (cname (if (listp fname) (make-method-name (car fname) (cdr fname)) (symbol-name fname)))
                      (sname (if (str:starts-with-p "__ciciliS_" cname)
                                 (intern (format nil "~A_" cname))
                                 (intern (format nil "__ciciliS_~A_" cname))))
                      (struct-spec (specify-struct (append (list '|struct| sname) (cadr type)) '() :inline t)))
                 (add-inner struct-spec *function-spec*)
                 (list '|struct| (if *module-path* (free-name *module-path* sname) sname))))
              ((and *function-spec* (key-eq 'QUOTE ty)) ; inline struct inside function body
               (let* ((sname (gensym "__ciciliS_"))
                      (struct-spec (specify-struct (append (list '|struct| sname) (cadr type)) '() :inline t)))
                 (add-inner struct-spec *function-spec*)
                 (list '|struct| (if *module-path* (free-name *module-path* sname) sname))))
              (t (error (format nil "syntax error ~A" type)))))))

(defun specify-type< (desc &optional noVar)
  (let ((len (if (listp desc) (length desc) 1))
	    (const nil)
	    (type nil)
	    (modifier nil)
	    (const-ptr nil)
	    (variable nil)
	    (array nil)
	    (status 0))
    (cond ((symbolp desc) (setq type desc))
	      ((= len 1) (setq type (nth 0 desc)))
	      ((= len 2) (if (key-eq (nth 0 desc) '|const|)
			             (progn
			               (setq const (nth 0 desc))
			               (setq type (nth 1 desc)))
		                 (if (find (nth 1 desc) *modifiers* :test #'key-eq)
			                 (progn
			                   (setq type (nth 0 desc))
			                   (setq modifier (nth 1 desc)))
			                 (if (is-array (nth 1 desc))
			                     (progn
			                       (setq type (nth 0 desc))
			                       (setq array (nth 1 desc)))
			                     (progn
			                       (setq type (nth 0 desc))
			                       (setq variable (nth 1 desc)))))))
	      ((= len 3) (if (key-eq (nth 0 desc) '|func|)
                         (progn
                           (setq type (nth 0 desc))
		                   (setq modifier '|*|)
                           (setq variable (nth 1 desc))
				           (setq array (specify-function desc (list '(|decl|)))))
                         (if (key-eq (nth 0 desc) '|const|)
			                 (if (find (nth 2 desc) *modifiers* :test #'key-eq) 
			                     (progn
			                       (setq const (nth 0 desc))
			                       (setq type (nth 1 desc))
			                       (setq modifier (nth 2 desc)))
			                     (if (is-array (nth 2 desc))
			                         (progn
				                       (setq const (nth 0 desc))
				                       (setq type (nth 1 desc))
				                       (setq array (nth 2 desc)))
			                         (progn
			                           (setq const (nth 0 desc))
			                           (setq type (nth 1 desc))
			                           (setq variable (nth 2 desc)))))
		                     (if (find (nth 1 desc) *modifiers* :test #'key-eq)
			                     (if (key-eq (nth 2 desc) '|const|)
			                         (progn
				                       (setq type (nth 0 desc))
				                       (setq modifier (nth 1 desc))
				                       (setq const-ptr (nth 2 desc)))
			                         (if (is-array (nth 2 desc))
				                         (progn
				                           (setq type (nth 0 desc))
				                           (setq modifier (nth 1 desc))
				                           (setq array (nth 2 desc)))
			                             (progn
				                           (setq type (nth 0 desc))
				                           (setq modifier (nth 1 desc))
				                           (setq variable (nth 2 desc)))))
			                     (progn
			                       (setq type (nth 0 desc))
			                       (setq variable (nth 1 desc))
			                       (setq array (nth 2 desc)))))))
	      ((= len 4) (if (key-eq (nth 0 desc) '|func|)
                         (progn
                           (setq type (nth 0 desc))
		                   (setq modifier '|*|)
                           (setq variable (nth 1 desc))
				           (setq array (specify-function desc (list '(|decl|)))))
                         (if (key-eq (nth 0 desc) '|const|)
                             (if (key-eq (nth 1 desc) '|func|)
                                 (progn
                                   (setq const (nth 0 desc))
                                   (setq type (nth 1 desc))
		                           (setq modifier '|*|)
                                   (setq variable (nth 2 desc))
				                   (setq array (specify-function (cdr desc) (list '(|decl|)))))
                                 (if (find (nth 2 desc) *modifiers* :test #'key-eq)
			                         (if (key-eq (nth 3 desc) '|const|)
				                         (progn
				                           (setq const (nth 0 desc))
				                           (setq type (nth 1 desc))
				                           (setq modifier (nth 2 desc))
				                           (setq const-ptr (nth 3 desc)))
			                             (if (is-array (nth 3 desc))
				                             (progn
				                               (setq const (nth 0 desc))
				                               (setq type (nth 1 desc))
				                               (setq modifier (nth 2 desc))
				                               (setq array (nth 3 desc)))
				                             (progn
				                               (setq const (nth 0 desc))
				                               (setq type (nth 1 desc))
				                               (setq modifier (nth 2 desc))
				                               (setq variable (nth 3 desc)))))
		                             (if (key-eq (nth 2 desc) '|const|)
			                             (if (is-array (nth 3 desc))
			                                 (progn
				                               (setq type (nth 0 desc))
				                               (setq modifier (nth 1 desc))
				                               (setq const-ptr (nth 2 desc))
				                               (setq array (nth 3 desc)))
			                                 (progn
			                                   (setq type (nth 0 desc))
			                                   (setq modifier (nth 1 desc))
			                                   (setq const-ptr (nth 2 desc))
			                                   (setq variable (nth 3 desc))))
                                         (if (is-array (nth 3 desc))
			                                 (progn
                                               (setq const (nth 0 desc))
				                               (setq type (nth 1 desc))
				                               (setq variable (nth 2 desc))
                                               (setq array (nth 3 desc)))
			                                 (progn
			                                   (setq type (nth 0 desc))
			                                   (setq modifier (nth 1 desc))
			                                   (setq variable (nth 2 desc))
			                                   (setq array (nth 3 desc)))))))
                             (if (find (nth 1 desc) *modifiers* :test #'key-eq)
			                     (if (key-eq (nth 2 desc) '|const|)
			                         (if (is-array (nth 3 desc))
				                         (progn
				                           (setq type (nth 0 desc))
				                           (setq modifier (nth 1 desc))
				                           (setq const-ptr (nth 2 desc))
                                           (setq array (nth 3 desc)))
				                         (progn
				                           (setq type (nth 0 desc))
				                           (setq modifier (nth 1 desc))
				                           (setq const-ptr (nth 2 desc))
                                           (setq variable (nth 3 desc))))
                                     (progn
                                       (setq type (nth 0 desc))
				                       (setq modifier (nth 1 desc))
				                       (setq variable (nth 2 desc))
                                       (setq array (nth 3 desc))))
                                 (progn
                                   (setq type (nth 0 desc))
				                   (setq variable (nth 1 desc))
                                   (setq array (list (nth 2 desc) (nth 3 desc))))))))
	       ((= len 5) (if (key-eq (nth 0 desc) '|const|)
                          (if (key-eq (nth 1 desc) '|func|)
                              (progn
                                (setq const (nth 0 desc))
                                (setq type (nth 1 desc))
		                        (setq modifier '|*|)
		                        (setq variable (nth 2 desc))
				                (setq array (specify-function (cdr desc) (List '(|decl|)))))
                              (if (is-array (nth 4 desc))
                                  (if (is-array (nth 3 desc))
			                          (progn
                                        (setq const (nth 0 desc))
                                        (setq type (nth 1 desc))
				                        (setq variable (nth 2 desc))
                                        (setq array (list (nth 3 desc) (nth 4 desc))))
                                      (progn
                                        (setq const (nth 0 desc))
			                            (setq type (nth 1 desc))
			                            (setq modifier (nth 2 desc))
			                            (setq variable (nth 3 desc))
                                        (setq array (nth 4 desc))))
                                  (progn
			                        (setq const (nth 0 desc))
			                        (setq type (nth 1 desc))
			                        (setq modifier (nth 2 desc))
			                        (setq const-ptr (nth 3 desc))
			                        (setq variable (nth 4 desc)))))
			              (progn
			                (setq type (nth 0 desc))
			                (setq modifier (nth 1 desc))
			                (setq const-ptr (nth 2 desc))
                            (setq variable (nth 3 desc))
			                (setq array (nth 4 desc)))))
	      ((= len 6) (progn
		               (setq const (nth 0 desc))
		               (setq type (nth 1 desc))
		               (setq modifier (nth 2 desc))
		               (setq const-ptr (nth 3 desc))
		               (setq variable (nth 4 desc))
		               (setq array (nth 5 desc))))
	      (t (setq status -1)))
    (setq type (specify-typeof< type))
    (unless (or (null const)     (key-eq const '|const|)) (setq status -2))
    (unless (or (null modifier)
              (key-eq modifier '&)
              (key-eq modifier '*)
              (key-eq modifier '**)
              (key-eq modifier '***))
      (setq status -3))
    (unless (or (null const-ptr) (key-eq const-ptr '|const|)) (setq status -4))
    (unless (or (null const-ptr)
              (key-eq modifier '*)
              (key-eq modifier '**)
              (key-eq modifier '***))
      (setq status -5))
    (when noVar (unless (null variable) (setq status -6)))
    (if (key-eq type '|func|)
        (progn
          (when (null array) (setq status -7))
          (setq array (list array)))
        (if (and (= (length array) 2) (is-array (car array)) (is-array (cadr array)))
            (setq array (list (specify-expr (nth 1 (car array))) (specify-expr (nth 1 (cadr array)))))
            (when (= (length array) 3)
              (setq array (list (specify-expr (nth 1 array)))))))
    (when   (< status 0) (error (format nil "wrong type descriptor ~D ~A" status desc)))
    (values const type modifier const-ptr variable array)))

(defun specify-type-value< (desc)
  (let ((l (cdr (last desc)))
	    (wl (without-last desc)))
    (cond ((and (listp l) (> (length desc) 2) (key-eq (nth (- (length desc) 2) desc) 'FUNCTION)) ; #' function initializer
	       (setq l (nth (- (length desc) 1) desc))
	       (multiple-value-bind (const type modifier const-ptr variable array)
		       (specify-type< (without-last wl))
		     (values const type modifier const-ptr variable array l)))
          ((and (listp l) (> (length desc) 2) (key-eq (nth (- (length desc) 2) desc) 'QUOTE)) ; ' list and lambda initializer
           (let* ((def (nthcdr (- (length desc) 2) desc))
                  (quoted (cadr def)))
             (if (key-eq (car quoted) '|lambda|)
                 (progn ; lambda initializer
                   (multiple-value-bind (const type modifier const-ptr variable array)
		               (specify-type< (without-last wl))
		             (values const type modifier const-ptr variable array def)))
                 (progn ; list initializer
	               (setq l (nthcdr (- (length desc) 2) desc))
		           (multiple-value-bind (const type modifier const-ptr variable array)
		               (specify-type< (without-last wl))
		             (values const type modifier const-ptr variable array l))))))
	      ((listp l) (specify-type< desc))
	      (t (multiple-value-bind (const type modifier const-ptr variable array)
	             (specify-type< wl)
	           (values const type modifier const-ptr variable array l))))))

(defun specify-nil-expr ()
  (make-specifier '|NULL| '|@ATOM| nil '|@SYMBOL| nil nil nil nil '()))

(defun specify-number-expr (def)
  (make-specifier def '|@ATOM| nil '|@NUMBER| nil nil nil nil '()))

(defun specify-character-expr (def)
  (if (eql def #\Null)
      (make-specifier "\\0" '|@ATOM| nil '|@CHAR| nil nil nil nil '())
      (make-specifier def   '|@ATOM| nil '|@CHAR| nil nil nil nil '())))

(defun specify-string-expr (def)
  (make-specifier (format nil "\"~A\"" def) '|@ATOM| nil '|@STRING| nil nil nil nil '()))

(defun specify-symbol-expr (def)
  (make-specifier (specify-name< def) '|@ATOM| nil '|@SYMBOL| nil nil nil nil '()))

(defun specify-atom-expr (def)
  (cond ((null       def) (make-specifier nil '|@NIL| nil nil nil nil nil nil '())) ; ignore nil values like ([ NIL ])
        ((key-eq     def '|nil|) (specify-nil-expr))
        ((key-eq     def '|NIL|) (specify-nil-expr))
        ((numberp    def)        (specify-number-expr def))
	    ((characterp def)        (specify-character-expr def))
	    ((stringp    def)        (specify-string-expr def))
        ((and (symbolp def) (is-symbol def))
	     (if (eql (char (symbol-name def) 0) #\0) ; 0x12af..
	         (specify-symbol-expr def)
             (specify-symbol-expr def))) ; name
        ((symbolp def) (specify-symbol-expr def)) ; operators
	    (t (error (format nil "syntax error \"~A\"" def)))))

(defun specify-code-expr (def)
  (make-specifier nil '|@CODE| nil nil nil nil nil def '()))

(defun specify-list-expr (def)
  (make-specifier nil '|@LIST| nil nil nil nil nil (loop for item in def collect (specify-expr item)) '()))

(defun specify-unary-expr (def)
  (unless (= (length def) 2) (error (format nil "wrong unary form ~A" def)))
  (let* ((oprt (car def))
	     (name (symbol-name oprt))
	     (is-postfix nil))
    (cond ((key-eq oprt '|not|) (setq oprt '|!|))
	      ((key-eq oprt '|cof|) (setq oprt '|*|))
          ((key-eq oprt '|aof|) (setq oprt '|&|))
          ((key-eq oprt '|stringize|) (setq oprt '|#|))  ; maybe inside a macro
          ((key-eq oprt '|1+|)  (setq oprt '|++|) (setq is-postfix t))
	      ((key-eq oprt '|1-|)  (setq oprt '|--|) (setq is-postfix t)))
    (if is-postfix
        (make-specifier oprt '|@UNARY| nil nil t   nil nil (specify-expr (cadr def)) '()) ; 1+ 1-
        (make-specifier oprt '|@UNARY| nil nil nil nil nil (specify-expr (cadr def)) '()))))

(defun specify-operator-expr (def)
  (when (< (length def) 3) (error (format nil "wrong operator form ~A" def)))
  (let ((opr (car def))
	    (oprnds '()))
    (cond ((key-eq opr '|and|)    (setq opr '|&&|))
	      ((key-eq opr '|or|)     (setq opr '|\|\||))
	      ((key-eq opr '|bitand|) (setq opr '|&|))
	      ((key-eq opr '|bitor|)  (setq opr '|\||))
	      ((key-eq opr '|xor|)    (setq opr '|^|)))
    (dolist (oprnd (cdr def))
      (push opr oprnds)
      (push oprnd oprnds))
    (make-specifier opr '|@OPR| nil nil nil nil nil
                    (loop for frm in (cdr (reverse oprnds))
                          for i from 0 to (length oprnds)
                          collect (if (= (mod i 2) 0)
                                      (specify-expr frm)
                                      (make-specifier frm '|@SYMBOL| nil '|@SYMBOL| nil nil nil nil '()))) '())))

(defun specify-assignment-expr (def)
  (unless (= (length def) 3) (error (format nil "wrong assignment form ~A" def)))
  (let ((opr (car def))
	    (oprnds '()))
    (dolist (oprnd (cdr def))
      (push opr oprnds)
      (push oprnd oprnds))
    (make-specifier opr '|@ASSIGN| nil nil nil nil nil
                    (loop for frm in (cdr (reverse oprnds))
                          collect (specify-expr frm))'())))

(defun specify-nth-expr (def)
  (unless (= (length def) 3) (error (format nil "wrong nth form ~A" def)))
  (make-specifier (specify-expr (nth 1 def)) '|@NTH| nil nil nil nil nil (specify-expr (nth 2 def)) '()))

(defun specify-?-expr (def)
  (unless (= (length def) 4) (error (format nil "wrong ? form ~A" def)))
  (make-specifier (specify-expr (nth 1 def)) '|@?| nil nil nil nil nil
                  (list (specify-expr (nth 2 def)) (specify-expr (nth 3 def))) '()))

(defun specify-cast-expr (def)
  (unless (= (length def) 3) (error (format nil "wrong cast form ~A" def)))
  (let ((ty (nth 1 def)))
    (multiple-value-bind (const type modifier const-ptr variable array)
	    (specify-type< (if (and (listp ty) (key-eq '|typeof| (car ty))) (list ty) ty))
      (make-specifier
          (specify-decl-name< variable)
        '|@CAST| const type modifier const-ptr array (specify-expr (nth 2 def)) '()))))

(defun specify-$-expr (def)
  (let ((len (length def))
        (member (car (last def))))
    (unless (>= len 3) (error (format nil "wrong access member $ form ~A" def)))
    (unless (is-symbol member) (error (format nil "wrong access member name ~A" def)))
    (make-specifier (if (> len 3)
                        (specify-expr (without-last def))
                        (specify-expr (car (last (without-last def)))))
      '|@$| nil nil nil nil nil
      (specify-symbol-expr member) '())))

(defun specify-->-expr (def)
  (when (< (length def) 3) (error (format nil "wrong access method -> form ~A" def)))
  ;; (unless (is-symbol (nth 2 def)) (error (format nil "wrong access method name ~A" def)))
  (let ((method-var (make-specifier (specify-expr (nth 1 def)) '|@->| nil nil nil nil nil
                                    ;; (specify-symbol-expr (nth 2 def)) '())))
                                    (specify-expr (nth 2 def)) '())))
    (setf (body method-var) (specify-list-expr (nthcdr 3 def)))
    method-var))

(defun specify-sizeof-expr (def)
  (when (< (length def) 2) (error (format nil "sizeof syntax error ~A" def)))
  (if (listp (second def))
      (make-specifier nil '|@SIZEOF| nil nil nil nil nil (specify-expr (second def)) '())
      (multiple-value-bind (const type modifier const-ptr variable array)
          (specify-type< (cdr def))
        (make-specifier (specify-decl-name< variable) '|@SIZEOF| const type modifier const-ptr array nil '()))))

(defun specify-typeof-expr (def)
  (when (< (length def) 2) (error (format nil "typeof syntax error ~A" def)))
  (make-specifier nil '|@TYPEOF| nil nil nil nil nil (specify-expr (cadr def)) '()))

(defun specify-call-expr (def)
  (when (key-eq (car def) '|aof|) (error (format nil "address of aka 'aof' takes only one argument ~A" def)))
  (make-specifier (specify-expr (nth 0 def)) '|@CALL| nil nil nil nil nil
                  (if (> (length def) 1) (loop for item in (nthcdr 1 def) collect (specify-expr item)) nil) '()))

(defun specify-expr (def)
  (cond ((key-eq  def '|nil|) (specify-nil-expr))
        ((key-eq  def '|NIL|) (specify-nil-expr))
        ((atom    def)        (specify-atom-expr def))
        (t (let* ((func (car def))
                  (attributes '())
                  (macro (if (symbolp func) (gethash (symbol-name func) *macros*) nil)))
	         (cond ((key-eq func '|code|)   (specify-code-expr (cadr def)))
                   ((key-eq func 'FUNCTION) (specify-expr      (cadr def)))
		           ((key-eq func 'QUOTE)
                    (let ((quoted (cadr def)))
                      (if (key-eq (car quoted) '|lambda|) ; lambda
                          (let* ((lname (gensym "__ciciliL_"))
                                 (func-spec (specify-function (append (list '|lambda| lname) (cdr quoted)) '())))
                            (add-inner func-spec (if *function-spec* *function-spec* *variable-spec*))
                            (specify-symbol-expr (if *module-path* (free-name *module-path* lname) lname)))
                          (specify-list-expr quoted))))   ; list
		           ((and (> (length def) 2) (key-eq func '\|) (key-eq (cadr def) '\|))
		            (specify-operator-expr (push '\|\| (cddr def))))
		           ((and (> (length def) 2) (key-eq func '\|)) (specify-operator-expr def))
		           ((and (= (length def) 2) (find func *unaries*   :test #'key-eq)) (specify-unary-expr def))
		           ((and (> (length def) 2) (find func *operators* :test #'key-eq)) (specify-operator-expr def))
		           ((key-eq func '|nth|)    (specify-nth-expr    def))
		           ((key-eq func '|?|)      (specify-?-expr      def)) 
		           ((key-eq func '|cast|)   (specify-cast-expr   def))
                   ((key-eq func '|$|)      (specify-$-expr      def)) ; member access operator
                   ((key-eq func '|->|)     (specify-->-expr     def)) ; method access operator
                   ((key-eq func '|sizeof|) (specify-sizeof-expr def))
                   ((key-eq func '|typeof|) (specify-typeof-expr def))
                   (*macroexpand*       ; inside macros, only during macro expantion
                       (cond ((key-eq func '|let|)    (specify-let         def)) 
                             ((key-eq func '|letn|)   (specify-let         def t))
                             ((key-eq func '|block|)  (specify-block       def))
                             ((key-eq func '|progn|)  (specify-progn       def))
		                     ((key-eq func '|static|)   (push def attributes))     
		                     ((key-eq func '|decl|)     (push def attributes))
		                     ((key-eq func '|inline|)   (push def attributes))
		                     ((key-eq func '|register|) (push def attributes))
		                     ((key-eq func '|auto|)     (push def attributes))
		                     ((key-eq func '|extern|)   (push def attributes))
		                     ((key-eq func '|resolve|)  (push def attributes))
		                     ((key-eq func '|include|)
                              (let ((out-spec (specify-include     def attributes))) (setq attributes '()) out-spec))
                             ((key-eq func '|var|)
                              (let ((out-spec (specify-variable    def attributes))) (setq attributes '()) out-spec))
		                     ((key-eq func '|func|)
                              (let ((out-spec (specify-function    def attributes))) (setq attributes '()) out-spec))
		                     ((key-eq func '|method|)
                              (let ((out-spec (specify-function    def attributes))) (setq attributes '()) out-spec))
		                     ((key-eq func '|enum|)
                              (let ((out-spec (specify-enum        def attributes))) (setq attributes '()) out-spec))
		                     ((key-eq func '|struct|)
                              (let ((out-spec (specify-struct      def attributes))) (setq attributes '()) out-spec))
		                     ((key-eq func '|union|)
                              (let ((out-spec (specify-union       def attributes))) (setq attributes '()) out-spec))
		                     ((key-eq func '|typedef|)
                              (let ((out-spec (specify-typedef     def attributes))) (setq attributes '()) out-spec))
		                     ((key-eq func '|guard|)
                              (let ((out-spec (specify-guard       def attributes))) (setq attributes '()) out-spec))
		                     ((key-eq func '|ghost|)
                              (let ((out-spec (specify-guard       def attributes t))) (setq attributes '()) out-spec))
		                     ((key-eq func '|module|)
                              (let ((out-spec (specify-module      def attributes))) (setq attributes '()) out-spec))
		                     ((key-eq func '|cicili|)
                              (let ((out-spec (compile-ast         (cdr def)))) (setq attributes '()) out-spec))
		                     ((or macro (and (symbolp func) (macro-function func)))
                              (let ((tmp-expantion *macroexpand*)
                                    (id (gensym "me:"))
                                    (result nil))
                                (when *debug-macroexpand* (format t "~A ~A~%" id def))
                                (setf *macroexpand* t)
                                (if (key-eq func '|generic|)
                                    (let ((symb (eval (macroexpand def))))
                                      (setq result (specify-guard (LIST '|ghost|) () t)))
                                    (let ((expr (if macro (macroexpand `(,macro ,@(cdr def))) (macroexpand def))))
                                      (when *debug-macroexpand* (format t "~A ~A~%" id expr))
                                      (setq result (if (listp expr)
                                                       (specify-body (list expr))
                                                       (specify-expr expr)))))
                                (setf *macroexpand* tmp-expantion)
                                result))
                             (t (specify-call-expr def))))
                   ((or macro (and (symbolp func) (macro-function func)))
                    (let ((tmp-expantion *macroexpand*)
                          (id (gensym "me:"))
                          (result nil))
                      (when *debug-macroexpand* (format t "~A ~A~%" id def))
                      (setf *macroexpand* t)
                      (let ((expr (if macro (macroexpand `(,macro ,@(cdr def))) (macroexpand def))))
                        (when *debug-macroexpand* (format t "~A ~A~%" id expr))
                        (setq result (if (listp expr)
                                         (specify-body (list expr))
                                         (specify-expr expr))))
                      (setf *macroexpand* tmp-expantion)
                      result))
                   (t (specify-call-expr def)))))))


;; var clause only allowed as global vars but inside macros for complex situation
;; use let clause instead
(defun specify-variable (def attrs)
  (let* ((is-auto     nil)
	     (is-register nil)
	     (is-static   nil)
	     (is-extern   nil)
         (is-alloc    nil)
         (has-defer   nil)
	     (type  (cdr def)))
    (dolist (attr attrs)
      (let ((name (car attr)))
	    (cond ;; ((key-eq name '|auto|)     (setq is-auto t))
	          ((key-eq name '|register|) (setq is-register t))
	          ((key-eq name '|static|)   (setq is-static t))
	          ((key-eq name '|extern|)   (setq is-extern t))
              ((key-eq (car attr)'|defer|)
               (let ((quoted (cadr attr)))
                 (if (null quoted)
                     (setq has-defer (cddr attr))
                     (if (and (key-eq '|true| quoted) (null (cddr attr)))
                         (setq has-defer t)
                         (error (format nil "wrong defer definition ~A, #t means pure free" attr))))))
	          (t (error (format nil "unknown variable attribute ~A" attr))))))
    (let ((tmp-variable-spec *variable-spec*)
          (var-spec (make-specifier nil '|@VAR| nil nil nil nil nil nil ()))) ; name and unique name further be replaced
      (setf *variable-spec* var-spec)
      (multiple-value-bind (const typeof modifier const-ptr variable array value)
		  (specify-type-value< type)
        (setf (name var-spec) (specify-decl-name< variable))
        (if *module-path* (setf (unique var-spec) (free-name *module-path* (name var-spec))))
        (setf (const var-spec) const)
        (setf (typeof var-spec) typeof)
        (setf (modifier var-spec) modifier)
        (setf (const-ptr var-spec) const-ptr)
        (setf (array-def var-spec) array)
        (when (and (listp value) (key-eq (first value) '|alloc|))
          (setq is-alloc t)
		  (when (or (= (length value) 1) (> (length value) 3))
		    (error (format nil "wrong alloc form ~A" value)))
		  (if (= (length value) 2)
		      (setq value (list '|cast| (remove nil (list const typeof modifier const-ptr))
					            (list '|malloc| (nth 1 value))))
		      (setq value (list '|cast| (remove nil (list const typeof modifier const-ptr))
				                (list '|calloc| (nth 1 value) (nth 2 value))))))
        (setf (default var-spec) (if (null value) nil (specify-expr value)))
	    (let ((attributes '()))
	      (when is-extern   (push (cons '|extern|   t) attributes))
		  (when is-static   (push (cons '|static|   t) attributes))
		  (when is-register (push (cons '|register| t) attributes))
		  (when is-auto     (push (cons '|auto|     t) attributes))
		  (when (or (eq has-defer t) (and is-alloc (null has-defer)))
            (push (cons '|alloc| t) attributes)
            (when (or (null has-defer) (eq has-defer t)) ; auto deferment
              (push (cons '|defer| 
                          (specify-expr
                              `'(|lambda|
                                 (,(remove nil
                                   `(,const ,typeof
                                     ,(cond
                                        ((key-eq '|*|  modifier) '|**|)
                                        ((key-eq '|**| modifier) '|***|)
                                        (t (error (format nil "not suitable for auto deferral"))))
                                     ,const-ptr ,variable ,array)))
                                 (|free| (|cast| (|void| *) (|cof| ,variable)))))) attributes)))
		  (when (and has-defer (not (eq has-defer t)))
            (let ((ptr-name (intern (format nil "~A_ptr" variable))))
              (push (cons '|defer|
                          (specify-expr
                              `'(|lambda|
                                 (,(remove nil
                                   `(,const ,typeof
                                     ,(cond
                                        ((null  modifier) '|*|)
                                        ((key-eq '|*|  modifier) '|**|)
                                        ((key-eq '|**| modifier) '|***|)
                                        (t (error (format nil "not suitable for deferment"))))
                                     ,const-ptr ,ptr-name ,array)))
                                 ,(remove nil `(var ,const ,typeof ,modifier ,const-ptr
                                                  ,variable ,array . #'(cof ,ptr-name)))
                                 ,@has-defer))) attributes)))
          (setf (attrs var-spec) attributes)
          (setf *variable-spec* tmp-variable-spec)
          var-spec)))))

(defun specify-body (def)
  (let ((body-specifier (make-specifier (gensym "cicili#Body") '@|BODY| nil nil nil nil nil nil nil)))
    (dolist (form def)
      (push
          (cond ((key-eq  form '|nil|) (specify-nil-expr))
                ((key-eq  form '|NIL|) (specify-nil-expr))
                ((atom    form)        (specify-atom-expr   form))
	            (t (let ((func (car form)))
	                 (cond ;; ((and (symbolp func) (macro-function func))
                           ;;  (let ((expr (macroexpand def)))
                           ;;    (display "AAAAAA" expr #\Newline)))
                           ((and (= (length form) 2) (find func *unaries*     :test #'key-eq))
                            (specify-unary-expr form))
		                   ((and (= (length form) 3) (find func *assignments* :test #'key-eq))
                            (specify-assignment-expr form))
		                   ((key-eq func '|let|)      (specify-let           form)) 
		                   ((key-eq func '|letn|)     (specify-let           form t)) 
		                   ((key-eq func '|block|)    (specify-block         form)) 
		                   ((key-eq func '|progn|)    (specify-progn         form)) 
		                   ((key-eq func '|set|)      (specify-set-expr      form))
		                   ((key-eq func '|return|)   (specify-return-expr   form))
		                   ((key-eq func '|break|)    (specify-symbol-expr   form))
		                   ((key-eq func '|continue|) (specify-symbol-expr   form))
		                   ((key-eq func '|if|)       (specify-if            form)) 
		                   ((key-eq func '|switch|)   (specify-switch        form)) 
		                   ((key-eq func '|while|)    (specify-while         form)) 
		                   ((key-eq func '|do|)       (specify-do            form)) 
		                   ((key-eq func '|for|)      (specify-for           form)) 
		                   ((key-eq func '|cond|)     (specify-cond          form)) 
		                   (t (specify-expr form))))))
          (body body-specifier)))
    (setf (body body-specifier) (reverse (body body-specifier)))
    body-specifier))

(defun specify-let (def &optional as-expr)
  (when (or (< (length def) 2) (not (listp (nth 1 def)))) (error (format nil "wrong let form ~A" def)))
  (let ((let-var (make-specifier (gensym "cicili#Let") (if as-expr '|@LETN| '|@LET|) nil nil nil nil nil nil '())))
    (let ((is-static   nil)
          (is-register nil)
	      (is-auto     nil)
          (is-alloc    nil)
          (has-defer   nil))
      (dolist (type-desc (nth 1 def))
        (unless (and (not (null type-desc)) (listp type-desc))
          (error (format nil "wrong variable definition form ~A" type-desc)))
	    (cond ((and (key-eq (car type-desc) '|register|) (= (length (cdr type-desc)) 0)) (setq is-register t))
              ;; ((and (key-eq (car type-desc) '|auto|)     (= (length (cdr type-desc)) 0)) (setq is-auto t))
	          ((and (key-eq (car type-desc) '|static|)   (= (length (cdr type-desc)) 0)) (setq is-static t))
	          ((key-eq (car type-desc) '|defer|)
               (let ((quoted (cadr type-desc)))
                 (if (null quoted)
                     (setq has-defer (cddr type-desc))
                     (if (and (key-eq '|true| quoted) (null (cddr type-desc)))
                         (setq has-defer t)
                         (error (format nil "wrong defer definition ~A, #t means pure free" type-desc))))))
              (t (multiple-value-bind (const typeof modifier const-ptr variable array value)
		             (specify-type-value< type-desc)
		           (let ((attributes '())
                         (has-atsign (and (symbolp typeof) (equal (char (symbol-name typeof) 0) #\@))))
                     (when has-atsign (setq typeof (intern (str:replace-first "@" "" (symbol-name typeof)))))
		             (when (and (listp value) (key-eq (first value) '|alloc|))
                       (setq is-alloc t)
		               (when (or (= (length value) 1) (> (length value) 3))
		                 (error (format nil "wrong alloc form ~A" value)))
		               (if (= (length value) 2)
		                   (setq value (list '|cast| (remove nil (list const typeof modifier const-ptr))
					                         (list '|malloc| (nth 1 value))))
		                   (setq value (list '|cast| (remove nil (list const typeof modifier const-ptr))
				                             (list '|calloc| (nth 1 value) (nth 2 value))))))
		             (when is-static   (push (cons '|static|   t) attributes))
		             (when is-register (push (cons '|register| t) attributes))
		             (when is-auto     (push (cons '|auto|     t) attributes))
		             (when (or has-atsign (eq has-defer t) (and is-alloc (null has-defer)))
                       (push (cons '|alloc| t) attributes)
                       (when (or has-atsign (null has-defer) (eq has-defer t)) ; auto deferment
                         (push (cons '|defer| 
                                     (specify-expr
                                         `'(|lambda|
                                            (,(remove nil
                                              `(,const ,typeof
                                                  ,(cond
                                                     ((key-eq '|*|  modifier) '|**|)
                                                     ((key-eq '|**| modifier) '|***|)
                                                     (t (error (format nil "not suitable for auto deferral"))))
                                                  ,const-ptr ,variable ,array)))
                                            ,(if has-atsign
                                                 `(|->| (|cof| ,variable) |free|)
                                                 `(|free| (|cast| (|void| *) (|cof| ,variable))))))) attributes)))
		             (when (and has-defer (not (eq has-defer t)))
                       (let ((ptr-name (intern (format nil "~A_ptr" variable))))
                         (push (cons '|defer|
                                     (specify-expr
                                         `'(|lambda|
                                            (,(remove nil
                                              `(,const ,typeof
                                                ,(cond
                                                   ((null  modifier) '|*|)
                                                   ((key-eq '|*|  modifier) '|**|)
                                                   ((key-eq '|**| modifier) '|***|)
                                                   (t (error (format nil "not suitable for deferment"))))
                                                ,const-ptr ,ptr-name ,array)))
                                            ,(remove nil `(var ,const ,typeof ,modifier ,const-ptr
                                                             ,variable ,array . #'(cof ,ptr-name)))
                                            ,@has-defer))) attributes)))
                     (add-param
                         (make-specifier (specify-decl-name< variable) '|@VAR| const typeof modifier const-ptr array
                                         (if (null value) nil (specify-expr value)) attributes)
                       let-var))
                   (setq is-static   nil)
                   (setq is-register nil)
	               (setq is-auto     nil)
                   (setq is-alloc    nil)
                   (setq has-defer   nil))))))
    (setf (body let-var) (specify-body (nthcdr 2 def)))
    let-var))

(defun specify-block (def)
  (let ((block-var (make-specifier (gensym "cicili#Block") '|@BLOCK| nil nil nil nil nil nil '())))
    (setf (body block-var) (specify-body (cdr def)))
    block-var))

(defun specify-progn (def)
  (let ((progn-var (make-specifier (gensym "cicili#Progn") '|@PROGN| nil nil nil nil nil nil '())))
    (setf (body progn-var) (specify-body (cdr def)))
    progn-var))

(defun specify-set-expr (def)
  (when (= (rem (length (cdr def)) 2) 1) (error (format nil "wrong set form ~A" def)))
  (let* ((len (length (cdr def)))
         (items (loop for i from 0 to (1- len)
                      for (x y) on (cdr def)
                      when (and (= (mod i 2) 0) (not (null y)))
                      collect (list (specify-expr x) (specify-expr y)))))
    (make-specifier nil '|@SET| nil nil nil nil nil items '())))

(defun specify-return-expr (def)
  (let ((output (nth 1 def)))
    (if (and *function-spec* (or (listp (typeof *function-spec*)) (and (listp output) (key-eq (car output) '|QUOTE|))))
        (make-specifier nil '|@RETURN| nil nil nil nil nil
                        (specify-cast-expr (list '|cast|
                                                 (remove nil (list
                                                              (const *function-spec*)
                                                              (typeof *function-spec*)
                                                              (modifier *function-spec*)
                                                              (const-ptr *function-spec*)
                                                              (array-def *function-spec*)))
                                                 output)) '())
        (make-specifier nil '|@RETURN| nil nil nil nil nil
                        (if (null output)
                            nil
                            (specify-expr output)) '()))))

(defun specify-if (def)
  (when (or (< (length def) 3) (> (length def) 4)) (error (format nil "wrong if form ~A" def)))
  (let* ((condition (specify-expr (nth 1 def)))
         (if-var (make-specifier condition '|@IF| nil nil nil nil nil nil '())))
    (setf (default if-var) (specify-body (list (nth 2 def))))
    (when (> (length def) 3)
      (setf (body if-var) (specify-body (list (nth 3 def)))))
    if-var))

(defun specify-switch (def)
  (when (< (length def) 2) (error (format nil "wrong switch form ~A" def)))
  (let* ((expre (specify-expr (nth 1 def)))
         (switch-var (make-specifier expre '|@SWITCH| nil nil nil nil nil nil '()))
         (cases '()))
    (dolist (ch-form (nthcdr 2 def))
      (cond ((key-eq (car ch-form) '|case|)
             (setq expre (specify-expr (cadr ch-form)))
             (let ((case-var (make-specifier expre '|@CASE| nil nil nil nil nil nil '())))
               (setf (body case-var) (specify-body (nthcdr 2 ch-form)))
               (push case-var cases)))
	        ((key-eq (car ch-form) '|default|)
             (let ((case-var (make-specifier expre '|@DEFAULT| nil nil nil nil nil nil '())))
               (setf (body case-var) (specify-body (nthcdr 1 ch-form)))
               (push case-var cases)))
	        (t (error (format nil "only case or default form ~A" ch-form)))))
    (setf (default switch-var) (reverse cases))
    switch-var))

(defun specify-while (def)
  (when (< (length def) 2) (error (format nil "wrong while form ~A" def)))
  (let* ((condition (specify-expr (nth 1 def)))
         (while-var (make-specifier condition '|@WHILE| nil nil nil nil nil nil '())))
    (setf (body while-var) (specify-body (nthcdr 2 def)))
    while-var))

(defun specify-do (def)
  (when (< (length def) 2) (error (format nil "wrong while form ~A" def)))
  (let* ((condition (specify-expr (car (last def))))
         (do-var (make-specifier condition '|@DO| nil nil nil nil nil nil '())))
    (setf (body do-var) (specify-body (cdr (without-last def))))
    do-var))

(defun specify-for (def)
  (when (or (< (length def) 3) (not (listp (nth 1 def)))) (error (format nil "wrong for form ~A" def)))
  (let* ((is-register nil)
	     (is-auto     nil)
         (condition (specify-expr (nth 2 def)))
         (for-var (make-specifier condition '|@FOR| nil nil nil nil nil (specify-body (nth 3 def)) '())))
    (dolist (type-desc (nth 1 def))
      (unless (and (not (null type-desc)) (listp type-desc))
        (error (format nil "wrong variable definition form ~A" type-desc)))
      (cond ((and (key-eq (car type-desc) '|register|) (= (length (cdr type-desc)) 0)) (setq is-register t))
            ((and (key-eq (car type-desc) '|auto|)     (= (length (cdr type-desc)) 0)) (setq is-auto t))
	        (t (multiple-value-bind (const typeof modifier const-ptr variable array value)
		           (specify-type-value< type-desc)
		         (let ((attributes '()))
		           (when is-register (push (cons '|register| t) attributes))
		           (when is-auto     (push (cons '|auto|     t) attributes))
                   (add-param
                       (if (null variable)
                           (make-specifier (specify-decl-name< typeof) '|@VAR| const variable modifier const-ptr array
                                           (if (null value) nil (specify-expr value)) attributes)
                           (make-specifier (specify-decl-name< variable) '|@VAR| const typeof modifier const-ptr array
                                           (if (null value) nil (specify-expr value)) attributes))
                     for-var))))))
    (setf (body for-var) (specify-body (nthcdr 4 def)))
    for-var))

(defun specify-cond (def)
  (when (< (length def) 2) (error (format nil "wrong cond form ~A" def)))
  (let ((cond-var (make-specifier nil '|@COND| nil nil nil nil nil nil '()))
        (nodes (loop for node in (cdr def)
                     collect (list (specify-expr (car node)) (specify-body (cdr node))))))
    (setf (body cond-var) nodes)
    cond-var))

(defun specify-function-name< (name)
  (if (listp name) ; method or shared
      (let ((recv (car name))
            (mthd (cdr name)))
        (if (and (symbolp recv) (key-eq recv '<>))
            (specify-decl-name< (if (listp mthd) (apply '<> mthd) mthd))
            (progn
              (when (listp recv)
                (if (key-eq (car recv) '<>)
                    (setq recv (apply '<> recv))
                    (error (format nil "generic names are produced by '<>', ~A" name))))
              (when (and (listp mthd) (key-eq (car mthd) '<>))
                (setq mthd (apply '<> (cdr mthd))))
              (cons (specify-decl-name< recv) (specify-decl-name< mthd)))))
      (specify-decl-name< name)))

(defun specify-function (def attrs)
  (let* ((is-static  nil)
	     (is-declare nil)
	     (is-inline  nil)
	     (is-extern  nil)
	     (do-resolve nil)
	     (name (specify-function-name< (nth 1 def)))
         (is-method (if (key-eq (car def) '|method|) t nil))
         (is-shared (and (listp name) (not is-method)))
	     (params (nth 2 def))
	     (r-> (nth 3 def))
	     (has-out (and (consp r->) (key-eq (car r->) '|out|)))
	     (returns (if is-shared
                      (if (str:starts-with-p "new" (string-downcase (symbol-name (cdr name))))
                          (if has-out
                              (error (format nil "constructor has out: ~A" def))
                              (list '|out| (car name) '|*|))
                          (if has-out r-> '(|out| |void|)))
                      (if has-out r->
		                  (if (key-eq name '|main|) '(|out| |int|) '(|out| |void|)))))
	     (body (if has-out (nthcdr 4 def) (nthcdr 3 def)))
         (function-specifier nil))
    (dolist (attr attrs)
      (let ((name (car attr)))
	    (cond ((key-eq name '|static|)  (setq is-static  t))
	          ((key-eq name '|decl|)    (setq is-declare t))
	          ((key-eq name '|inline|)  (setq is-inline  t))
	          ((key-eq name '|extern|)  (setq is-extern  t))
	          ((key-eq name '|resolve|) (setq do-resolve (cadr attr)))
	          (t (error (format nil "unknown function attribute ~A" attr))))))
    (when (and is-declare is-inline) (error (format nil "inline functions should be defined ~A" def)))
    (when (< (length def) 3) (error (format nil "wrong function definition ~A" def)))
    (when (and is-declare body)
      (error (format nil "function declaration with body, may be 'out' missed '~A' ~A" name (first body))))
    (let ((attributes    '())
          (tmp-specifier nil)
          (tmp-outp      nil))
	  (when is-extern  (push (cons '|extern|  t) attributes))
	  (when is-inline  (push (cons '|inline|  t) attributes))
	  (when is-static  (push (cons '|static|  t) attributes))
	  (when is-declare (push (cons '|decl|    t) attributes))
	  (when do-resolve (push (cons '|resolve| do-resolve) attributes))
      ;; guard *function-spec* for inline structs and lambdas
      (setq function-specifier (make-specifier name (if is-method '|@METHOD| '|@FUNC|)
                                               nil nil nil nil nil nil attributes)) ;; for specify out
      (setq tmp-specifier *function-spec*)
      (setq tmp-outp      *function-outp*)
      (setf *function-spec* function-specifier)
      (setf *function-outp* t)
	  (multiple-value-bind (const type modifier const-ptr variable array)
	      (specify-type< (cdr returns) t)
        (setf *function-outp* tmp-outp)
        (setf (const function-specifier) const)
        (setf (typeof function-specifier) type)
        (setf (modifier function-specifier) modifier)
        (setf (const-ptr function-specifier) const-ptr)
        (setf (array-def function-specifier) array))
      (setf (body function-specifier) (specify-body body))
	  (when is-method
        (add-param
            (make-specifier (specify-decl-name< '|this|) '|@PARAM| nil
                            (if *module-path*
                                (free-name *module-path* (car name))
                                (car name)) '|*| nil nil nil '())
        function-specifier))
      (loop for param in params
            for i from 0 to (length params)
            do (let ((is-anonymous nil))
	              (multiple-value-bind (const type modifier const-ptr variable array)
	                  (specify-type< param)
	                (cond ((or (null variable) (key-eq '_ variable))
                           (setq variable (gensym (format nil "_ciciliParam_~D" i))))
                          ((key-eq '$$$ variable)
                           (setq variable '|...|)))
	                  ; (setq is-anonymous t))
                    (add-param
                        (make-specifier
                            (specify-decl-name< variable)
                          '@|PARAM| const type modifier const-ptr array nil nil is-anonymous)
                      function-specifier))))
      (setf *function-spec* tmp-specifier)) ; end of guard, revert *function-spec*
    function-specifier))

(defun specify-preprocessor (def attrs)
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (when (> (length def) 3) (error (format nil "wrong preprocessor definition ~A" def)))
  (let ((preproc-specifier
            (make-specifier (gensym "cicili#PreProc")
              '|@PREPROC| (specify-symbol-expr (car def)) nil nil nil nil nil nil)))
    (setf (char (symbol-name (name (const preproc-specifier))) 0) #\#)
    (unless (null (cadr  def)) (setf (typeof  preproc-specifier) (specify-expr (cadr  def))))
    (unless (null (caddr def)) (setf (default preproc-specifier) (specify-expr (caddr def))))
    preproc-specifier))

(defun specify-include (def attrs)
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (when (< (length def) 2) (error (format nil "wrong include definition ~A" def)))
  (let ((heads (cdr def))
        (include-var (make-specifier (gensym "cicili#Include") '|@INCLUDE| nil nil nil nil nil nil nil)))
    (dolist (head heads)
      (unless (or (symbolp head) (stringp head)) (error "wrong inclusion")))
    (setf (params include-var) heads)
    include-var))

(defun specify-typedef (def attrs)
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (when (< (length def) 3) (error (format nil "syntax error ~A" def)))
  (multiple-value-bind (const type modifier const-ptr variable array)
      (specify-type< (nthcdr 1 def))
	(when (null variable) (error (format nil "syntax error ~A" def)))
    (make-specifier (specify-decl-name< variable) '|@TYPEDEF| const type modifier const-ptr array nil nil)))

(defun specify-enum (def attrs &key ((:nested is-nested) nil))
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (let* ((is-anonymous (or (= (length def) 1) (not (symbolp (nth 1 def)))))
	     (name (specify-decl-name< (if is-anonymous (gensym "ciciliEnum") (nth 1 def))))
	     (constants (if is-anonymous (nthcdr 1 def) (nthcdr 2 def)))
	     (enum-specifier (make-specifier name '|@ENUM| nil nil nil nil nil nil nil)))
    (setf (anonymous enum-specifier) is-anonymous)
    (loop for const in constants
	      with l = (length constants)
	      for i from 0 to l
	      do (progn
	           (unless (and (consp const) (symbolp (car const))) (error (format nil "syntax error ~A" const)))
	           (let ((key (car const))
		             (value (cdr const)))
		         (unless (or (null value) (numberp value) (symbolp value)) (error (format nil "syntax error ~A" const)))
		         (add-inner (make-specifier (specify-expr key) '|@VAR| nil nil nil nil nil
                                       (if (null value) nil (specify-expr value)) nil) enum-specifier))))
    enum-specifier))

(defun specify-struct (def attrs &key ((:nested is-nested) nil) ((:inline is-inline) nil))
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (let* ((is-anonymous (or (= (length def) 1) (not (symbolp (nth 1 def)))))
	     (name (specify-decl-name< (if is-anonymous
                                       (gensym "ciciliStruct")
                                       (if (and (listp (nth 1 def)) (key-eq (car (nth 1 def)) '<>))
                                           (apply '<> (cdr (nth 1 def)))
                                           (nth 1 def)))))
	     (clauses (if is-anonymous (nthcdr 1 def) (nthcdr 2 def)))
	     (struct-specifier (make-specifier name '|@STRUCT| nil nil nil nil nil nil nil)))
    (when (and is-anonymous (not is-nested)) (error (format nil "only nested structs could be anonymous")))
    (when (and (not is-anonymous) is-nested) (error (format nil "nested structs should be anonymous")))
    (setf (anonymous struct-specifier) is-anonymous)
    (let ((attributes '())
	      (declares '()))
      (dolist (clause clauses)
	    (if (consp clause)
	        (let ((construct (car clause)))
	          (cond (is-inline
                      (add-inner (specify-variable (append (list '|member|) clause) attributes) struct-specifier)
		              (setq attributes '()))
                    ((find (char (symbol-name construct) 0) "@#")
		             (add-inner (specify-preprocessor clause attributes) struct-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|static|)   (push clause attributes))
		            ((key-eq construct '|decl|)     (push clause attributes))
		            ((key-eq construct '|inline|)   (push clause attributes))
		            ((key-eq construct '|register|) (push clause attributes))
		            ((key-eq construct '|auto|)     (push clause attributes))
		            ((key-eq construct '|extern|)   (push clause attributes))
		            ((key-eq construct '|member|)
		             (add-inner (specify-variable clause attributes) struct-specifier) (setq attributes '()))
		            ((key-eq construct '|enum|)
		             (add-inner (specify-enum     clause attributes :nested t) struct-specifier) (setq attributes '()))
		            ((key-eq construct '|struct|)
		             (add-inner (specify-struct   clause attributes :nested t) struct-specifier) (setq attributes '()))
		            ((key-eq construct '|union|)
		             (add-inner (specify-union    clause attributes :nested t) struct-specifier) (setq attributes '()))
		            ((key-eq construct '|declare|)
		             (when (= (length clause) 1)
		               (error (format nil "declare needs a name of variable for anonymous struct")))
		             (push clause declares))
		            (t (error (format nil "unknown clause ~A in struct ~A" construct name)))))
	        (error (format nil "syntax error ~A" clause))))
      (when (and (not is-anonymous) (> (length declares) 0))
	    (error (format nil "declare must be inside anonymous struct ~A" name)))
      (dolist (decl (reverse declares))
        (let ((var-spec (specify-variable (push '|var| decl) '())))
          (setf (construct var-spec) '|@DECLARE|)
	      (add-param var-spec struct-specifier)
          (setf (typeof var-spec) '||))))
    struct-specifier))

(defun specify-union (def attrs &key ((:nested is-nested) nil))
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (let* ((is-anonymous (or (= (length def) 1) (not (symbolp (nth 1 def)))))
	     (name (specify-decl-name< (if is-anonymous (gensym "ciciliUnion") (nth 1 def))))
	     (clauses (if is-anonymous (nthcdr 1 def) (nthcdr 2 def)))
	     (union-specifier (make-specifier name '|@UNION| nil nil nil nil nil nil nil)))
    (when (and is-anonymous (not is-nested)) (error (format nil "only nested unions could be anonymous")))
    (setf (anonymous union-specifier) is-anonymous)
    (let ((attributes '())
	      (declares '()))
      (dolist (clause clauses)
	    (if (consp clause)
	        (let ((construct (car clause)))
	          (cond ((find (char (symbol-name construct) 0) "@#")
		             (add-inner (specify-preprocessor clause attributes) union-specifier) (setq attributes '()))
		            ((key-eq construct '|member|)
		             (add-inner (specify-variable clause attributes) union-specifier) (setq attributes '()))
		            ((key-eq construct '|struct|)
		             (add-inner (specify-struct   clause attributes :nested t) union-specifier) (setq attributes '()))
		            ((key-eq construct '|union|)
		             (add-inner (specify-union    clause attributes :nested t) union-specifier) (setq attributes '()))
		            ((key-eq construct '|declare|)
		             (when (= (length clause) 1)
		               (error (format nil "declare needs a name of variable for anonymous union")))
		             (push clause declares))
		            (t (error (format nil "unknown clause ~A in union ~A" construct name)))))
	        (error (format nil "syntax error ~A" clause))))
      (when (and (not is-anonymous) (> (length declares) 0))
	    (error (format nil "declare must be inside anonymous union ~A" name)))
      (dolist (decl (reverse declares))
        (let ((var-spec (specify-variable (push '|var| decl) '())))
          (setf (construct var-spec) '|@DECLARE|)
	      (add-param var-spec union-specifier)
          (setf (typeof var-spec) '||))))
      union-specifier))

(defun specify-guard (def attrs &optional is-ghost)
  (when (> (length attrs) 0) (error (format nil "wrong attributes ~A" attrs)))
  (let* ((name (specify-decl-name< (if is-ghost (gensym "ciciliGhost") (nth 1 def))))
	     (clauses (if is-ghost (nthcdr 1 def) (nthcdr 2 def)))
	     (guard-specifier (make-specifier name (if is-ghost '|@GHOST| '|@GUARD|) nil nil nil nil nil nil nil)))
    (let ((attributes '()))
      (dolist (clause clauses)
	    (if (consp clause)
	        (let ((construct (car clause)))
	          (cond ((find (char (symbol-name construct) 0) "@#")
		             (add-inner (specify-preprocessor clause attributes) guard-specifier)
		             (setq attributes '()))
		            ((key-eq construct '|static|)   (push clause attributes))
		            ((key-eq construct '|decl|)     (push clause attributes))
		            ((key-eq construct '|inline|)   (push clause attributes))
		            ((key-eq construct '|register|) (push clause attributes))
		            ((key-eq construct '|auto|)     (push clause attributes))
		            ((key-eq construct '|extern|)   (push clause attributes))
		            ((key-eq construct '|resolve|)  (push clause attributes))
		            ((key-eq construct '|defer|)    (push clause attributes))
		            ((key-eq construct '|include|)
		             (add-inner (specify-include  clause attributes) guard-specifier) (setq attributes '()))
		            ((key-eq construct '|var|)
		             (add-inner (specify-variable clause attributes) guard-specifier) (setq attributes '()))
		            ((key-eq construct '|func|)
		             (add-inner (specify-function clause attributes) guard-specifier) (setq attributes '()))
		            ((key-eq construct '|method|)
		             (add-inner (specify-function clause attributes) guard-specifier) (setq attributes '()))
		            ((key-eq construct '|enum|)
		             (add-inner (specify-enum     clause attributes) guard-specifier) (setq attributes '()))
		            ((key-eq construct '|struct|)
		             (add-inner (specify-struct   clause attributes) guard-specifier) (setq attributes '()))
		            ((key-eq construct '|union|)
		             (add-inner (specify-union    clause attributes) guard-specifier) (setq attributes '()))
		            ((key-eq construct '|typedef|)
		             (add-inner (specify-typedef  clause attributes) guard-specifier) (setq attributes '()))
		            ((key-eq construct '|guard|)
		             (add-inner (specify-guard    clause attributes) guard-specifier) (setq attributes '()))
		            ((key-eq construct '|ghost|)
		             (add-inner (specify-guard    clause attributes t) guard-specifier) (setq attributes '()))
		            ((key-eq construct '|module|)
		             (add-inner (specify-module   clause attributes) guard-specifier) (setq attributes '()))
		            (t (add-inner (specify-expr   clause) guard-specifier))))
            (specify-guard (LIST '|ghost|) () t))))
	        ;; (error (format nil "syntax error ~A" clause)))))
    guard-specifier))
