(in-package :cicili)

(defun compile-name (name lvl globals)
  (if (symbolp name)
      (set-ast-line (output (symbol-name name)))
      (if (and (typep name 'sp) (key-eq '|@TYPEOF| (construct name)))
          (compile-typeof name lvl globals)
          (let ((type (car name)))
            (cond ((or (key-eq '|struct| type) (key-eq '|union| type))
                   (set-ast-line (output (symbol-name type)))
                   (output " ")
                   (set-ast-line (output (symbol-name (cadr name)))))
                  ((key-eq '|typeof| type)
                   (set-ast-line (output "typeof("))
                   (compile-form (cadr name) (1+ lvl) globals)
                   (set-ast-line (output ")")))
                  (t (error (format nil  "wrong name: ~A" name))))))))

(defun compile-type-name (name lvl globals)
  (cond ((key-eq name '|uchar|)  (set-ast-line (output "unsigned char")))
	    ((key-eq name '|ushort|) (set-ast-line (output "unsigned short")))
	    ((key-eq name '|uint|)   (set-ast-line (output "unsigned int")))
	    ((key-eq name '|ulong|)  (set-ast-line (output "unsigned long")))
	    ((key-eq name '|llong|)  (set-ast-line (output "long long")))
	    ((key-eq name '|ullong|) (set-ast-line (output "unsigned long long")))
	    ((key-eq name '|i8|)     (set-ast-line (output "int8_t")))
	    ((key-eq name '|u8|)     (set-ast-line (output "uint8_t")))
	    ((key-eq name '|i16|)    (set-ast-line (output "int16_t")))
	    ((key-eq name '|u16|)    (set-ast-line (output "uint16_t")))
	    ((key-eq name '|i32|)    (set-ast-line (output "int32_t")))
	    ((key-eq name '|u32|)    (set-ast-line (output "uint32_t")))
	    ((key-eq name '|i64|)    (set-ast-line (output "int64_t")))
	    ((key-eq name '|u64|)    (set-ast-line (output "uint64_t")))
	    ((key-eq name '|i128|)   (set-ast-line (output "__int128")))
	    ((key-eq name '|u128|)   (set-ast-line (output "unsigned __int128")))
	    ((key-eq name '|real|)   (set-ast-line (output "long double")))
	    ((key-eq name '|auto|)   (set-ast-line (output "__auto_type")))
	    ((key-eq name '|$$$|)    (set-ast-line (output "...")))
	    (t (compile-name name lvl globals))))

(defun compile-array (desc lvl globals)
  (cond ((null desc) t) ; empty
        ((= (length desc) 1)
         (set-ast-line (output "["))
         (let ((amount (nth 0 desc)))
           (unless (key-eq '|NULL| (name amount)) (compile-form (nth 0 desc) (1+ lvl) globals)))
         (set-ast-line (output "]")))
        ((= (length desc) 2)
         (set-ast-line (output "["))
         (let ((amount (nth 0 desc)))
           (unless (key-eq '|NULL| (name amount)) (compile-form (nth 0 desc) (1+ lvl) globals)))
         (set-ast-line (output "]"))
         (set-ast-line (output "["))
         (let ((amount (nth 1 desc)))
           (unless (key-eq '|NULL| (name amount)) (compile-form (nth 1 desc) (1+ lvl) globals)))
         (set-ast-line (output "]")))
        (t (error (format nil "wrong array description, maybe #' missed for function initializer ~A" desc)))))

(defun format-type (const typeof modifier const-ptr name array-def anonymous lvl globals)
  (when anonymous (setq name (format nil "/* ~A */" name)))
  (when const     (set-ast-line (output "const ")))
  (unless (null typeof) (compile-type-name typeof lvl globals))
  (when modifier  (output " ") (set-ast-line (output "~A" modifier)))
  (when const-ptr (output " ") (set-ast-line (output "const" const-ptr)))
  (let ((line-n   -1)
        (col-n    -1))
    (when name      (output " ")
          (setq line-n   (funcall *line-num* 0))
          (setq col-n    (funcall *col-num* 0))
          (set-ast-line (output "~A "(if (str:starts-with-p "_ciciliParam_" (symbol-name name)) " " name))))
    (compile-array array-def lvl globals)
    (values line-n col-n)))

(defun compile-spec-type (spec lvl globals)
  (let ((const     (const      spec))
	    (typeof    (typeof     spec))
	    (modifier  (modifier   spec))
	    (const-ptr (const-ptr  spec))
	    (name      (name       spec))
	    (array-def (array-def  spec))
	    (anonymous (anonymous  spec)))
    (if (key-eq typeof '|func|)
        (progn
          (when const (set-ast-line (output "const ")))
          (compile-function (car array-def) lvl '() :type t))
        (format-type const typeof modifier const-ptr name array-def anonymous lvl globals))))

(defun format-type-value (const typeof modifier const-ptr name array-def default anonymous lvl globals &optional defer)
  (when anonymous (setq name (format nil "/* ~A */" name)))
  (let ((ns (multiple-value-list
                (format-type const typeof modifier const-ptr name array-def anonymous lvl globals))))

    (when defer
      (output " ")
      (set-ast-line (output "__attribute__(("))
      (set-ast-line (output "__cleanup__("))
      (compile-form defer (1+ lvl) globals)
      (set-ast-line (output ")))")))
    
    (when (and (not (null default)) (not (key-eq (construct default) '|@NIL|)))
      (output " ")
      (set-ast-line (output "= "))

      (let* ((line-n   (nth 0 ns))
             (col-n    (nth 1 ns))
             (ast      (prev-ast-by-key< (gethash 'key-def (keys default))))
             (info     (getf ast 'info))
             (dump     (reverse (getf ast 'dump)))
             (spec-key (ast-key< line-n col-n))
             (res      (gethash 'res-def (keys default))))
        (setf (gethash 'key-def (keys default)) spec-key)
        (when *debug-resolve*
          (display "resolving def:" line-n col-n "RES:" res "INFO:" info #\Newline dump #\Newline))
        
        (cond ((null ast)
	           (compile-form default (1+ lvl) globals))
              (res
               (set-ast-line (output "~A" res))
               (set-ast-line (output "("))
               (compile-form default (1+ lvl) globals)
               (output ")"))
              ((str:containsp "incompatible pointer types" info)
               (let* ((result (multiple-value-list (ppcre:scan-to-strings *trait-regex* info)))
                      (matches (cadr result)))
                 ;; (display "GGGGGG" matches #\Newline)
                 (let ((resu (make-shared-name (elt matches 1) (format nil "to~A" (elt matches 0)))))
                   (setf (gethash 'res-def (keys default)) resu)
                   (set-ast-line (output "~A" resu))
                   (set-ast-line (output "("))
                   (compile-form default (1+ lvl) globals)
                   (output ")"))))
              ((str:containsp "format specifies type" info)
               (let* ((result (multiple-value-list (ppcre:scan-to-strings *trait-regex* info)))
                      (matches (cadr result)))
                 ;; (display "GGGGGG" matches #\Newline)
                 (let ((resu (make-shared-name (elt matches 0) (format nil "to~A" (elt matches 1)))))
                   (setf (gethash 'res-def (keys default)) resu)
                   (set-ast-line (output "~A" resu))
                   (set-ast-line (output "("))
                   (compile-form default (1+ lvl) globals)
                   (output ")"))))
              (t (compile-form default (1+ lvl) globals)))))))

(defun compile-spec-type-value (spec lvl globals &optional defer &key ((:unique is-unique) nil))
  (let ((const     (const      spec))
	    (typeof    (typeof     spec))
	    (modifier  (modifier   spec))
	    (const-ptr (const-ptr  spec))
	    (name      (name       spec))
	    (array-def (array-def  spec))
	    (default   (default    spec))
	    (anonymous (anonymous  spec)))
    (if (key-eq typeof '|func|)
        (progn
          (when const (set-ast-line (output "const ")))
          (compile-function (car array-def) lvl '() :type t)
          (when (and (not (null default)) (not (key-eq (construct default) '|@NIL|)))
            (output " ")
            (set-ast-line (output "= "))
            (set-ast-line (output "~A" (if is-unique (unique default) (name default))))))
        (format-type-value const typeof modifier const-ptr
                           (if is-unique (unique spec) name)
                           array-def default anonymous lvl globals defer))))

(defun compile-symbol (spec symbol)
  (let* ((line-n   (funcall *line-num* 0))
         (col-n    (funcall *col-num* 0))
         (ast      (prev-ast-by-key< (gethash 'key-sym (keys spec))))
         (info     (getf ast 'info))
         (spec-key (ast-key< line-n col-n))
         (res      (gethash 'res-sym (keys spec))))
    (setf (gethash 'key-sym (keys spec)) spec-key)
    (when *debug-resolve*
      (display "resolving symbol:" line-n col-n "RES:" res "INFO:" info #\Newline))
    (if (null ast)
	    (set-ast-line (output "~A " symbol))
        (if info
            (cond ((str:containsp "take the address with &" info)
                   (let ((resu (format nil "\&~A" symbol)))
                     (setf (gethash 'res-sym (keys spec)) resu)
                     (set-ast-line (output resu))))
                  ((str:containsp "passing 'typeof ((" info)
                   (let ((resu (format nil "\&~A" symbol)))
                     (setf (gethash 'res-sym (keys spec)) resu)
                     (set-ast-line (output resu))))
                  ((str:containsp "__ciciliL_" info)
                   (let ((resu (format nil "\&~A" symbol)))
                     (setf (gethash 'res-sym (keys spec)) resu)
                     (set-ast-line (output resu))))
                  ((str:containsp "expression result unused" info)
                   (let ((resu (format nil "~A " symbol)))
                     (setf (gethash 'res-sym (keys spec)) resu)
                     (set-ast-line (output resu))))
                  ((str:containsp "member reference type" info)
                   (let ((resu (format nil "~A " symbol)))
                     (setf (gethash 'res-sym (keys spec)) resu)
                     (set-ast-line (output resu))))
                  ((str:containsp "no member named" info)
                   (set-ast-line (output "~A " symbol))) ; ignore for ->
                  ((str:containsp "format specifies type" info)
                   (set-ast-line (output "~A " symbol))) ; ignore for arg
                  ((str:containsp "incompatible pointer types" info)
                   (set-ast-line (output "~A " symbol))) ; ignore for arg
                  (t (error (format nil "cicili: atom: ~A. ~S~%~A" spec-key (str:substring 0 340 info) spec))))
            (if (null res)
                (set-ast-line (output "~A " symbol))
                (set-ast-line (output res)))))))

(defun compile-atom (spec lvl globals)
  (with-slots (construct (value name) typeof) spec
    (unless (or (key-eq construct '|@ATOM|) (key-eq construct '|@SYMBOL|))
      (error (format nil "atom syntax error \"~A\"" spec)))
    (cond ((and (key-eq typeof '|@SYMBOL|) (string= (symbol-name value) "this"))
           (set-ast-line (output "~A " '|this|)))
          ((key-eq typeof '|@SYMBOL|)
           (compile-symbol spec value))
          ((key-eq typeof '|@CHAR|) (set-ast-line (output "'~A'" value))) 
          (t (set-ast-line (output "~A" value))))))

(defun compile-code (spec lvl globals)
  (with-slots ((content default)) spec
    (set-ast-line (output "~A" content))))

(defun compile-list (spec lvl globals)
  (with-slots ((items default)) spec
    (let ((ast (prev-ast<)))
      (if (null ast)
	      (set-ast-line (output "{ "))
          (let ((info (getf ast 'info)))
            (if info
                (error (format nil "cicili: list: ~S" (str:substring 0 340 info)))
                (set-ast-line (output "{ "))))))
    (let ((l (length items))
          (m-init nil))
      (loop for i from 1 to l
            for item in (default spec)
            do (progn
                 (if (or (key-eq '|@SYMBOL| (construct item))
                       (and (key-eq '|@ATOM| (construct item)) (key-eq '|@SYMBOL| (typeof item))
                          (equal (str:s-first (symbol-name (name item))) "$")))
                     (progn
                       (setq m-init t)
                       (set-ast-line (output "~A " (str:replace-all "$" "." (symbol-name (name item))))))
                     (progn
                       (when m-init (set-ast-line (output "= ")))
                       (compile-form item (1+ lvl) globals)
                       (setq m-init nil)))
                 (when (and (not m-init) (< i l)) (output ", ")))))
    (set-ast-line (output "}"))))

(defun compile-unary (spec lvl globals)
  (with-slots ((oprt name) (is-postfix modifier) (oprnd default)) spec
    (output "(")
    (let ((ast (prev-ast<)))
      (unless (null ast)
        (let ((info (getf ast 'info)))
          (when info
            (error (format nil "cicili: unary: ~S" (str:substring 0 340 info)))))))
    (if is-postfix
        (progn
          (compile-form oprnd (1+ lvl) globals)
	      (set-ast-line (output "~A"  oprt)))
        (progn
          (set-ast-line (output "~A" oprt))
          (compile-form oprnd (1+ lvl) globals)))
    (output ")")))

(defun compile-operator (spec lvl globals)
  (with-slots ((opr name) (seq default)) spec
    (output "(")
    (let ((ast (prev-ast<)))
      (unless (null ast)
        (let ((info (getf ast 'info)))
          (when info
            (error (format nil "cicili: operator: ~S" (str:substring 0 340 info)))))))
    (dolist (frm seq)
      (compile-form frm (1+ lvl) globals)
      (output " "))
    (output ")")))

(defun compile-assignment (spec lvl globals)
  (with-slots ((opr name) (seq default)) spec
    (when (> lvl -1) (output "~&~A" (indent lvl)))
    (dolist (frm seq)
      (compile-form frm (1+ lvl) globals)
      (output " "))
    (when (> lvl -1) (output ";~%"))))

(defun compile-nth (spec lvl globals)
  (with-slots ((index name) (array default)) spec
    (compile-form array (1+ lvl) globals)
    (output "[")
    (compile-form index (1+ lvl) globals)
    (output "]")))

(defun compile-? (spec lvl globals)
  (with-slots ((condition name) (exprs default)) spec
    (output "((")
    (compile-form condition (1+ lvl) globals)
    (output ") ? ")
    (compile-form (nth 0 exprs) (1+ lvl) globals)
    (output " \: ")
    (compile-form (nth 1 exprs) (1+ lvl) globals)
    (output ")")))

(defun compile-cast (spec lvl globals)
  (with-slots (typeof (value default)) spec
    (output "((")
    (compile-spec-type spec lvl globals)
    (output ")")
    (compile-form value (1+ lvl) globals)
    (output ")")))

(defun compile-$ (spec lvl globals)
  (with-slots ((receiver name) (member default)) spec
    (let* ((line-n     (funcall *line-num* 0))
           (col-n      (funcall *col-num* 0))
           (begin-ast  (prev-ast-by-key< (gethash 'key-$ (keys spec))))        ; --
           (ptr-ast    (prev-ast-by-key< (getf begin-ast 'ptr)))
           (mtd-ast    (prev-ast-by-key< (getf begin-ast 'mtd)))
           (end-ast    (prev-ast-by-key< (getf begin-ast 'end)))
           (begin-info (getf begin-ast 'info)) ; --
           (begin-dump (reverse (getf begin-ast 'dump))) ; --
           
           (ptr-info   (getf ptr-ast   'info))
           (mtd-info   (getf mtd-ast   'info))
           (end-info   (getf end-ast   'info))
           (spec-key   (ast-key< line-n col-n))
           (res        (gethash 'res-$ (keys spec))))
      (setf (gethash 'key-$ (keys spec)) spec-key)
      (when *debug-resolve*
        (display "resolving .:" line-n col-n "RES:" res "INFO:"
                 begin-info ptr-info mtd-info end-info #\Newline begin-dump #\Newline))
      
      (cond (res
             (set-ast-line (output "("))
             (compile-form receiver (1+ lvl) globals)
             (set-ast-line (output res))
             (compile-form member (1+ lvl) globals)
             (output ")"))
            ((or (null *resolve*) ; function without resolver (inline in header or attr resolve #f)
               (null begin-ast)  ; access member by instance default for first run
               (and (null begin-info) (null ptr-info) (null mtd-info) (null end-info)))
             (set-ast-line (output "("))
             (compile-form receiver (1+ lvl) globals)
             (setf (getf (gethash (ast-key< line-n col-n) (nth 0 *ast-lines*)) 'ptr)
                   (ast-key< (funcall *line-num* 0) (funcall *col-num* 0)))
             (set-ast-line (output ". "))
             (setf (getf (gethash (ast-key< line-n col-n) (nth 0 *ast-lines*)) 'mtd)
                   (ast-key< (funcall *line-num* 0) (funcall *col-num* 0)))
             (compile-form member (1+ lvl) globals)
             (setf (getf (gethash (ast-key< line-n col-n) (nth 0 *ast-lines*)) 'end)
                   (ast-key< (funcall *line-num* 0) (funcall *col-num* 0)))
             (output ")"))
            ((and (str:containsp "member reference type" ptr-info) (str:containsp "is a pointer" ptr-info))
             (let ((resu "->"))
               (setf *more-run* t)
               (setf (gethash 'res-$ (keys spec)) resu)
               (set-ast-line (output "("))
               (compile-form receiver (1+ lvl) globals)
               (set-ast-line (output resu))
               (compile-form member (1+ lvl) globals)
               (output ")")))
            (t (error (format nil "cicili\: unresolved member reference type ~A. ~S~%~A"
                              spec-key (str:substring 0 340 (or mtd-info ptr-info begin-info)) spec)))))))

(defun compile--> (spec lvl globals)
  (with-slots ((receiver name) (method default) (args body)) spec
    (let* ((line-n     (funcall *line-num* 0))
           (col-n      (funcall *col-num* 0))
           (begin-ast  (prev-ast-by-key< (gethash 'key--> (keys spec))))        ; --
           (ptr-ast    (prev-ast-by-key< (getf begin-ast 'ptr)))
           (mtd-ast    (prev-ast-by-key< (getf begin-ast 'mtd)))
           (end-ast    (prev-ast-by-key< (getf begin-ast 'end)))
           (begin-info (getf begin-ast 'info)) ; --
           (begin-dump (reverse (getf begin-ast 'dump))) ; --
           
           (ptr-info   (getf ptr-ast   'info))
           (mtd-info   (getf mtd-ast   'info))
           (end-info   (getf end-ast   'info))
           (spec-key   (ast-key< line-n col-n))
           (res        (gethash 'res--> (keys spec))))
      (setf (gethash 'key--> (keys spec)) spec-key)
      (when *debug-resolve*
        (display "resolving ->:" line-n col-n "RES:" res "INFO:" 
                 begin-info ptr-info mtd-info end-info #\Newline begin-dump #\Newline))
      
      (cond (res
             (if (str:starts-with-p (str:replace-first "\\(.*" "" (make-shared-name (name receiver) "") :regex t)
                   res) ; was shared or method
                 (progn
                   (set-ast-line (output res))
                   (output "(")
                   (compile-args (default args) lvl globals nil)
                   (setf (getf (gethash (ast-key< line-n col-n) (nth 0 *ast-lines*)) 'end)
                         (ast-key< (funcall *line-num* 0) (funcall *col-num* 0)))
                   (output ")"))
                 (progn
                   (set-ast-line (output res))
                   (output "(")
                   (compile-form receiver (1+ lvl) globals)
                   (compile-args (default args) lvl globals t)
                   (setf (getf (gethash (ast-key< line-n col-n) (nth 0 *ast-lines*)) 'end)
                         (ast-key< (funcall *line-num* 0) (funcall *col-num* 0)))
                   (output ")"))))
            ((or (null *resolve*) ; function without resolver (inline in header or attr resolve #f)
               (null begin-ast)  ; access member by pointer default for first run
               (and (null begin-info) (null ptr-info) (null mtd-info) (null end-info)))
             (set-ast-line (output "("))
             (compile-form receiver (1+ lvl) globals)
             (setf (getf (gethash (ast-key< line-n col-n) (nth 0 *ast-lines*)) 'ptr)
                   (ast-key< (funcall *line-num* 0) (funcall *col-num* 0)))
             (set-ast-line (output "->"))
             (setf (getf (gethash (ast-key< line-n col-n) (nth 0 *ast-lines*)) 'mtd)
                   (ast-key< (funcall *line-num* 0) (funcall *col-num* 0)))
             (compile-form method (1+ lvl) globals)
             (compile-args (default args) lvl globals t)
             (setf (getf (gethash (ast-key< line-n col-n) (nth 0 *ast-lines*)) 'end)
                   (ast-key< (funcall *line-num* 0) (funcall *col-num* 0)))
             (output ")"))
            ((and ptr-info (str:containsp "expected ')'" ptr-info))
             (let ((resu (make-shared-name (name receiver) (name method))))
               (setf *more-run* t)               
               (setf (gethash 'res--> (keys spec)) resu)
               (set-ast-line (output "~A" resu))
               (output "(")
               (compile-args (default args) lvl globals nil)
               (output ")")))
            ((and ptr-info (str:containsp "expected expression" ptr-info))
             (if (key-eq (construct receiver) '|@ATOM|) 
                 (let ((resu (make-method-name (name receiver) (name method))))
                   (setf *more-run* t)               
                   (setf (gethash 'res--> (keys spec)) resu)
                   (set-ast-line (output resu))
                   (output "(")
                   (compile-form receiver (1+ lvl) globals)
                   (compile-args (default args) lvl globals t)
                   (output ")"))
                 (progn
                   (set-ast-line (output "("))
                   (compile-form receiver (1+ lvl) globals)
                   (setf (getf (gethash (ast-key< line-n col-n) (nth 0 *ast-lines*)) 'ptr)
                         (ast-key< (funcall *line-num* 0) (funcall *col-num* 0)))
                   (set-ast-line (output "->"))
                   (setf (getf (gethash (ast-key< line-n col-n) (nth 0 *ast-lines*)) 'mtd)
                         (ast-key< (funcall *line-num* 0) (funcall *col-num* 0)))
                   (compile-form method (1+ lvl) globals)
                   (compile-args (default args) lvl globals t)
                   (setf (getf (gethash (ast-key< line-n col-n) (nth 0 *ast-lines*)) 'end)
                         (ast-key< (funcall *line-num* 0) (funcall *col-num* 0)))
                   (output ")"))))
            ((and end-info (str:containsp "too few arguments" end-info))
             (error (format nil "cicili\: call: ~S" (str:substring 0 330 end-info))))
            ((and mtd-info (str:containsp "no member named" mtd-info))
             (let* ((matches     (ppcre:all-matches-as-strings "'(struct\\s+)?\\w+'" mtd-info))
                    (method      (car matches))
                    (parts       (str:split #\Space (cadr matches)))
                    (resu        (make-method-name (string-right-trim "'" (cadr parts)) (string-trim "'" method))))
               (if (string-equal (car parts) "'struct")
                   (progn
                     (setf *more-run* t)               
                     (setf (gethash 'res--> (keys spec)) resu))
                   (error (format nil "cicili\: nnn unresolved method reference type ~A. ~s~%~A"
                                  spec-key (str:substring 0 340 (or mtd-info ptr-info begin-info)) spec)))
               (set-ast-line (output "~A" resu))
               (output "(")
               (compile-form receiver lvl globals)
               (compile-args (default args) lvl globals t)
               (output ")")))
            (t (error (format nil "cicili\: unresolved method reference type ~A. ~S~%~A"
                              spec-key (str:substring 0 340 (or mtd-info ptr-info begin-info)) spec)))))))
                  
(defun compile-sizeof (spec lvl globals)
  (set-ast-line (output "sizeof("))
  (let ((ast (prev-ast<)))
    (unless (null ast)
      (let ((info (getf ast 'info)))
        (when info
          (error (format nil "cicili: unary: ~S" (str:substring 0 340 info)))))))
  (if (default spec)
      (compile-form (default spec) lvl globals)
      (compile-spec-type spec lvl globals))
  (output ")"))

(defun compile-typeof (spec lvl globals)
  (set-ast-line (output "typeof("))
  (compile-form (default spec) (1+ lvl) globals)
  (output ")"))

(defun compile-args (args lvl globals comma-first)
  (when (and comma-first (> (length args) 0)) (output ", "))
  (loop for arg in args
        with l = (1- (length args))
        for i from 0 to l
        do (progn
             (let* ((line-n   (funcall *line-num* 0))
                    (col-n    (funcall *col-num* 0))
                    (ast      (prev-ast-by-key< (gethash 'key-arg (keys arg))))
                    (info     (getf ast 'info))
                    (dump     (reverse (getf ast 'dump)))
                    (spec-key (ast-key< line-n col-n))
                    (res      (gethash 'res-arg (keys arg))))
               (setf (gethash 'key-arg (keys arg)) spec-key)
               (when *debug-resolve*
                 (display "resolving arg:" line-n col-n "RES:" res "INFO:" info #\Newline dump #\Newline))
               
               (cond ((null ast)
	                  (compile-form arg lvl globals))
                     (res
                      (set-ast-line (output "~A" res))
                      (set-ast-line (output "("))
                      (compile-form arg lvl globals)
                      (output ")"))
                     ((str:containsp "incompatible pointer types" info)
                      (let* ((result (multiple-value-list (ppcre:scan-to-strings *trait-regex* info)))
                             (matches (cadr result)))
                        ;; (display "GGGGGG" matches #\Newline)
                        (let ((resu (make-shared-name (elt matches 0) (format nil "to~A" (elt matches 1)))))
                          (setf (gethash 'res-arg (keys arg)) resu)
                          (set-ast-line (output "~A" resu))
                          (set-ast-line (output "("))
                          (compile-form arg lvl globals)
                          (output ")"))))
                     ((str:containsp "format specifies type" info)
                      (let* ((result (multiple-value-list (ppcre:scan-to-strings *trait-regex* info)))
                             (matches (cadr result)))
                        ;; (display "GGGGGG" matches #\Newline)
                        (let ((resu (make-shared-name (elt matches 1) (format nil "to~A" (elt matches 0)))))
                          (setf (gethash 'res-arg (keys arg)) resu)
                          (set-ast-line (output "~A" resu))
                          (set-ast-line (output "("))
                          (compile-form arg lvl globals)
                          (output ")"))))
                     ((str:containsp "member reference type" info)
                      (compile-form arg lvl globals))
                     (t (compile-form arg lvl globals))))
             (when (< i l) (output ", ")))))

(defun compile-call (spec lvl globals)
  (with-slots ((func name) (args default)) spec
    (when (> lvl -1) (output "~&~A" (indent lvl)))
    (compile-form func (1+ lvl) globals)
    (output "(")
    (unless (null args) (compile-args args lvl globals nil))
    (let ((ast (prev-ast<)))
      (if (null ast)
	      (set-ast-line (output ")"))
          (let ((info (getf ast 'info)))
            (if info
                (error (format nil "cicili: call: ~S" (str:substring 0 340 info)))
                (set-ast-line (output ")"))))))
    (when (> lvl -1) (output ";~%"))))

(defun compile-form (spec lvl globals)
  (with-slots (construct) spec
    (case construct
      ('|@NIL|    t)
      ('|@SYMBOL| (compile-atom       spec lvl globals))
      ('|@ATOM|   (compile-atom       spec lvl globals))
      ('|@CODE|   (compile-code       spec lvl globals))
      ('|@LIST|   (compile-list       spec lvl globals))
      ('|@UNARY|  (compile-unary      spec lvl globals))
      ('|@OPR|    (compile-operator   spec lvl globals))
      ('|@NTH|    (compile-nth        spec lvl globals))
      ('|@?|      (compile-?          spec lvl globals))
      ('|@CAST|   (compile-cast       spec lvl globals))
      ('|@$|      (compile-$          spec lvl globals))      
      ('|@->|     (compile-->         spec lvl globals))
      ('|@SIZEOF| (compile-sizeof     spec lvl globals))
      ('|@TYPEOF| (compile-typeof     spec lvl globals))
      ('|@LET|    (compile-let        spec lvl globals spec))
      ('|@LETN|   (compile-let        spec lvl globals spec t))
      ('|@BLOCK|  (compile-block      spec lvl globals spec t))
      ('|@PROGN|  (compile-progn      spec lvl globals))
      ('|@INCLUDE|(compile-include    spec 0   globals)) 
      ('|@VAR|    (compile-variable   spec 0   globals)) ; inside macros
      ('|@FUNC|   (compile-function   spec 0   globals)) 
      ('|@METHOD| (compile-function   spec 0   globals)) 
      ('|@ENUM|   (compile-enum       spec 0   globals)) 
      ('|@STRUCT| (compile-struct     spec 0   globals)) 
      ('|@UNION|  (compile-union      spec 0   globals)) 
      ('|@TYPEDEF|(compile-typedef    spec 0   globals)) 
      ('|@GUARD|  (compile-guard      spec 0   globals)) 
      ('|@GHOST|  (compile-guard      spec 0   globals t)) 
      ('|@MODULE| (compile-module     spec 0   globals))
      ('|@GENERIC|(compile-generic    spec 0   globals)) ; down here for inside macros 
      ('|@CALL|   (compile-call       spec -1  globals))
      ('|@BODY|   (compile-body       spec -1  globals spec))
      (t (error (format nil "expr syntax error ~A" spec))))))

(defun compile-variable (spec lvl globals &optional is-global &key ((:unique is-unique) nil))
  (let ((is-auto     nil)
	    (is-register nil)
	    (is-static   nil)
	    (is-extern   nil)
        (is-alloc    nil)
        (has-defer   nil))
    (dolist (attr (attrs spec))
      (case (car attr)
	    ('|auto|     (setq is-auto     t))
	    ('|register| (setq is-register t))
	    ('|static|   (setq is-static   t))
	    ('|extern|   (setq is-extern   t))
        ('|alloc|    (setq is-alloc    t))
        ('|defer|    (setq has-defer   (cdr attr)))))

    (loop for los being the hash-value of (inners spec)
          do (progn
               (if (key-eq '|@STRUCT| (construct los))
                   (when (or *target-header* (and is-static *target-source*))
                     (compile-struct los lvl globals :nested t :unique is-unique
                                     :static (if (and is-static *target-header*) t nil)))
                   (progn ; lambdas
                     (push (cons '|static| t) (attrs los))
                     (compile-function los lvl globals :unique is-unique)
                     (pop (attrs los))))))

    
    (output "~&~A" (indent lvl))
    (when is-extern   (set-ast-line (output "extern ")))
    (when is-static   (set-ast-line (output "static ")))
    (when is-register (set-ast-line (output "register ")))
    (when is-auto     (set-ast-line (output "auto ")))
    (compile-spec-type-value spec lvl globals has-defer :unique is-unique)
    (when is-global (output ";~%"))))

(defun compile-body (spec lvl globals parent-spec)
  (loop for form in (body spec)
        do (progn
             (case (construct form)
             ('|@ASSIGN| (compile-assignment form (1+ lvl) globals))
             ('|@CALL|   (compile-call       form (1+ lvl) globals))
             ('|@LET|    (compile-let        form (1+ lvl) globals parent-spec))
             ('|@LETN|   (compile-let        form (1+ lvl) globals parent-spec t))
             ('|@BLOCK|  (compile-block      form (1+ lvl) globals))
             ('|@PROGN|  (compile-progn      form (1+ lvl) globals))
             ('|@SET|    (compile-set        form (1+ lvl) globals))
             ('|@RETURN| (compile-return     form (1+ lvl) globals))
             ('|@IF|     (compile-if         form (1+ lvl) globals))
             ('|@SWITCH| (compile-switch     form (1+ lvl) globals))
             ('|@WHILE|  (compile-while      form (1+ lvl) globals))
             ('|@FOR|    (compile-for        form (1+ lvl) globals))
             ('|@COND|   (compile-cond       form (1+ lvl) globals))
             ('|@DO|     (compile-do         form (1+ lvl) globals))
             ('|@BODY|   (compile-body       form     lvl  globals spec))
             (t (unless (= lvl -1) (output "~&~A" (indent (1+ lvl))))
                (compile-form form (1+ lvl) globals)
                (unless (= lvl -1) (output ";~%")))))))

(defun compile-let (spec lvl globals parent-spec &optional is-n) ; is-n means letn -> scope is statement
  (let ((dynamics    '())
	    (locals      (copy-specifiers globals))
        (in-progn    (key-eq (construct parent-spec) '|@PROGN|)))
    (unless is-n (output "~&~A" (indent lvl)))
    (when (or in-progn is-n) (output "("))
    (output "{ /* ~A */~%" (name spec))
    (loop for var being the hash-value of (params spec)
          do (progn
               (compile-variable var (1+ lvl) locals t)
               (when (find '|alloc| (attrs var) :test #'key-eq) (push (name var) dynamics))))
    (compile-body (body spec) lvl locals spec)
    (output "~&~A" (indent lvl))
    (if (or in-progn is-n)
        (if is-n (output "})") (output "});~%"))
        (output "}~%"))))

(defun compile-block (spec lvl globals)
  (let ((locals      (copy-specifiers globals)))
    (output "~&~A" (indent lvl))
    (output "{ /* ~A */~%" (name spec))
    (compile-body (body spec) lvl locals spec)
    (output "~&~A" (indent lvl))
    (output "} /* ~A */~%" (name spec))))

(defun compile-progn (spec lvl globals)
  (let ((locals      (copy-specifiers globals)))
    (output "({ /* ~A */~%" (name spec))
    (compile-body (body spec) lvl locals spec)
    (output "~&~A" (indent lvl))
    (output "})" (name spec))))

(defun compile-set (spec lvl globals)
  (with-slots ((items default)) spec
    (dolist (item items)
      (when (> lvl -1) (output "~&~A" (indent lvl)))
      (compile-form (nth 0 item) (1+ lvl) globals)
      (output " ")

      (let* ((line-n   (funcall *line-num* 0))
             (col-n    (funcall *col-num* 0))
             (ast      (prev-ast-by-key< (gethash 'key-set (keys (nth 1 item)))))
             (info     (getf ast 'info))
             (dump     (reverse (getf ast 'dump)))
             (spec-key (ast-key< line-n col-n))
             (res      (gethash 'res-set (keys (nth 1 item)))))
        (setf (gethash 'key-set (keys (nth 1 item))) spec-key)
        (when *debug-resolve*
          (display "resolving set:" line-n col-n "RES:" res "INFO:" info #\Newline dump #\Newline))
        
        (cond ((null ast)
               (set-ast-line (output "= "))
	           (compile-form (nth 1 item) (1+ lvl) globals))
              (res
               (set-ast-line (output "= "))
               (set-ast-line (output "~A" res))
               (set-ast-line (output "("))
               (compile-form (nth 1 item) (1+ lvl) globals)
               (output ")"))
              ((str:containsp "incompatible pointer types" info)
               (let* ((result (multiple-value-list (ppcre:scan-to-strings *trait-regex* info)))
                      (matches (cadr result)))
                 ;; (display "GGGGGG" matches #\Newline)
                 (let ((resu (make-shared-name (elt matches 1) (format nil "to~A" (elt matches 0)))))
                   (setf (gethash 'res-set (keys (nth 1 item))) resu)
                   (set-ast-line (output "= "))
                   (set-ast-line (output "~A" resu))
                   (set-ast-line (output "("))
                   (compile-form (nth 1 item) (1+ lvl) globals)
                   (output ")"))))
              ((str:containsp "format specifies type" info)
               (let* ((result (multiple-value-list (ppcre:scan-to-strings *trait-regex* info)))
                      (matches (cadr result)))
                 ;; (display "GGGGGG" matches #\Newline)
                 (let ((resu (make-shared-name (elt matches 0) (format nil "to~A" (elt matches 1)))))
                   (setf (gethash 'res-set (keys (nth 1 item))) resu)
                   (set-ast-line (output "= "))
                   (set-ast-line (output "~A" resu))
                   (set-ast-line (output "("))
                   (compile-form (nth 1 item) (1+ lvl) globals)
                   (output ")"))))
              (t (set-ast-line (output "= "))
	             (compile-form (nth 1 item) (1+ lvl) globals))))
      (when (> lvl -1) (output ";~%")))))

(defun compile-return (spec lvl globals)
  (output "~&~A" (indent lvl))
  (set-ast-line (output "return "))
  (when (default spec) (compile-form (default spec) (1+ lvl) globals))
  (output ";~%"))

(defun compile-if (spec lvl globals)
  (let ((locals (copy-specifiers globals)))
    (output "~&~A" (indent lvl))
    (set-ast-line (output "if "))
    (let ((is-atom (key-eq '|@ATOM| (construct (name spec)))))
      (when is-atom (output "("))
      (compile-form (name spec) (1+ lvl) globals) ; condition
      (when is-atom (output ")")))
    (set-ast-line (output " ~%"))
    (compile-body (default spec) lvl locals spec)
    (let ((else-body (body spec))
          (locals (copy-specifiers globals)))
      (if (null else-body) (output "~%")
          (progn
            (output "~&~A" (indent lvl))
            (set-ast-line (output "else ~%"))
            (compile-body else-body lvl locals spec))))))

(defun compile-switch (spec lvl globals)
  (output "~&~A" (indent lvl))
  (set-ast-line (output "switch ("))
  (compile-form (name spec) (1+ lvl) globals)
  (set-ast-line (output ") {~%"))
  (dolist (ch-form (default spec))
    (let ((constr (construct ch-form)))
      (cond ((key-eq constr '|@CASE|)
             (output "~&~A" (indent lvl))
             (set-ast-line (output "case "))
             (compile-form (name ch-form) (1+ lvl) globals)
             (output ":~%")
             (compile-body (body ch-form) (+ lvl 2) globals spec))
	        ((key-eq constr '|@DEFAULT|)
             (output "~&~A" (indent lvl))
             (set-ast-line (output "default:~%" (indent (+ lvl 1))))
	         (compile-body (body ch-form) (+ lvl 2) globals spec))
	        (t (error (format nil "only case or default form ~A" spec))))))
  (output "~&~A}~%" (indent lvl)))

(defun compile-while (spec lvl globals)
  (let ((locals (copy-specifiers globals)))
    (output "~&~A" (indent lvl))
    (set-ast-line (output "while ("))
    (compile-form (name spec) (1+ lvl) globals) ; condition
    (set-ast-line (output ") {~%"))
    (compile-body (body spec) lvl locals spec)
    (output "~&~A" (indent lvl))
    (output "} ~%")))

(defun compile-do (spec lvl globals)
  (let ((locals (copy-specifiers globals)))
    (output "~&~A" (indent lvl))
    (set-ast-line (output "do { ~%"))
    (compile-body (body spec) lvl locals spec)
    (output "~&~A" (indent lvl))
    (output "} while (")
    (compile-form (name spec) (1+ lvl) globals) ; condition
    (set-ast-line (output ");~%"))))

(defun compile-for (spec lvl globals)
  (let ((params (params spec))
        (locals (copy-specifiers globals)))
    (output "~&~A" (indent lvl))
    (set-ast-line (output "for ("))
    (loop for var being the hash-value of params
          with lc = (1- (hash-table-count params))
          for i from 0 to lc
          do (progn
               (compile-spec-type-value var lvl locals)
               (when (< i lc) (output ", "))))
    (output "; ")
    (compile-form (name spec) (1+ lvl) locals) ; condition
    (set-ast-line (output "; "))
    (let ((forms (body (default spec))))
      (loop for form in forms
            with lc = (1- (length forms))
            for i from 0 to lc
            do (progn
                 (case (construct form)
                   ('|@ATOM|   (compile-atom       form lvl locals))
                   ('|@UNARY|  (compile-unary      form lvl locals))
                   ('|@ASSIGN| (compile-assignment form -1 locals))
                   ('|@CALL|   (compile-call       form -1 locals))
                   ('|@SET|    (compile-set        form -1 locals))
                   (t (error (format nil "unsupported form inside advance part of for loop ~A" spec))))
                 (when (< i lc) (output ", ")))))
    (set-ast-line (output ") {~%"))
    (compile-body (body spec) lvl locals spec)
    (output "~&~A" (indent lvl))
    (output "} ~%")))

(defun compile-cond (spec lvl globals)
  (let ((locals (copy-specifiers globals))
        (nodes (body spec)))
    (loop for node in nodes
          for i from 0 to (length nodes)
          do (let ((condition (car node))
                   (body (cadr node)))
               (output "~&~A" (indent lvl))
               (set-ast-line (if (= i 0) (output "if ") (output "else if ")))
               (let ((is-atom (key-eq '|@ATOM| condition)))
                (when is-atom (output "("))
                (compile-form condition lvl globals) ; each condition
                (when is-atom (output ")")))
               (set-ast-line (output " ~%"))
               (compile-body body lvl locals spec)))))

(defun compile-function (spec lvl globals &key ((:type as-type) nil) ((:unique is-unique) nil))
  ;; resolve ?
  (let ((is-static  nil)
	    (is-declare as-type)
	    (is-inline  nil)
	    (is-extern  nil)
        (do-resolve nil))
    (dolist (attr (attrs spec))
      (case (car attr)
	    ('|static|  (setq is-static  t))
	    ('|decl|    (setq is-declare t))
	    ('|inline|  (setq is-inline  t))
	    ('|extern|  (setq is-extern  t))
        ('|resolve| (setq do-resolve (cdr attr)))))
    (when (and (> *ast-run* 1) (key-eq '|false| do-resolve)) (setq *resolve* nil))

    ;; compile lambdas and online structs before function
    (unless as-type
      (loop for los being the hash-value of (inners spec)
            do (progn
                 (if (key-eq '|@STRUCT| (construct los)) ; inline structs
                     (when (or *target-header* (and is-static *target-source*))
                       (compile-struct los lvl globals :nested t :unique is-unique
                                       :static (if (and is-static *target-header*) t nil)))
                     (progn ; lambdas
                       (push (cons '|static| t) (attrs los))
                       (compile-function los lvl globals :unique is-unique)
                       (pop (attrs los)))))))

    ;; compile function
    (let* ((name       (name   spec))
	       (is-method  (if (key-eq (construct spec) '|@METHOD|) t nil))
	       (is-shared  (and (listp name) (not is-method)))
	       (params     (params spec))
	       (body       (body   spec))
	       (locals     (copy-specifiers globals)))
      (let ((cparams '()))
        (maphash #'(lambda (in-name in-spec)
		             (case (construct in-spec)
		               ('|@PARAM| (setf (gethash in-name locals) in-spec)
                                  (push in-spec cparams))
		               (otherwise nil)))
	             params)
        (output "~&~A" (indent lvl))
        (when is-extern (set-ast-line (output "extern ")))
        (when is-inline (set-ast-line (output "__attribute__((weak)) ")))
        (when is-static (set-ast-line (output "static ")))
        (format-type (const spec) (typeof spec) (modifier spec) nil (const-ptr spec) (array-def spec) nil lvl locals)
        (output " ")
        (set-ast-line (output "~A " (if is-unique (unique spec)
                                        (if (or is-method is-shared)
                                            (if as-type
                                                (format nil "(*~A)" (if is-method
                                                                        (make-method-name (car name) (cdr name))
                                                                        (make-shared-name (car name) (cdr name))))
                                                (if is-method
                                                    (make-method-name (car name) (cdr name))
                                                    (make-shared-name (car name) (cdr name))))
                                            (if as-type (format nil "(*~A)" name) name)))))
        (output "(")
        (loop for param being the hash-value of params
              with lc = (1- (hash-table-count params))
              for i from 0 to lc
              do (progn
                   (compile-spec-type-value param lvl locals)
                   (when (< i lc) (output ", "))))
        (let ((ast (prev-ast<)))
          (unless (null ast)
            (let ((info (getf ast 'info)))
              (when info
                (error (format nil "cicili: function: ~S" (str:substring 0 340 info)))))))
        (set-ast-line (output ")"))
        (if is-declare
            (unless as-type (output ";~%"))
            (progn
              (output " ")
              (output "{~%")))
        (unless is-declare
          (progn
	        (compile-body body lvl locals spec)
	        (output "~&~A" (indent lvl))
            (output "}~%"))))))
  (setq *resolve* t))

(defun compile-preprocessor (spec lvl globals)
  (with-slots ((directive const) (name typeof) (macro default)) spec
    (compile-form directive lvl globals)
    (when name (compile-form name lvl globals))
    (when macro (compile-form macro (1+ lvl) globals))
    (output "~%")))

(defun compile-include (spec lvl globals)
  (with-slots ((headers params)) spec
    (dolist (header headers)
      (cond ((symbolp header)
             (set-ast-line (output "~&#include "))
             (set-ast-line (output "~A~%" header)))
	        ((stringp header)
             (set-ast-line (output "~&#include "))
             (set-ast-line (output "~S~%" header)))
	        (t (error "wrong inclusion"))))))

(defun compile-typedef (spec lvl globals)
  (set-ast-line (output "~&typedef "))
  (compile-spec-type spec lvl globals)
  (output ";~%"))

(defun compile-enum (spec lvl globals &key ((:nested is-nested) nil) ((:unique is-unique) nil))
  (let ((name         (name spec))
	    (is-anonymous (anonymous spec))
	    (counter      1)
	    (count        (hash-table-count (inners spec)))
	    (locals       (copy-specifiers globals)))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@VAR| (setf (gethash in-name locals) in-spec))
		           (otherwise nil)))
	         (inners spec))
    (output "~&~A" (indent lvl))
    (if is-anonymous
        (set-ast-line (output "enum "))
        (if is-nested
            (progn
              (set-ast-line (output "enum "))
              (set-ast-line (output "~A " (if is-unique (unique spec) name))))
            (progn
              (set-ast-line (output "typedef "))
              (set-ast-line (output "enum "))
              (set-ast-line (output "~A " (if is-unique (unique spec) name))))))
    (if is-anonymous
        (output "{ /* ~A */~%" name)
        (output "{~%"))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@VAR|
                    (output "~&~A" (indent (+ 1 lvl)))
		            (set-ast-line (output "~A" (if is-unique (unique in-spec) (name in-name))))
                    (unless (null (default in-spec))
                      (set-ast-line (output " = "))
                      (compile-form (default in-spec) (1+ lvl) locals))
                    (when (< counter count) (output ","))
                    (output "~%"))
		           (otherwise (error (format nil "unknown clause ~A inside ~A" in-name in-spec))))
		         (incf counter))
	         (inners spec))
    (output "~&}")
    (unless is-anonymous
      (output " ")
      (set-ast-line (output "~A" (if is-unique (unique spec) name))))
    (output ";~%")))

(defun compile-struct (spec lvl globals &key ((:nested is-nested) nil) ((:unique is-unique) nil) ((:static is-static) nil))
  (let ((name         (name spec))
	    (is-anonymous (anonymous spec))
	    (declares     (params spec))
	    (locals       (copy-specifiers globals)))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@VAR|  (setf (gethash in-name locals) in-spec))
		           ('|@FUNC| (setf (gethash in-name locals) in-spec))
		           ('|@PREPROC|  t)
		           ('|@ENUM|
		            (unless (anonymous spec) (setf (gethash in-name locals) in-spec))
		            (maphash #'(lambda (k v) (setf (gethash k locals) v)) (inners in-spec)))
		           ('|@STRUCT|
		            (setf (gethash in-name locals) in-spec)
		            (maphash #'(lambda (k v) (setf (gethash k locals) v)) (params in-spec)))
		           ('|@UNION|
		            (setf (gethash in-name locals) in-spec)
		            (maphash #'(lambda (k v) (setf (gethash k locals) v)) (params in-spec)))
		           (otherwise (error (format nil "unknown clause ~A inside ~A" in-name in-spec)))))
	         (inners spec))
    (output "~&~A" (indent lvl))
    (when is-static (set-ast-line (output "static ")))
    (if is-anonymous
        (set-ast-line (output "struct "))
        (if is-nested
            (progn
              (set-ast-line (output "struct "))
              (set-ast-line (output "~A " (if is-unique (unique spec) name))))
            (progn
              (set-ast-line (output "typedef "))
              (set-ast-line (output "struct "))
              (set-ast-line (output "~A " (if is-unique (unique spec) name))))))
    (if is-anonymous
        (output "{ /* ~A */~%" name)
        (output "{~%"))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@VAR|      (compile-variable     in-spec (+ 1 lvl) locals t))
		           ('|@FUNC|     (compile-function     in-spec (+ 1 lvl) locals))
		           ('|@PREPROC|  (compile-preprocessor in-spec (+ 1 lvl) locals))
		           ('|@ENUM|     (compile-enum         in-spec (+ 1 lvl) locals :nested t :unique is-unique))
		           ('|@STRUCT|   (compile-struct       in-spec (+ 1 lvl) locals :nested t :unique is-unique))
		           ('|@UNION|    (compile-union        in-spec (+ 1 lvl) locals :nested t :unique is-unique))
		           (otherwise nil)))
	         (inners spec))
    (output "~&~A" (indent lvl))
    (output "}")
    (if is-anonymous
        (when (> (hash-table-count declares) 0)
          (loop for dec being the hash-values of declares
                with l = (1- (hash-table-count declares))
                for i from 0 to l
                do (progn
                     (compile-spec-type dec lvl globals)
                     (when (< i l) (output ",")))))
        (unless is-nested
          (output " ")
          (set-ast-line (output "~A" (if is-unique (unique spec) name)))))
    (output ";~%")))

(defun compile-union (spec lvl globals &key ((:nested is-nested) nil) ((:unique is-unique) nil))
  (let ((name         (name spec))
	    (is-anonymous (anonymous spec))
	    (declares     (params spec))
	    (locals       (copy-specifiers globals)))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@VAR| (setf (gethash in-name locals) in-spec))
		           ('|@PREPROC|  t)
		           ('|@STRUCT|
		            (setf (gethash in-name locals) in-spec)
		            (maphash #'(lambda (k v) (setf (gethash k locals) v)) (params in-spec)))
		           ('|@UNION|
		            (setf (gethash in-name locals) in-spec)
		            (maphash #'(lambda (k v) (setf (gethash k locals) v)) (params in-spec)))
		           (otherwise (error (format nil "unknown clause ~A inside ~A" in-name in-spec)))))
	         (inners spec))
    (output "~&~A" (indent lvl))
    (if is-anonymous
        (set-ast-line (output "union "))
        (progn
          (set-ast-line (output "typedef "))
          (set-ast-line (output "union "))
          (set-ast-line (output "~A " (if is-unique (unique spec) name)))))
    (if is-anonymous
        (output "{ /* ~A */~%" name)
        (output "{~%"))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@VAR|      (compile-variable     in-spec (+ 1 lvl) locals t))
		           ('|@PREPROC|  (compile-preprocessor in-spec (+ 1 lvl) locals))
		           ('|@STRUCT|   (compile-struct       in-spec (+ 1 lvl) locals :nested t :unique is-unique))
		           ('|@UNION|    (compile-union        in-spec (+ 1 lvl) locals :nested t :unique is-unique))
		           (otherwise nil)))
	         (inners spec))
    (output "~&~A" (indent lvl))
    (output "}")
    (if is-anonymous
        (when (> (hash-table-count declares) 0)
          (loop for dec being the hash-values of declares
                with l = (1- (hash-table-count declares))
                for i from 0 to l
                do (progn
                     (compile-spec-type dec lvl globals)
                     (when (< i l) (output ",")))))
        (progn
          (output " ")
          (set-ast-line (output "~A" name))))
    (output ";~%")))

(defun compile-guard (spec lvl globals &optional is-ghost &key ((:nested is-nested) nil))
  (let ((name (name spec)))
    (unless is-ghost
      (set-ast-line (output "~&#ifndef ~A~%" name))
      (set-ast-line (output "~&#define ~A~%" name)))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@VAR|      (compile-variable     in-spec lvl globals (if is-ghost nil t)))
		           ('|@FUNC|     (compile-function     in-spec lvl globals))
		           ('|@METHOD|   (compile-function     in-spec lvl globals))
		           ('|@PREPROC|  (compile-preprocessor in-spec lvl globals))
		           ('|@INCLUDE|  (compile-include      in-spec lvl globals))
		           ('|@TYPEDEF|  (compile-typedef      in-spec lvl globals))
		           ('|@ENUM|     (compile-enum         in-spec lvl globals))
		           ('|@STRUCT|   (compile-struct       in-spec lvl globals))
		           ('|@UNION|    (compile-union        in-spec lvl globals))
		           ('|@GUARD|    (compile-guard        in-spec lvl globals nil :nested t))
		           ('|@GHOST|    (compile-guard        in-spec lvl globals t :nested t))
		           ('|@MODULE|   (compile-module       in-spec lvl globals))
		           ('|@GENERIC|  (compile-generic      in-spec lvl globals))
		           (otherwise    (compile-form         in-spec lvl globals)
                                 (output "~%"))))
	         (inners spec))
    (unless is-ghost (set-ast-line (output "~&#endif /* ~A */ ~%" name)))))
