(in-package :lcc)

(defun compile-name (name)
  (set-ast-line (output (symbol-name name))))

(defun compile-type-name (name)
  (cond ((key-eq name '|uchar|)  (set-ast-line (output "unsigned char")))
	    ((key-eq name '|ushort|) (set-ast-line (output "unsigned short")))
	    ((key-eq name '|uint|)   (set-ast-line (output "unsigned int")))
	    ((key-eq name '|ulong|)  (set-ast-line (output "unsigned long")))
	    ((key-eq name '|llong|)  (set-ast-line (output "long long")))
	    ((key-eq name '|ullong|) (set-ast-line (output "unsigned long long")))
	    ((key-eq name '|i8|)     (set-ast-line (output "int8_t")))
	    ((key-eq name '|u8|)     (set-ast-line (output "uint8_t")))
	    ((key-eq name '|i16|)    (set-ast-line (output "int16_t")))
	    ((key-eq name '|u16|)    (set-ast-line (output "uint16_t")))
	    ((key-eq name '|i32|)    (set-ast-line (output "int32_t")))
	    ((key-eq name '|u32|)    (set-ast-line (output "uint32_t")))
	    ((key-eq name '|i64|)    (set-ast-line (output "int64_t")))
	    ((key-eq name '|u64|)    (set-ast-line (output "uint64_t")))
	    ((key-eq name '|i128|)   (set-ast-line (output "__int128")))
	    ((key-eq name '|u128|)   (set-ast-line (output "unsigned __int128")))
	    ((key-eq name '|real|)   (set-ast-line (output "long double")))
	    (t (compile-name name))))

(defun compile-array (desc globals)
  (cond ((null desc) t) ; empty
        ((= (length desc) 1)
         (set-ast-line (output "["))
         (let ((amount (nth 0 desc)))
           (unless (key-eq '|NULL| (name amount)) (compile-form (nth 0 desc) globals)))
         (set-ast-line (output "]")))
        ((= (length desc) 2)
         (set-ast-line (output "["))
         (let ((amount (nth 0 desc)))
           (unless (key-eq '|NULL| (name amount)) (compile-form (nth 0 desc) globals)))
         (set-ast-line (output "]"))
         (set-ast-line (output "["))
         (let ((amount (nth 1 desc)))
           (unless (key-eq '|NULL| (name amount)) (compile-form (nth 1 desc) globals)))
         (set-ast-line (output "]")))
        (t (error (format nil "wrong array description ~A" desc)))))

(defun format-type (const typeof modifier const-ptr name array-def anonymous globals)
  (when anonymous (setq name (format nil "/* ~A */" name)))
  (when const     (set-ast-line (output "const ")))
  (compile-type-name typeof)
  (when modifier  (output " ") (set-ast-line (output "~A" modifier)))
  (when const-ptr (output " ") (set-ast-line (output "const" const-ptr)))
  (when name      (output " ")
        (set-ast-line (output "~A" (if (str:starts-with-p "_lccParam_" (symbol-name name)) " " name))))
  (compile-array array-def globals))

(defun compile-spec-type (spec globals)
  (let ((const     (const     spec))
	    (typeof    (typeof    spec))
	    (modifier  (modifier  spec))
	    (const-ptr (const-ptr spec))
	    (name      (name      spec))
	    (array-def (array-def spec))
	    (anonymous (anonymous spec)))
    (if (key-eq typeof '|func|)
        (progn
          (when const (set-ast-line (output "const ")))
          (compile-function (car array-def) 0 '() t))
        (format-type const typeof modifier const-ptr name array-def anonymous globals))))

(defun format-type-value (const typeof modifier const-ptr name array-def default anonymous globals &optional defer)
  (when anonymous (setq name (format nil "/* ~A */" name)))
  (format-type const typeof modifier const-ptr name array-def anonymous globals)
  (when defer
    (output " ")
    (set-ast-line (output "__attribute__(("))
    (set-ast-line (output "__cleanup__("))
    (compile-form defer globals)
    (set-ast-line (output ")))")))
  (when (and (not (null default)) (not (key-eq (construct default) '|@NIL|)))
    (output " ")
    (set-ast-line (output "= "))
    (compile-form default globals)))

(defun compile-spec-type-value (spec globals &optional defer)
  (let ((const     (const     spec))
	    (typeof    (typeof    spec))
	    (modifier  (modifier  spec))
	    (const-ptr (const-ptr spec))
	    (name      (name      spec))
	    (array-def (array-def spec))
	    (default   (default   spec))
	    (anonymous (anonymous spec)))
    (if (key-eq typeof '|func|)
        (progn
          (when const (set-ast-line (output "const ")))
          (compile-function (car array-def) 0 '() t)
          (when (and (not (null default)) (not (key-eq (construct default) '|@NIL|)))
            (output " ")
            (set-ast-line (output "= "))
            (set-ast-line (output "~A" (name default)))))
        (format-type-value const typeof modifier const-ptr name array-def default anonymous globals defer))))

(defun compile-atom (spec globals)
  (with-slots (construct (value name) typeof) spec
    (unless (key-eq construct '|@ATOM|) (error (format nil "syntax error \"~A\"" spec)))
    (cond ((and (key-eq typeof '|@SYMBOL|) (string= (symbol-name value) "this"))
           (set-ast-line (output "~A " '|this|)))
          ((key-eq typeof '|@SYMBOL|)
	       (unless (gethash value globals nil) (warning! "lcc\: [warning] undefined variable ~A~%" value))
           (let ((ast (current-ast<)))
             (if (null ast)
	             (set-ast-line (output "~A " value))
                 (let ((info (getf ast 'info)))
                   (if info
                       (if (str:containsp "take the address with &" info)
                           (set-ast-line (output "\&~A" value))
                           (if (str:containsp "__lccLambda" info)
                               (set-ast-line (output "\&~A" value))
                               (error (format nil "~A" info))))
                       (set-ast-line (output "~A " value)))))))
          (t (set-ast-line (output "~A" value))))))

(defun compile-code (spec globals)
  (with-slots ((content default)) spec
    (set-ast-line (output "~A" content))))

(defun compile-list (spec globals)
  (with-slots ((items default)) spec
    (set-ast-line (output "{"))
    (let ((l (length items))
          (m-init nil))
      (loop for i from 1 to l
            for item in (default spec)
            do (progn
                 (if (and (key-eq '|@ATOM| (construct item)) (key-eq '|@SYMBOL| (typeof item))
                          (equal (str:s-first (symbol-name (name item))) "$"))
                     (progn
                       (setq m-init t)
                       (set-ast-line (output "~A " (str:replace-all "$" "." (symbol-name (name item))))))
                     (progn
                       (when m-init (set-ast-line (output "= ")))
                       (compile-form item globals)
                       (setq m-init nil)))
                 (when (and (not m-init) (< i l)) (output ", ")))))
    (set-ast-line (output "}"))))

(defun compile-unary (spec globals)
  (with-slots ((oprt name) (is-postfix modifier) (oprnd default)) spec
    (output "(")
    (if is-postfix
        (progn
          (compile-form oprnd globals)
	      (set-ast-line (output "~A"  oprt)))
        (progn
          (set-ast-line (output "~A" oprt))
          (compile-form oprnd globals)))
    (output ")")))

(defun compile-operator (spec globals)
  (with-slots ((opr name) (seq default)) spec
    (output "(")
    (dolist (frm seq)
      (compile-form frm globals)
      (output " "))
    (output ")")))

(defun compile-assignment (spec lvl globals)
  (with-slots ((opr name) (seq default)) spec
    (output "~&~A" (indent lvl))
    (dolist (frm seq)
      (compile-form frm globals)
      (output " "))
    (output ";~%")))

(defun compile-nth (spec globals)
  (with-slots ((index name) (array default)) spec
    (compile-form array globals)
    (output "[")
    (compile-form index globals)
    (output "]")))

(defun compile-? (spec globals)
  (with-slots ((condition name) (exprs default)) spec
    (output "((")
    (compile-form condition globals)
    (output ") ? ")
    (compile-form (nth 0 exprs) globals)
    (output " \: ")
    (compile-form (nth 1 exprs) globals)
    (output ")")))

(defun compile-cast (spec globals)
  (with-slots (typeof (value default)) spec
    (output "((")
    (compile-spec-type spec globals)
    (output ")")
    (compile-form value globals)
    (output ")")))

(defun compile-$ (spec globals)
  (with-slots ((receiver name) (member default)) spec
    (output "(")
    (compile-form receiver globals)
    (let* ((ast  (current-ast<))
           (info (getf ast 'info)))
      (if (null ast)
          (progn
            (set-resolved ". ")
            (set-ast-line (output ". ")))
          (if (null info)
              (set-ast-line (output (current-resolved<)))
              (if (and (str:containsp "member reference type" info) (str:containsp "is a pointer" info))
                  (progn
                    (set-resolved "->")
                    (set-ast-line (output "->")))
                  (error (format nil "lcc\: unresolved member reference type ~A~%" spec))))))
    (compile-form member globals)
    (output ")")))

(defun compile--> (spec globals)
  (with-slots ((receiver name) (method default) (args body)) spec
    (let* ((obj-ast (current-ast< 0 1))
           (opr-ast (current-ast< 0 (1+ (length (getf obj-ast 'res)))))
           (ast     (current-ast< 0 (1+ (+ (length (getf obj-ast 'res)) (length (getf opr-ast 'res))))))
           (info    (getf ast 'info)))
      (if (null ast)
          (let ((col-n (funcall *col-num* 0))
                (res   (current-resolved<)))
            (if (null res)
                (progn ;; access member by pointer
                  (output "(")
                  (compile-form receiver globals)
                  (set-ast-line (output "->"))
                  (compile-form method globals)
                  (output ")"))
                (progn
                  (set-ast-line (output res))
                  (output "(")
                  (compile-form receiver globals)
                  (compile-args (default args) globals t)
                  (output ")")
                  (funcall *col-num* 0 :reset (+ col-n (length res))))))
          (if (str:containsp "no member named" info)
              (let* ((col-n       (funcall *col-num* 0))
                     (matches     (ppcre:all-matches-as-strings "'(struct\\s+)?\\w+'" info))
                     (method      (car matches))
                     (parts       (str:split #\Space (cadr matches))))
                (if (string= (car parts) "'struct")
                    (progn
                      (set-resolved (format nil "~A_~A" (string-right-trim "'" (cadr parts)) (string-trim "'" method)))
                      (set-ast-line (output "~A_" (string-right-trim "'" (cadr parts)))))
                    (error (format nil "lcc\: unresolved method reference type ~A~%" spec)))
                (set-ast-line (output "~A " (string-trim "'" method)))
                (output "(")
                (compile-form receiver globals)
                (compile-args (default args) globals t)
                (output ")")
                (funcall *col-num* 0 :reset (+ col-n (length (getf ast 'res)))))
              (error (format nil "lcc\: unresolved method reference type ~A~%" spec)))))))

(defun compile-sizeof (spec globals)
  (set-ast-line (output "sizeof("))
  (compile-spec-type spec globals)
  (output ")"))

(defun compile-args (args globals comma-first)
  (loop for arg in args
        with l = (1- (length args))
        for i from 0 to l
        do (progn
             (when comma-first (output ", "))
             (compile-form arg globals)
             (when (< i l) (output ", ")))))

(defun compile-call (spec lvl globals)
  (with-slots ((func name) (args default)) spec
    (when (> lvl -1) (output "~&~A" (indent lvl)))
    (compile-form func globals)
    (output "(")
    (unless (null args) (compile-args args globals nil))
    (output ")")
    (when (> lvl -1) (output ";~%"))))

(defun compile-form (spec globals)
  (with-slots (construct) spec
    (case construct
      ('|@NIL|    t)
      ('|@ATOM|   (compile-atom       spec globals))
      ('|@CODE|   (compile-code       spec globals))
      ('|@LIST|   (compile-list       spec globals))
      ('|@UNARY|  (compile-unary      spec globals))
      ('|@OPR|    (compile-operator   spec globals))
      ('|@NTH|    (compile-nth        spec globals))
      ('|@?|      (compile-?          spec globals))
      ('|@CAST|   (compile-cast       spec globals))
      ('|@$|      (compile-$          spec globals))      
      ('|@->|     (compile-->         spec globals))
      ('|@SIZEOF| (compile-sizeof     spec globals))
      ('|@CALL|   (compile-call       spec -1 globals))
      (t (error (format nil "syntax error ~A" spec))))))

(defun compile-variable (spec lvl globals)
  (let ((is-auto     nil)
	    (is-register nil)
	    (is-static   nil)
	    (is-extern   nil)
        (is-alloc    nil)
        (has-defer   nil))
    (dolist (attr (attrs spec))
      (case (car attr)
	    ('|auto|     (setq is-auto     t))
	    ('|register| (setq is-register t))
	    ('|static|   (setq is-static   t))
	    ('|extern|   (setq is-extern   t))
        ('|alloc|    (setq is-alloc    t))
        ('|defer|    (setq has-defer   (cdr attr)))))
    (output "~&~A" (indent lvl))
    (when is-extern   (set-ast-line (output "extern ")))
    (when is-static   (set-ast-line (output "static ")))
    (when is-register (set-ast-line (output "register ")))
    (when is-auto     (set-ast-line (output "auto ")))
    (compile-spec-type-value spec globals has-defer)
    (output ";~%")))

(defun compile-body (spec lvl globals)
  (loop for form in (body spec)
        do (progn
             (case (construct form)
               ('|@ASSIGN| (compile-assignment form (1+ lvl) globals))
               ('|@CALL|   (compile-call       form (1+ lvl) globals))
               ('|@LET|    (compile-let        form (1+ lvl) globals))
               ('|@BLOCK|  (compile-block      form (1+ lvl) globals))
               ('|@SET|    (compile-set        form (1+ lvl) globals))
               ('|@RETURN| (compile-return     form (1+ lvl) globals))
               (t (output "~&~A" (indent (1+ lvl)))
                  (compile-form form globals)
                  (output ";~%")))))
  (return-from compile-body)
  (dolist (form (default spec))
    (cond (t (let ((func (car form))
		           (locals (copy-specifiers globals)))
	           (cond ((listp func) (error (format nil "function name or operator is missing ~A" form)))
		             ((and (= (length form) 2) (find func *unaries* :test #'key-eq))
                      (output "~&~A" (indent lvl))
                      (compile-unary form locals)
                      (output ";"))
		             ((and (= (length form) 3) (find func *assignments* :test #'key-eq))
                      (output "~&~A" (indent lvl))
                      (compile-assignment form locals)
		              (output ";"))
		             ((key-eq func '|break|)    (set-ast-line (output "~&~Abreak;"    (indent lvl))))
		             ((key-eq func '|continue|) (set-ast-line (output "~&~Acontinue;" (indent lvl))))
		             ((key-eq func '|return|)   (compile-return   form lvl locals))
		             ((key-eq func '|set|)      (compile-set      form lvl locals))
		             ((key-eq func '|let|)      (compile-let      form lvl locals)) 
		             ((key-eq func '|block|)    (compile-block    form lvl locals)) 
		             ((key-eq func '|if|)       (compile-if       form lvl locals)) 
		             ((key-eq func '|switch|)   (compile-switch   form lvl locals)) 
		             ((key-eq func '|while|)    (compile-while    form lvl locals)) 
		             ((key-eq func '|do|)       (compile-do       form lvl locals)) 
		             ((key-eq func '|for|)      (compile-for      form lvl locals)) 
		             ((key-eq func '|for-each|) (compile-for-each form lvl locals)) 
		             (t
                      (output "~&~A" (indent lvl))
                      (compile-form form locals)
                      (output ";~%"))))))))

(defun compile-let (spec lvl globals)
  (let ((dynamics    '())
	    (locals      (copy-specifiers globals)))
    (output "~&~A" (indent lvl))
    (output "{ /* ~A */~%" (name spec))
    (loop for var being the hash-value of (params spec)
          do (progn
               (compile-variable var (1+ lvl) locals)
               (when (find '|alloc| (attrs var) :test #'key-eq) (push (name var) dynamics))))
    ;; (dolist (variable (reverse dynamics))
    ;;   (output "~&~A" (indent (+ lvl 1)))
    ;;   (set-ast-line (output "if ("))
    ;;   (set-ast-line (output "~A " variable))
    ;;   (set-ast-line (output "== NULL) printf(\"dynamic memory allocation failed! ~A\\n\");~%" variable)))
    (compile-body (body spec) lvl locals)
    ;; (dolist (variable dynamics)
    ;;   (output "~&~A" (indent (+ lvl 1)))
    ;;   (set-ast-line (output "free("))
    ;;   (set-ast-line (output "~A" variable))
    ;;   (set-ast-line (output ");~%")))
    (output "~&~A" (indent lvl))
    (output "} /* ~A */~%" (name spec))))

(defun compile-block (spec lvl globals)
  (let ((locals      (copy-specifiers globals)))
    (output "~&~A" (indent lvl))
    (output "{ /* ~A */~%" (name spec))
    (compile-body (body spec) lvl locals)
    (output "~&~A" (indent lvl))
    (output "} /* ~A */~%" (name spec))))

(defun compile-set (spec lvl globals)
  (with-slots ((items default)) spec
    (dolist (item items)
      (output "~&~A" (indent lvl))
      (compile-form (nth 0 item) globals)
      (output " ")
      (set-ast-line (output "= "))
      (compile-form (nth 1 item) globals)
      (output ";~%"))))

(defun compile-return (spec lvl globals)
  (output "~&~A" (indent lvl))
  (set-ast-line (output "return "))
  (compile-form (default spec) globals)
  (output ";~%"))

(defun compile-if (form lvl globals)
  (when (or (< (length form) 3) (> (length form) 4)) (error (format nil "wrong if form ~A" form)))
  (output "~&~A" (indent lvl))
  (set-ast-line (output "if ("))
  (compile-form (nth 1 form) globals)
  (set-ast-line (output ") {~%"))
  (compile-body (list (nth 2 form)) (+ lvl 1) globals)
  (if (= (length form) 3)
      (progn
        (output "~&~A" (indent lvl))
        (set-ast-line (output "}~%")))
      (progn
        (output "~&~A" (indent lvl))
        (set-ast-line (output "} else {~%"))
        (compile-body (list (nth 3 form)) (+ lvl 1) globals)
        (output "~&~A}~%" (indent lvl)))))

(defun compile-switch (form lvl globals)
  (when (< (length form) 2) (error (format nil "wrong switch form ~A" form)))
  (output "~&~A" (indent lvl))
  (set-ast-line (output "switch ("))
  (compile-form (nth 1 form) globals)
  (set-ast-line (output ") {~%"))
  (dolist (ch-form (nthcdr 2 form))
    (cond ((key-eq (car ch-form) '|case|)
           (output "~&~A" (indent lvl))
           (set-ast-line (output "case "))
           (compile-form (cadr ch-form) globals)
           (output ":~%")
           (compile-body (nthcdr 2 ch-form) (+ lvl 2) globals))
	      ((key-eq (car ch-form) '|default|)
           (output "~&~A" (indent lvl))
           (set-ast-line (output "default:~%" (indent (+ lvl 1))))
	       (compile-body (nthcdr 1 ch-form) (+ lvl 2) globals))
	      (t (error (format nil "only case or default form ~A" form)))))
  (output "~&~A}~%" (indent lvl)))

(defun compile-while (form lvl globals)
  (when (< (length form) 2) (error (format nil "wrong while form ~A" form)))
  (output "~&~A" (indent lvl))
  (set-ast-line (output "while ("))
  (compile-form (nth 1 form) globals)
  (set-ast-line (output ") {~%"))
  (compile-body (nthcdr 2 form) (+ lvl 1) globals)
  (output "~&~A}~%" (indent lvl)))

(defun compile-do (form lvl globals)
  (when (< (length form) 2) (error (format nil "wrong do form ~A" form)))
  (output "~&~A" (indent lvl))
  (set-ast-line (output "do {~%"))
  (compile-body (nthcdr 2 form) (+ lvl 1) globals)
  (output "~&~A" (indent lvl))
  (set-ast-line (output "} while ("))
  (compile-form (nth 1 form) globals)
  (set-ast-line (output ");~%")))

(defun compile-for (form lvl globals)
  (when (or (< (length form) 3) (not (listp (nth 1 form)))) (error (format nil "wrong for form ~A" form)))
  (output "~&~A" (indent lvl))
  (set-ast-line (output "for ("))
  (dolist (type (nth 1 form))
    (unless (and (not (null type)) (listp type)) (error (format nil "wrong variable definition form ~A" form)))
    (compile-type-value type globals)
    (output ", "))
  (compile-form (nth 2 form) globals)
  (output "; ")
  (set-ast-line (output ";) {~%"))
  (compile-body (nthcdr 3 form) (+ lvl 1) globals)
  (output "~&~A}~%" (indent lvl)))

(defun compile-for-each (form lvl globals)
  (when (or (< (length form) 4) (not (listp (nth 1 form)))) (error (format nil "wrong for each form ~A" form)))
  (let ((counter (gensym)))
    (output "~&~A" (indent lvl))
    (set-ast-line (output "for (int ~A = 0; ~A < " counter counter))
    (compile-form (nth 3 form) globals)
    (set-ast-line (output "; ~A++) {~%" counter))
    (output "~&~A" (indent (+ lvl 1)))
    (compile-type (nth 1 form) globals)
    (set-ast-line (output " = "))
    (set-ast-line (output "~A" (nth 2 form)))
    (set-ast-line (output "[~A];~%"   counter)))
  (compile-body (nthcdr 4 form) (+ lvl 1) globals)
  (output "~&~A}~%" (indent lvl)))

(defun compile-function (spec lvl globals &optional (asType nil))
  (loop for lambda being the hash-value of (inners spec)
        do (compile-function lambda lvl globals))

  (let* ((is-static  nil)
	     (is-declare nil)
	     (is-inline  nil)
	     (is-extern  nil)
         (is-method  (if (key-eq (construct spec) '|@METHOD|) t nil))
	     (name       (name   spec))
	     (params     (params spec))
	     (body       (body   spec))
	     (locals     (copy-specifiers globals)))
    (let ((cparams '()))
      (maphash #'(lambda (in-name in-spec)
		           (case (construct in-spec)
		             ('|@PARAM| (setf (gethash in-name locals) in-spec)
                                    (push in-spec cparams))
		             (otherwise nil)))
	           params)
      (dolist (attr (attrs spec))
        (case attr
	      ('|static|  (setq is-static  t))
	      ('|decl|    (setq is-declare t))
	      ('|inline|  (setq is-inline  t))
	      ('|extern|  (setq is-extern  t))))
      (output "~&~A" (indent lvl))
      (when is-extern (set-ast-line (output "extern ")))
      (when is-inline (set-ast-line (output "__attribute__((weak)) ")))
      (when is-static (set-ast-line (output "static ")))
      (format-type (const spec) (typeof spec) (modifier spec) nil (const-ptr spec) (array-def spec) nil locals)
      (output " ")
      (set-ast-line (output "~A " (if is-method
                                      (format nil "~A_~A" (car name) (cdr name))
                                      (if asType (format nil "(*~A)" name) name))))
      (output "(")
      (when is-method
        (setf (gethash '|this| locals)
			  (make-specifier '|this| '|@PARAM| nil (car name) '|*| nil nil nil '()))
        ;; (set-ast-line (output "~A " (car name)))
        (set-ast-line (output "~A" (car name)))
        (output " ")
        (set-ast-line (output "* "))
        (set-ast-line (output "this"))
        (when (> (length cparams) 0) (set-ast-line (output ", "))))
      (loop for param being the hash-value of params
            with lc = (1- (hash-table-count params))
            for i from 0 to lc
            do (progn
                 (compile-spec-type-value param locals)
                 (when (< i lc) (output ", "))))
      (output ")")
      (if is-declare
          (unless asType (output ";~%"))
          (progn
            (output " ")
            (output "{~%")))
      (unless is-declare
        (progn
	      (compile-body body lvl locals)
	      (output "~&~A" (indent lvl))
          (output "}~%"))))))

(defun compile-preprocessor (spec lvl globals)
  (with-slots ((directive name) body) spec
    (setq directive (symbol-name (name directive))) 
    (setf (char directive 0) #\#)
    (set-ast-line (output "~&~A " directive))
    (when body (compile-form body globals))
    (output "~%")))

(defun compile-include (spec lvl globals)
  (with-slots ((headers params)) spec
    (dolist (header headers)
      (cond ((symbolp header)
             (set-ast-line (output "~&#include "))
             (set-ast-line (output "~A~%" header)))
	        ((stringp header)
             (set-ast-line (output "~&#include "))
             (set-ast-line (output "~S~%" header)))
	        (t (error "wrong inclusion"))))))

(defun compile-typedef (spec lvl globals)
  (set-ast-line (output "~&typedef "))
  (compile-spec-type spec globals)
  (output ";~%"))

(defun compile-enum (spec lvl globals)
  (let ((name         (name spec))
	    (is-anonymous (anonymous spec))
	    (counter      1)
	    (count        (hash-table-count (inners spec)))
	    (locals       (copy-specifiers globals)))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@VAR| (setf (gethash in-name locals) in-spec))
		           (otherwise nil)))
	         (inners spec))
    (output "~&~A" (indent lvl))
    (if is-anonymous
        (set-ast-line (output "enum "))
        (progn
          (set-ast-line (output "typedef "))
          (set-ast-line (output "enum "))
          (set-ast-line (output "~A " name))))
    (if is-anonymous
        (output "{ /* ~A */~%" name)
        (output "{~%"))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@VAR|
                    (output "~&~A" (indent (+ 1 lvl)))
		            (set-ast-line (output "~A" (name in-name)))
                    (unless (null (default in-spec))
                      (set-ast-line (output " = "))
                      (compile-form (default in-spec) locals))
                    (when (< counter count) (output ","))
                    (output "~%"))
		           (otherwise (error (format nil "unknown clause ~A inside ~A" in-name in-spec))))
		         (incf counter))
	         (inners spec))
    (output "~&}")
    (unless is-anonymous
      (output " ")
      (set-ast-line (output "~A" name)))
    (output ";~%")))

(defun compile-struct (spec lvl globals)
  (let ((name         (name spec))
	    (is-anonymous (anonymous spec))
	    (declares     (params spec))
	    (locals       (copy-specifiers globals)))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@VAR|  (setf (gethash in-name locals) in-spec))
		           ('|@FUNC| (setf (gethash in-name locals) in-spec))
		           ('|@ENUM|
		            (unless (anonymous spec) (setf (gethash in-name locals) in-spec))
		            (maphash #'(lambda (k v) (setf (gethash k locals) v)) (inners in-spec)))
		           ('|@STRUCT|
		            (setf (gethash in-name locals) in-spec)
		            (maphash #'(lambda (k v) (setf (gethash k locals) v)) (params in-spec)))
		           ('|@UNION|
		            (setf (gethash in-name locals) in-spec)
		            (maphash #'(lambda (k v) (setf (gethash k locals) v)) (params in-spec)))
		           (otherwise (error (format nil "unknown clause ~A inside ~A" in-name in-spec)))))
	         (inners spec))
    (output "~&~A" (indent lvl))
    (if is-anonymous
        (set-ast-line (output "struct "))
        (progn
          (set-ast-line (output "typedef "))
          (set-ast-line (output "struct "))
          (set-ast-line (output "~A " name))))
    (if is-anonymous
        (output "{ /* ~A */~%" name)
        (output "{~%"))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@PREPROC|  (compile-preprocessor in-spec (+ 1 lvl) locals))
		           ('|@VAR|      (compile-variable     in-spec (+ 1 lvl) locals))
		           ('|@FUNC|     (compile-function     in-spec (+ 1 lvl) locals))
		           ('|@ENUM|     (compile-enum         in-spec (+ 1 lvl) locals))
		           ('|@STRUCT|   (compile-struct       in-spec (+ 1 lvl) locals))
		           ('|@UNION|    (compile-union        in-spec (+ 1 lvl) locals))
		           (otherwise nil)))
	         (inners spec))
    (output "~&~A" (indent lvl))
    (output "}")
    (if is-anonymous
        (when (> (hash-table-count declares) 0)
          (loop for dec being the hash-values of declares
                with l = (1- (hash-table-count declares))
                for i from 0 to l
                do (progn
                     (compile-spec-type dec globals)
                     (when (< i l) (output ",")))))
        (progn
          (output " ")
          (set-ast-line (output "~A" name))))
    (output ";~%")))

(defun compile-union (spec lvl globals)
  (let ((name         (name spec))
	    (is-anonymous (anonymous spec))
	    (declares     (params spec))
	    (locals       (copy-specifiers globals)))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@VAR| (setf (gethash in-name locals) in-spec))
		           ('|@STRUCT|
		            (setf (gethash in-name locals) in-spec)
		            (maphash #'(lambda (k v) (setf (gethash k locals) v)) (params in-spec)))
		           ('|@UNION|
		            (setf (gethash in-name locals) in-spec)
		            (maphash #'(lambda (k v) (setf (gethash k locals) v)) (params in-spec)))
		           (otherwise (error (format nil "unknown clause ~A inside ~A" in-name in-spec)))))
	         (inners spec))
    (output "~&~A" (indent lvl))
    (if is-anonymous
        (set-ast-line (output "union "))
        (progn
          (set-ast-line (output "typedef "))
          (set-ast-line (output "union "))
          (set-ast-line (output "~A " name))))
    (if is-anonymous
        (output "{ /* ~A */~%" name)
        (output "{~%"))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@PREPROC|  (compile-preprocessor in-spec (+ 1 lvl) locals))
		           ('|@VAR|      (compile-variable     in-spec (+ 1 lvl) locals))
		           ('|@STRUCT|   (compile-struct       in-spec (+ 1 lvl) locals))
		           ('|@UNION|    (compile-union        in-spec (+ 1 lvl) locals))
		           (otherwise nil)))
	         (inners spec))
    (output "~&~A" (indent lvl))
    (output "}")
    (if is-anonymous
        (when (> (hash-table-count declares) 0)
          (loop for dec being the hash-values of declares
                with l = (1- (hash-table-count declares))
                for i from 0 to l
                do (progn
                     (compile-spec-type dec globals)
                     (when (< i l) (output ",")))))
        (progn
          (output " ")
          (set-ast-line (output "~A" name))))
    (output ";~%")))

(defun compile-guard (spec lvl globals)
  (let ((name (name spec)))
    (set-ast-line (output "~&#ifndef ~A~%" name))
    (set-ast-line (output "~&#define ~A~%" name))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@PREPROC|  (compile-preprocessor in-spec lvl globals))
		           ('|@INCLUDE|  (compile-include      in-spec lvl globals))
		           ('|@TYPEDEF|  (compile-typedef      in-spec lvl globals))
		           ('|@VAR|      (compile-variable     in-spec lvl globals))
		           ('|@FUNC|     (compile-function     in-spec lvl globals))
		           ('|@METHOD|   (compile-function     in-spec lvl globals))
		           ('|@ENUM|     (compile-enum         in-spec lvl globals))
		           ('|@STRUCT|   (compile-struct       in-spec lvl globals))
		           ('|@UNION|    (compile-union        in-spec lvl globals))
		           ('|@GUARD|    (compile-guard        in-spec lvl globals))
		           (otherwise nil)))
	         (inners spec))    
    (set-ast-line (output "~&#endif /* ~A */ ~%" name))))
