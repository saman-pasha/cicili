(in-package :lcc)

(defun compile-name (name)
  (if (is-name name) (set-ast-line (output (symbol-name name)))
      (error (format nil "wrong name ~S" name))))

(defun compile-type-name (name)
  (cond ((key-eq name '|uchar|)  (set-ast-line (output "unsigned char")))
	    ((key-eq name '|ushort|) (set-ast-line (output "unsigned short")))
	    ((key-eq name '|uint|)   (set-ast-line (output "unsigned int")))
	    ((key-eq name '|ulong|)  (set-ast-line (output "unsigned long")))
	    ((key-eq name '|llong|)  (set-ast-line (output "long long")))
	    ((key-eq name '|ullong|) (set-ast-line (output "unsigned long long")))
	    ((key-eq name '|i8|)     (set-ast-line (output "int8_t")))
	    ((key-eq name '|u8|)     (set-ast-line (output "uint8_t")))
	    ((key-eq name '|i16|)    (set-ast-line (output "int16_t")))
	    ((key-eq name '|u16|)    (set-ast-line (output "uint16_t")))
	    ((key-eq name '|i32|)    (set-ast-line (output "int32_t")))
	    ((key-eq name '|u32|)    (set-ast-line (output "uint32_t")))
	    ((key-eq name '|i64|)    (set-ast-line (output "int64_t")))
	    ((key-eq name '|u64|)    (set-ast-line (output "uint64_t")))
	    ((key-eq name '|i128|)   (set-ast-line (output "__int128")))
	    ((key-eq name '|u128|)   (set-ast-line (output "unsigned __int128")))
	    ((key-eq name '|real|)   (set-ast-line (output "long double")))
	    (t (compile-name name))))

(defun compile-array (desc globals)
  (cond ((null desc) t)
	    ((not (is-array desc)) (error (format nil "wrong array description ~A" desc)))
	    ((null (nth 1 desc)) (set-ast-line (output "[]")))
	    (t (set-ast-line (output "[~A]" (compile-form< (nth 1 desc) globals))))))

(defun format-type (const typeof modifier const-ptr name array-def globals &optional anonymous)
  (when anonymous (setq name (format nil "/* ~A */" name)))
  (if (key-eq typeof '|function|)
      (compile-function array-def 0 '() t)
      (progn
        (when const     (set-ast-line (output "const ")))
        (compile-type-name typeof)
        (when modifier  (output " ") (set-ast-line (output "~A" modifier)))
        (when const-ptr (output " ") (set-ast-line (output "const" const-ptr)))
        (when name      (output " ") (set-ast-line (output "~A" name)))
        (compile-array array-def globals))))

(defun compile-type (desc globals &optional no-text)
  (multiple-value-bind (const typeof modifier const-ptr name array-def)
      (specify-type< desc globals)
    (values (if no-text nil (format-type const typeof modifier const-ptr name array-def globals))
	        const typeof modifier const-ptr name array-def)))

(defun compile-spec-type (spec globals &optional no-text)
  (let ((const     (const     spec))
	    (typeof    (typeof    spec))
	    (modifier  (modifier  spec))
	    (const-ptr (const-ptr spec))
	    (name      (name      spec))
	    (array-def (array-def spec))
	    (anonymous (anonymous spec)))
    (values (if no-text nil (format-type const typeof modifier const-ptr name array-def globals anonymous))
	        const typeof modifier const-ptr name array-def)))

(defun format-type-value (const typeof modifier const-ptr name array-def default globals &optional anonymous)
  (when anonymous (setq name (format nil "/* ~A */" name)))
  (format-type const typeof modifier const-ptr name array-def globals)
  (unless (null default)
    (output " ")
    (set-ast-line (output "= "))
    (compile-form default globals)))

(defun compile-type-value (desc globals &optional no-text)
  (multiple-value-bind (const typeof modifier const-ptr name array-def default)
      (specify-type-value< desc globals)
    (values (if no-text nil (format-type-value const typeof modifier const-ptr name array-def default globals))
	        const typeof modifier const-ptr name array-def default)))

(defun compile-spec-type-value (spec globals &optional no-text)
  (let ((const     (const     spec))
	    (typeof    (typeof    spec))
	    (modifier  (modifier  spec))
	    (const-ptr (const-ptr spec))
	    (name      (name      spec))
	    (array-def (array-def spec))
	    (default   (default   spec))
	    (anonymous (anonymous spec)))
    (values (if no-text nil (format-type-value const typeof modifier const-ptr name array-def default globals anonymous))
	        const typeof modifier const-ptr name array-def default)))

(defun compile-atom (obj globals)
  (cond ((null obj) nil)
	    ((key-eq '|nil| obj) (set-ast-line (output "NULL")))
	    ((numberp obj) (set-ast-line (output "~A" obj)))
	    ((characterp obj) (if (eql obj #\Null) (set-ast-line (output "'\\0'")) (set-ast-line (output "'~C'" obj))))
	    ((stringp obj) (set-ast-line (output "\"~A\"" obj)))
	    ((and (symbolp obj) (is-symbol obj))
	     (if (eql (char (symbol-name obj) 0) #\0)
	         (set-ast-line (output "~A " obj))
             (progn
               (if (string= (symbol-name obj) "this")
                   (set-ast-line (output "~A " '|this|))
                   (progn
	                 (unless (gethash obj globals nil) (warning! "lcc\: [warning] undefined variable ~A~%" obj))
                     (let ((ast (current-ast<)))
                       (if (null ast)
	                       (set-ast-line (output "~A " obj))
                           (let ((info (getf ast 'info)))
                             (if info
                                 (if (str:containsp "take the address with &" info)
                                     (set-ast-line (output "\&~A" obj))
                                     (if (str:containsp "__lccLambda" info)
                                         (set-ast-line (output "\&~A" obj))
                                         (error (format nil "~A" info))))
                                 (set-ast-line (output "~A " obj)))))))))))
        ((symbolp obj) (set-ast-line (output "~A " obj))) ; operators
	    (t (error (format nil "syntax error \"~A\"" obj)))))

(defun compile-unary (form globals)
  (unless (= (length form) 2) (error (format nil "wrong unary form ~A" form)))
  (let* ((oprt (car form))
	     (name (symbol-name oprt))
	     (is-postfix nil))
    (when (eql (char name (- (length name) 1)) #\#)
      (setq oprt (subseq name 0 (- (length name) 1)))
      (setq is-postfix t))
    (cond ((key-eq oprt '|not|)       (setq oprt '|!|))
	      ((key-eq oprt '|contentof|) (setq oprt '|*|))
	      ((key-eq oprt '|addressof|) (setq oprt '|&|)))
    (output "(")
    (if is-postfix
        (progn
          (compile-form (cadr form) globals)
	      (set-ast-line (output "~A"  oprt)))
        (progn
          (set-ast-line (output "~A" oprt))
          (compile-form (cadr form) globals)))
    (output ")")))

(defun compile-operator (form globals)
  (let ((opr (car form))
	    (oprnds '()))
    (cond ((key-eq opr '|and|)    (setq opr '|&&|))
	      ((key-eq opr '|or|)     (setq opr '|\|\||))
	      ((key-eq opr '|bitand|) (setq opr '|&|))
	      ((key-eq opr '|bitor|)  (setq opr '|\||))
	      ((key-eq opr '|xor|)    (setq opr '|^|)))
    (dolist (oprnd (cdr form))
      (push opr oprnds)
      (push oprnd oprnds))
    (output "(")
    (dolist (frm (cdr (nreverse oprnds)))
      (compile-form frm globals))
    (output ")")))

(defun compile-assignment (form globals)
  (let ((opr (car form))
	    (oprnds '()))
    (dolist (oprnd (cdr form))
      (push opr oprnds)
      (push oprnd oprnds))
    (dolist (frm (cdr (nreverse oprnds)))
      (compile-form frm globals))))

(defun compile-nth-form (form globals)
  (unless (= (length form) 3) (error (format nil "wrong nth form ~A" form)))
  (compile-form (nth 2 form) globals)
  (output "[")
  (compile-form (nth 1 form) globals)
  (output "]"))

(defun compile-?-form (form globals)
  (unless (= (length form) 4) (error (format nil "wrong ? form ~A" form)))
  (output "((")
  (compile-form (nth 1 form) globals)
  (output ") ? ")
  (compile-form (nth 2 form) globals)
  (output " \: ")
  (compile-form (nth 3 form) globals)
  (output ")"))

(defun compile-cast-form (form globals)
  (unless (= (length form) 3) (error (format nil "wrong cast form ~A" form)))
  (output "((")
  (compile-type (nth 1 form) globals)
  (output ")")
  (compile-form (nth 2 form) globals)
  (output ")"))

(defun compile-form (form globals)
  (handler-case
      (if (atom form) (compile-atom form globals)
	      (let ((func (car form)))
	        (cond ((listp func) (error (format nil "function name or operator is missing ~A" form)))
		          ((key-eq func '|code|) (output " ") (set-ast-line (output "~A" (cadr form))))
		          ((key-eq func 'QUOTE)
                   (let ((quoted (cadr form)))
                     (if (key-eq (car quoted) '|lambda|)
                         (progn ; lambda
                           (compile-function     (cadr quoted) 0 globals))
                         (progn ; list
                           (output "{")
                           (let* ((li (cadr form))
                                  (l (1- (length li))))
                             (loop
                                   for f in li
                                   for i from 0 to l
                                   do (progn
                                        (compile-form f globals)
                                        (when (< i l) (output ", ")))))
                           (output "}")))))
		          ((and (> (length form) 2) (key-eq func '\|) (key-eq (cadr form) '\|))
		           (compile-operator (push '\|\| (cddr form)) globals))
		          ((and (> (length form) 2) (key-eq func '\|)) (compile-operator form globals))
		          ((and (= (length form) 2) (find func *unaries* :test #'key-eq))   (compile-unary form globals))
		          ((and (> (length form) 2) (find func *operators* :test #'key-eq)) (compile-operator form globals))
		          ((key-eq func '|nth|)    (compile-nth-form form globals)) 
		          ((key-eq func '|?|)      (compile-?-form form globals)) 
		          ((key-eq func '|cast|)   (compile-cast-form form globals))
                  ((key-eq func '|$|) ; member access operator
                   (output "(")
                   (compile-form (cadr form) globals)
                   (let* ((ast  (current-ast<))
                          (info (getf ast 'info)))
                     (if (null ast)
                         (progn
                           (set-resolved ". ")
                           (set-ast-line (output ". ")))
                         (if (null info)
                             (set-ast-line (output (current-resolved<)))
                             (if (and (str:containsp "member reference type" info) (str:containsp "is a pointer" info))
                                 (progn
                                   (set-resolved "->")
                                   (set-ast-line (output "->")))
                                 (error (format nil "lcc\: unresolved member reference type ~A~%" form))))))
                   (let* ((li (cddr form))
                          (l (1- (length li))))
                     (loop
                           for f in li
                           for i from 0 to l
                           do (progn
                                (compile-form f globals)
                                (when (< i l) (output ", ")))))
                   (output ")"))
                  ((key-eq func '|->|) ; method access operator
                   (let* ((obj-ast (current-ast< 0 1))
                          (opr-ast (current-ast< 0 (1+ (length (getf obj-ast 'res)))))
                          (ast     (current-ast< 0 (1+ (+ (length (getf obj-ast 'res)) (length (getf opr-ast 'res))))))
                          (info    (getf ast 'info)))
                     (display "HHHHHH"  *ast-run* (getf obj-ast 'res) info #\NewLine)
                     (if (null ast)
                         (let ((col-n       (funcall *col-num* 0))
                               (res (current-resolved<)))
                           (display "ORES" res)
                           (if (null res)
                               (progn
                                 (output "(")
                                 (compile-form (cadr form) globals)
                                 (set-ast-line (output "->"))
                                 ;; (compile-form (caddr form) globals)
                                 ;; we know it is atom symbol
                                 (set-ast-line (output "~A " (caddr form)))
                                 (output ")"))
                               (progn
                                 (set-ast-line (output res))
                                 (output "(")
                                 (compile-form (cadr form) globals)
                                 (let* ((li (cdddr form))
                                        (l (1- (length li))))
                                   (when (> (length li) 0) (output ", "))
                                   (loop
                                         for f in li
                                         for i from 0 to l
                                         do (progn
                                              (compile-form f globals)
                                              (when (< i l) (output ", ")))))
                                 (output ")")
                                 (funcall *col-num* 0 :reset (+ col-n (length res))))))
                         (if (str:containsp "no member named" info)
                             (let* ((col-n       (funcall *col-num* 0))
                                    (matches     (ppcre:all-matches-as-strings "'(struct\\s+)?\\w+'" info))
                                    (method      (car matches))
                                    (parts       (str:split #\Space (cadr matches))))
                               (display "gGGGGG" matches method parts)
                               (if (string= (car parts) "'struct")
                                   (progn
                                     (set-resolved (format nil "~A_~A" (string-right-trim "'" (cadr parts)) (string-trim "'" method)))
                                     (display "ERES" (current-resolved< 0 1))
                                     (set-ast-line (output "~A_" (string-right-trim "'" (cadr parts)))))
                                   (error (format nil "lcc\: unresolved method reference type ~A~%" form)))
                               ;; (compile-form (caddr form) globals)
                               ;; we know it is atom symbol
                               (set-ast-line (output "~A " (string-trim "'" method)))
                               (output "(")
                               (compile-form (cadr form) globals)
                               (let* ((li (cdddr form))
                                      (l (1- (length li))))
                                 (when (> (length li) 0) (output ", "))
                                 (loop
                                       for f in li
                                       for i from 0 to l
                                       do (progn
                                            (compile-form f globals)
                                            (when (< i l) (output ", ")))))
                               (output ")")
                               (display "FFFFFF" col-n (length (getf ast 'res)))
                               (funcall *col-num* 0 :reset (+ col-n (length (getf ast 'res)))))
                             (error (format nil "lcc\: unresolved method reference type ~A~%" form))))))
		          (t (unless (gethash func globals nil) (warning! "lcc\: [warning] undefined function ~A~%" func))
                     (set-ast-line (output "~A" func))
                     (output "(")
                     (let* ((li (cdr form))
                            (l (1- (length li))))
                       (loop
                             for f in li
                             for i from 0 to l
                             do (progn
                                  (compile-form f globals)
                                  (when (< i l) (output ", ")))))
                     (output ")")))))
    (error (ex)
	  (error (format nil "~A -> ~A" ex form)))))

(defun compile-return-form (form lvl globals)
  (unless (= (length form) 2) (error (format nil "wrong return form ~A" form)))
  (output "~&~A" (indent lvl))
  (set-ast-line (output "return "))
  (compile-form (cadr form) globals)
  (output ";~%"))

(defun compile-set-form (form lvl globals)
  (when (= (rem (length (cdr form)) 2) 1) (error (format nil "wrong set form ~A" form)))
  (let ((len (length (cdr form))))
    (loop for i from 0 to (1- len)
        for (x y) on (cdr form)
          do (when (= (mod i 2) 0)
               (unless (null y)
                 (output "~&~A" (indent lvl))
                 (compile-form x globals)
                 (output " ")
                 (set-ast-line (output "= "))
                 (compile-form y globals)
                 (output ";~%"))))))

(defun compile-block-form (form lvl globals)
  (when (< (length form) 2) (error (format nil "wrong block form ~A" form)))
  (compile-body (cdr form) lvl globals))

(defun compile-if-form (form lvl globals)
  (when (or (< (length form) 3) (> (length form) 4)) (error (format nil "wrong if form ~A" form)))
  (output "~&~A" (indent lvl))
  (set-ast-line (output "if ("))
  (compile-form (nth 1 form) globals)
  (set-ast-line (output ") {~%"))
  (compile-body (list (nth 2 form)) (+ lvl 1) globals)
  (if (= (length form) 3)
      (progn
        (output "~&~A" (indent lvl))
        (set-ast-line (output "}~%")))
      (progn
        (output "~&~A" (indent lvl))
        (set-ast-line (output "} else {~%"))
        (compile-body (list (nth 3 form)) (+ lvl 1) globals)
        (output "~&~A}~%" (indent lvl)))))

(defun compile-switch-form (form lvl globals)
  (when (< (length form) 2) (error (format nil "wrong switch form ~A" form)))
  (output "~&~A" (indent lvl))
  (set-ast-line (output "switch ("))
  (compile-form (nth 1 form) globals)
  (set-ast-line (output ") {~%"))
  (dolist (ch-form (nthcdr 2 form))
    (cond ((key-eq (car ch-form) '|case|)
           (output "~&~A" (indent lvl))
           (set-ast-line (output "case "))
           (compile-form (cadr ch-form) globals)
           (output ":~%")
           (compile-body (nthcdr 2 ch-form) (+ lvl 2) globals))
	      ((key-eq (car ch-form) '|default|)
           (output "~&~A" (indent lvl))
           (set-ast-line (output "default:~%" (indent (+ lvl 1))))
	       (compile-body (nthcdr 1 ch-form) (+ lvl 2) globals))
	      (t (error (format nil "only case or default form ~A" form)))))
  (output "~&~A}~%" (indent lvl)))

(defun compile-while-form (form lvl globals)
  (when (< (length form) 2) (error (format nil "wrong while form ~A" form)))
  (output "~&~A" (indent lvl))
  (set-ast-line (output "while ("))
  (compile-form (nth 1 form) globals)
  (set-ast-line (output ") {~%"))
  (compile-body (nthcdr 2 form) (+ lvl 1) globals)
  (output "~&~A}~%" (indent lvl)))

(defun compile-do-form (form lvl globals)
  (when (< (length form) 2) (error (format nil "wrong do form ~A" form)))
  (output "~&~A" (indent lvl))
  (set-ast-line (output "do {~%"))
  (compile-body (nthcdr 2 form) (+ lvl 1) globals)
  (output "~&~A" (indent lvl))
  (set-ast-line (output "} while ("))
  (compile-form (nth 1 form) globals)
  (set-ast-line (output ");~%")))

(defun compile-for-form (form lvl globals)
  (when (or (< (length form) 3) (not (listp (nth 1 form)))) (error (format nil "wrong for form ~A" form)))
  (output "~&~A" (indent lvl))
  (set-ast-line (output "for ("))
  (dolist (type (nth 1 form))
    (unless (and (not (null type)) (listp type)) (error (format nil "wrong variable definition form ~A" form)))
    (compile-type-value type globals)
    (output ", "))
  (compile-form (nth 2 form) globals)
  (output "; ")
  (set-ast-line (output ";) {~%"))
  (compile-body (nthcdr 3 form) (+ lvl 1) globals)
  (output "~&~A}~%" (indent lvl)))

(defun compile-for-each-form (form lvl globals)
  (when (or (< (length form) 4) (not (listp (nth 1 form)))) (error (format nil "wrong for each form ~A" form)))
  (let ((counter (gensym)))
    (output "~&~A" (indent lvl))
    (set-ast-line (output "for (int ~A = 0; ~A < " counter counter))
    (compile-form (nth 3 form) globals)
    (set-ast-line (output "; ~A++) {~%" counter))
    (output "~&~A" (indent (+ lvl 1)))
    (compile-type (nth 1 form) globals)
    (set-ast-line (output " = "))
    (set-ast-line (output "~A" (nth 2 form)))
    (set-ast-line (output "[~A];~%"   counter)))
  (compile-body (nthcdr 4 form) (+ lvl 1) globals)
  (output "~&~A}~%" (indent lvl)))

(defun compile-let-form (form lvl globals)
  (when (or (< (length form) 2) (not (listp (nth 1 form)))) (error (format nil "wrong let form ~A" form)))
  (let ((is-auto     nil)
	    (is-register nil)
	    (is-static   nil)
	    (dynamics    '())
	    (scope       "LET SCOPE")
	    (locals      (copy-specifiers globals)))
    (output "~&~A" (indent lvl))
    (output "{ /* ~A */~%" scope)
    (dolist (type-desc (nth 1 form))
      (unless (and (not (null type-desc)) (listp type-desc)) (error (format nil "wrong variable definition form ~A" form)))
      (cond ((and (key-eq (car type-desc) '|auto|)     (= (length (cdr type-desc)) 0)) (setq is-auto t))
	        ((and (key-eq (car type-desc) '|register|) (= (length (cdr type-desc)) 0)) (setq is-register t))
	        ((and (key-eq (car type-desc) '|static|)   (= (length (cdr type-desc)) 0)) (setq is-static t))
	        (t (multiple-value-bind (text const typeof modifier const-ptr variable array value)
		           (compile-type-value< type-desc globals t)
		         (when (and (listp value) (key-eq (first value) '|alloc|))
		           (when (or (= (length value) 1) (> (length value) 3))
		             (error (format nil "wrong alloc form ~A" value)))
		           (push variable dynamics)
		           (if (= (length value) 2)
		               (setq value (list '|cast| (list const typeof modifier const-ptr array)
					                     (list '|malloc| (nth 1 value))))
		               (setq value (list '|cast| (list const typeof modifier const-ptr array)
				                         (list '|calloc| (nth 1 value) (nth 2 value))))))
		         (let ((attributes '()))
		           (when is-static   (push '|static|   attributes))
		           (when is-register (push '|register| attributes))
		           (when is-auto     (push '|auto|     attributes))
		           (setf (gethash variable locals)
			             (make-specifier variable '|@VARIABLE| const typeof modifier const-ptr array value attributes)))
                 (output "~&~A" (indent (+ lvl 1)))
                 (when is-static   (set-ast-line (output "static ")))
                 (when is-register (set-ast-line (output "register ")))
                 (when is-auto     (set-ast-line (output "auto ")))
                 (format-type-value const typeof modifier const-ptr variable array value locals)
                 (output ";~%"))
	           (setq is-static nil))))
    (dolist (variable (reverse dynamics))
      (output "~&~A" (indent (+ lvl 1)))
      (set-ast-line (output "if ("))
      (set-ast-line (output "~A " variable))
      (set-ast-line (output "== NULL) printf(\"dynamic memory allocation failed! ~A\\n\");~%" variable)))
    (compile-body (nthcdr 2 form) (+ lvl 1) locals)
    (dolist (variable dynamics)
      (output "~&~A" (indent (+ lvl 1)))
      (set-ast-line (output "free("))
      (set-ast-line (output "~A" variable))
      (set-ast-line (output ");~%")))
    (output "~&~A" (indent lvl))
    (output "} /* ~A */~%" scope)))

(defun compile-body (body lvl globals)
  (dolist (form body)
    (cond ((key-eq form '|nil|) (set-ast-line (output "~&~ANULL;" (indent lvl))))
	      ((symbolp form)
           (output "~&~A" (indent lvl))
           (compile-form form globals)
           (output ";"))
	      (t (let ((func (car form))
		           (locals (copy-specifiers globals)))
	           (cond ((listp func) (error (format nil "function name or operator is missing ~A" form)))
		             ((and (= (length form) 2) (find func *unaries* :test #'key-eq))
                      (output "~&~A" (indent lvl))
                      (compile-unary form locals)
                      (output ";"))
		             ((and (= (length form) 3) (find func *assignments* :test #'key-eq))
                      (output "~&~A" (indent lvl))
                      (compile-assignment form locals)
		              (output ";"))
		             ((key-eq func '|break|)    (set-ast-line (output "~&~Abreak;"    (indent lvl))))
		             ((key-eq func '|continue|) (set-ast-line (output "~&~Acontinue;" (indent lvl))))
		             ((key-eq func '|return|)   (compile-return-form   form lvl locals))
		             ((key-eq func '|set|)      (compile-set-form      form lvl locals))
		             ((key-eq func '|let|)      (compile-let-form      form lvl locals)) 
		             ((key-eq func '|block|)    (compile-block-form    form lvl locals)) 
		             ((key-eq func '|if|)       (compile-if-form       form lvl locals)) 
		             ((key-eq func '|switch|)   (compile-switch-form   form lvl locals)) 
		             ((key-eq func '|while|)    (compile-while-form    form lvl locals)) 
		             ((key-eq func '|do|)       (compile-do-form       form lvl locals)) 
		             ((key-eq func '|for|)      (compile-for-form      form lvl locals)) 
		             ((key-eq func '|for-each|) (compile-for-each-form form lvl locals)) 
		             (t
                      (output "~&~A" (indent lvl))
                      (compile-form form locals)
                      (output ";~%"))))))))

(defun compile-variable (spec lvl globals)
  (let ((is-auto     nil)
	    (is-register nil)
	    (is-static   nil)
	    (is-extern   nil))
    (dolist (attr (attrs spec))
      (case attr
	    ('|auto|     (setq is-auto t))
	    ('|register| (setq is-register t))
	    ('|static|   (setq is-static t))
	    ('|extern|   (setq is-extern t))))
    (output "~&~A" (indent lvl))
    (when is-extern   (set-ast-line (output "extern ")))
    (when is-static   (set-ast-line (output "static ")))
    (when is-register (set-ast-line (output "register ")))
    (when is-auto     (set-ast-line (output "auto ")))
    (compile-spec-type-value spec globals)
    (output ";~%")))

(defun compile-lambda (spec lvl globals)
  (let ((tmp-spec spec))
    (setf *function-spec* spec)
    (when (> *ast-run* 1)
      (maphash #'(lambda (l-name l-spec)
                   (let ((attrs (attrs l-spec))
                         (body  (body l-spec)))
                     (setf (attrs l-spec) (list '|declare|))
                     (compile-lambda      l-spec 0 globals)
                     (setf (attrs l-spec) attrs)
                     (setf (body  l-spec) body)))
               (inners spec)))

    (if (> *ast-run* 1)
        (let ((inners (inners spec)))
          (setf (inners spec) (make-hash-table :test 'eql))
          (compile-function     spec lvl globals)
          ;; (setf (inners spec) inners)
          )
        (compile-function     spec lvl globals))
    
    (when (> *ast-run* 1)
      (maphash #'(lambda (l-name l-spec)
                   (compile-lambda     l-spec 0 globals))
               (inners spec)))
    (setf *function-spec* tmp-spec)))

(defun compile-function (spec lvl globals &optional (asType nil))
  (let* ((is-static  nil)
	     (is-declare nil)
	     (is-inline  nil)
	     (is-extern  nil)
         (is-method  (if (key-eq (construct spec) '|@METHOD|) t nil))
	     (name       (name   spec))
	     (params     (params spec))
	     (body       (body   spec))
	     (locals     (copy-specifiers globals))
	     (ret        (format-type< (const spec) (typeof spec) (modifier spec) nil
				                   (const-ptr spec) (array-def spec) locals)))
    (let ((cparams '()))
      (maphash #'(lambda (in-name in-spec)
		           (case (construct in-spec)
		             ('|@PARAMETER| (setf (gethash in-name locals) in-spec)
                                    (push in-spec cparams))
		             (otherwise nil)))
	           params)
      (dolist (attr (attrs spec))
        (case attr
	      ('|static|  (setq is-static  t))
	      ('|declare| (setq is-declare t))
	      ('|inline|  (setq is-inline  t))
	      ('|extern|  (setq is-extern  t))))
      (output "~&~A" (indent lvl))
      (when is-extern (set-ast-line (output "extern ")))
      (when is-inline (set-ast-line (output "__attribute__((weak)) ")))
      (when is-static (set-ast-line (output "static ")))
      (set-ast-line (output "~A " ret))
      (set-ast-line (output "~A " (if is-method
                                      (format nil "~A_~A" (car name) (cdr name))
                                      (if asType
                                          (format nil "(*~A)" name)
                                          name))))
      (output "(")
      (when is-method
        (setf (gethash '|this| locals)
			  (make-specifier '|this| '|@PARAMETER| nil (car name) '|*| nil nil nil '()))
        ;; (set-ast-line (output "~A " (car name)))
        (compile-form (car name) globals)
        (output " ")
        (set-ast-line (output "* "))
        (set-ast-line (output "this"))
        (when (> (length cparams) 0) (set-ast-line (output ", "))))
      (loop
            for param in cparams
            with lc = (1- (length cparams))
            for i from 0 to lc
            do (progn
                 (compile-spec-type-value param locals)
                 (when (< i lc) (output ", "))))
      (output ")")
      (if is-declare
          (unless asType (output ";~%"))
          (progn
            (output " ")
            (output "{~%")))
      (unless is-declare
	      ;; (progn
	      ;;   (set-ast-line (output "~&typedef "))
          ;;   (set-ast-line (output "~A " ret))
          ;;   (set-ast-line (output "(*~A_t) " (if is-method (format nil "~A_~A" (car name) (cdr name)) name)))
          ;;   (output "(")
          ;;   (when is-method
          ;;     ;; (set-ast-line (output "~A " (car name)))
          ;;     (compile-form (car name) globals)
          ;;     (output " ")
          ;;     (set-ast-line (output "* "))
          ;;     (set-ast-line (output "this"))
          ;;     (when (> (length cparams) 0) (output ", ")))
          ;;   (loop
          ;;         for param in cparams
          ;;         with lc = (1- (length cparams))
          ;;         for i from 0 to lc
          ;;         do (progn
          ;;              (compile-spec-type-value param locals)
          ;;              (when (< i lc) (output ", "))))
	      ;;   (output ")")
          ;;   (unless asType (output ";~%")))
          (progn
	        (compile-body body (+ lvl 1) locals)
	        (output "~&~A" (indent lvl))
            (output "}~%"))))))

(defun compile-preprocessor (spec lvl globals)
  (let* ((def (body spec))
	     (dir (symbol-name (car def))))
    (setf (char dir 0) #\#)
    (set-ast-line (output "~&~A" dir))
    (when (> (length def) 1)
      (compile-form (cadr def) globals))
    (output "~%")))

(defun compile-include (spec lvl globals)
  (let ((header (name spec)))
    (cond ((symbolp header)
           (set-ast-line (output "~&#include "))
           (set-ast-line (output "~A~%" header)))
	      ((stringp header)
           (set-ast-line (output "~&#include "))
           (set-ast-line (output "~S~%" header)))
	      (t (error "wrong inclusion")))))

(defun compile-typedef (spec lvl globals)
  (let ((text (compile-spec-type spec globals)))
    (set-ast-line (output "~&typedef "))
    (set-ast-line (output "~A" text))
    (output ";~%")))

(defun compile-enum (spec lvl globals)
  (let ((name         (name spec))
	    (is-anonymous (anonymous spec))
	    (counter      1)
	    (count        (hash-table-count (inners spec)))
	    (locals       (copy-specifiers globals)))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@VARIABLE| (setf (gethash in-name locals) in-spec))
		           (otherwise nil)))
	         (inners spec))
    (output "~&~A" (indent lvl))
    (if is-anonymous
        (set-ast-line (output "enum "))
        (progn
          (set-ast-line (output "typedef "))
          (set-ast-line (output "enum "))
          (set-ast-line (output "~A " name))))
    (if is-anonymous
        (output "{ /* ~A */~%" name)
        (output "{~%"))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@VARIABLE|
                    (output "~&~A" (indent (+ 1 lvl)))
		            (set-ast-line (output "~A" in-name))
                    (unless (null (default in-spec))
                      (set-ast-line (output " = "))
                      (compile-form (default in-spec) locals))
                    (when (< counter count) (output ","))
                    (output "~%"))
		           (otherwise nil))
		         (incf counter))
	         (inners spec))
    (output "~&}")
    (unless is-anonymous
      (output " ")
      (set-ast-line (output "~A" name)))
    (output "; /* ~A */~%" name)))

(defun compile-struct (spec lvl globals)
  (let ((name         (name spec))
	    (is-anonymous (anonymous spec))
	    (declares     '())
	    (locals       (copy-specifiers globals)))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@VARIABLE| (setf (gethash in-name locals) in-spec))
		           ;; ('|@FUNCTION| (setf (gethash in-name locals) in-spec))
		           ('|@ENUM|
		            (unless (anonymous spec) (setf (gethash in-name locals) in-spec))
		            (maphash #'(lambda (k v) (setf (gethash k locals) v)) (inners in-spec)))
		           ('|@STRUCT|
		            (setf (gethash in-name locals) in-spec)
		            (maphash #'(lambda (k v)
				                 (when (eql (construct v) '|@DECLARES|) (setf (gethash k locals) v)))
			                 (inners in-spec)))
		           ('|@UNION|
		            (setf (gethash in-name locals) in-spec)
		            (maphash #'(lambda (k v)
				                 (when (eql (construct v) '|@DECLARES|) (setf (gethash k locals) v)))
			                 (inners in-spec)))
		           (otherwise nil)))
	         (inners spec))
    (output "~&~A" (indent lvl))
    (if is-anonymous
        (set-ast-line (output "struct "))
        (progn
          (set-ast-line (output "typedef "))
          (set-ast-line (output "struct "))
          (set-ast-line (output "~A " name))))
    (if is-anonymous
        (output "{ /* ~A */~%" name)
        (output "{~%"))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@PREPROC|  (compile-preprocessor in-spec (+ 1 lvl) locals))
		           ('|@VARIABLE| (compile-variable     in-spec (+ 1 lvl) locals))
		           ;; ('|@FUNCTION| (compile-function     in-spec (+ 1 lvl) locals))
		           ('|@ENUM|     (compile-enum         in-spec (+ 1 lvl) locals))
		           ('|@STRUCT|   (compile-struct       in-spec (+ 1 lvl) locals))
		           ('|@UNION|    (compile-union        in-spec (+ 1 lvl) locals))
		           ('|@DECLARES| (push (name in-spec) declares))
		           (otherwise nil)))
	         (inners spec))
    (output "~&~A" (indent lvl))
    (output "}")
    (if is-anonymous
        (unless (null declares)
          (output " ")
          (loop
                for dec in declares
                with l = (1- (length declares))
                for i from 0 to l
                do (progn
                     (set-ast-line (output "~A" dec))
                     (when (< i l) (output ", ")))))
        (progn
          (output " ")
          (set-ast-line (output "~A" name))))
    (output "; /* ~A */~%" name)))

(defun compile-union (spec lvl globals)
  (let ((name         (name spec))
	    (is-anonymous (anonymous spec))
	    (declares     '())
	    (locals       (copy-specifiers globals)))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@VARIABLE| (setf (gethash in-name locals) in-spec))
		           ('|@STRUCT|
		            (setf (gethash in-name locals) in-spec)
		            (maphash #'(lambda (k v)
				                 (when (eql (construct v) '|@DECLARES|) (setf (gethash k locals) v)))
			                 (inners in-spec)))
		           ('|@UNION|
		            (setf (gethash in-name locals) in-spec)
		            (maphash #'(lambda (k v)
				                 (when (eql (construct v) '|@DECLARES|) (setf (gethash k locals) v)))
			                 (inners in-spec)))
		           (otherwise nil)))
	         (inners spec))
    (output "~&~A" (indent lvl))
    (if is-anonymous
        (set-ast-line (output "union "))
        (progn
          (set-ast-line (output "typedef "))
          (set-ast-line (output "union "))
          (set-ast-line (output "~A " name))))
    (if is-anonymous
        (output "{ /* ~A */~%" name)
        (output "{~%"))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@PREPROC|  (compile-preprocessor in-spec (+ 1 lvl) locals))
		           ('|@VARIABLE| (compile-variable     in-spec (+ 1 lvl) locals))
		           ('|@STRUCT|   (compile-struct       in-spec (+ 1 lvl) locals))
		           ('|@UNION|    (compile-union        in-spec (+ 1 lvl) locals))
		           ('|@DECLARES| (push (name in-spec) declares))
		           (otherwise nil)))
	         (inners spec))
    (output "~&~A" (indent lvl))
    (output "}")
    (if is-anonymous
        (unless (null declares)
          (output " ")
          (loop
                for dec in declares
                with l = (1- (length declares))
                for i from 0 to l
                do (progn
                     (set-ast-line (output "~A" dec))
                     (when (< i l) (output ", ")))))
        (progn
          (output " ")
          (set-ast-line (output "~A" name))))
    (output "; /* ~A */~%" name)))

(defun compile-guard (spec lvl globals)
  (let ((name (name spec)))
    (set-ast-line (output "~&#ifndef ~A~%" name))
    (set-ast-line (output "~&#define ~A~%" name))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@PREPROC|  (compile-preprocessor in-spec lvl globals))
		           ('|@INCLUDE|  (compile-include      in-spec lvl globals))
		           ('|@TYPEDEF|  (compile-typedef      in-spec lvl globals))
		           ('|@VARIABLE| (compile-variable     in-spec lvl globals))
		           ('|@FUNCTION| (compile-function     in-spec lvl globals))
		           ('|@METHOD|   (compile-function     in-spec lvl globals))
		           ('|@ENUM|     (compile-enum         in-spec lvl globals))
		           ('|@STRUCT|   (compile-struct       in-spec lvl globals))
		           ('|@UNION|    (compile-union        in-spec lvl globals))
		           ('|@GUARD|    (compile-guard        in-spec lvl globals))
		           (otherwise nil)))
	         (inners spec))    
    (set-ast-line (output "~&#endif /* ~A */ ~%" name))))
