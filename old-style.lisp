
(defun compile-return-form (form lvl globals)
  (unless (= (length form) 2) (error (format nil "wrong return form ~A" form)))
  (output "~&~A" (indent lvl))
  (set-ast-line (output "return ~A;~%" (compile-form< (cadr form) globals))))

(defun compile-set-form (form lvl globals)
  (when (= (rem (length (cdr form)) 2) 1) (error (format nil "wrong set form ~A" form)))
  (let ((items '()))
    (dolist (item (cdr form))
      (push (compile-form< item globals) items))
    (set-ast-line (output "~&~A~{~A = ~A~^, ~};~%" (indent lvl) (nreverse items)))))

(defun compile-block-form (form lvl globals)
  (when (< (length form) 2) (error (format nil "wrong block form ~A" form)))
  (compile-body (cdr form) lvl globals))

(defun compile-if-form (form lvl globals)
  (when (or (< (length form) 3) (> (length form) 4)) (error (format nil "wrong if form ~A" form)))
  (set-ast-line (output "~&~Aif (~A) {~%" (indent lvl) (compile-form< (nth 1 form) globals)))
  (compile-body (list (nth 2 form)) (+ lvl 1) globals)
  (if (= (length form) 3)
      (output "~&~A}~%" (indent lvl))
      (progn
        (set-ast-line (output "~&~A} else {~%" (indent lvl)))
        (compile-body (list (nth 3 form)) (+ lvl 1) globals)
        (output "~&~A}~%" (indent lvl)))))

(defun compile-switch-form (form lvl globals)
  (when (< (length form) 2) (error (format nil "wrong switch form ~A" form)))
  (set-ast-line (output "~&~Aswitch (~A) {~%" (indent lvl) (compile-form< (nth 1 form) globals)))
  (dolist (ch-form (nthcdr 2 form))
    (cond ((key-eq (car ch-form) '|case|)
	       (set-ast-line (output "~&~Acase ~A:~%" (indent (+ lvl 1)) (compile-form< (cadr ch-form) globals)))
	       (compile-body (nthcdr 2 ch-form) (+ lvl 2) globals))
	      ((key-eq (car ch-form) '|default|)
	       (set-ast-line (output "~&~Adefault:~%" (indent (+ lvl 1))))
	       (compile-body (nthcdr 1 ch-form) (+ lvl 2) globals))
	      (t (error (format nil "only case or default form ~A" form)))))
  (output "~&~A}~%" (indent lvl)))

(defun compile-while-form (form lvl globals)
  (when (< (length form) 2) (error (format nil "wrong while form ~A" form)))
  (set-ast-line (output "~&~Awhile (~A) {~%" (indent lvl) (compile-form< (nth 1 form) globals)))
  (compile-body (nthcdr 2 form) (+ lvl 1) globals)
  (output "~&~A}~%" (indent lvl)))

(defun compile-do-form (form lvl globals)
  (when (< (length form) 2) (error (format nil "wrong do form ~A" form)))
  (set-ast-line (output "~&~Ado {~%" (indent lvl)))
  (compile-body (nthcdr 2 form) (+ lvl 1) globals)
  (set-ast-line (output "~&~A} while (~A);~%" (indent lvl) (compile-form< (nth 1 form) globals))))

(defun compile-for-form (form lvl globals)
  (when (or (< (length form) 3) (not (listp (nth 1 form)))) (error (format nil "wrong for form ~A" form)))
  (set-ast-line (output "~&~Afor (" (indent lvl)))
  (let ((inits '()))
    (dolist (type (nth 1 form))
      (unless (and (not (null type)) (listp type)) (error (format nil "wrong variable definition form ~A" form)))
      (push (compile-type-value< type globals) inits))
    (set-ast-line (output "~{~A~^, ~}; ~A;) {~%" (nreverse inits) (compile-form< (nth 2 form) globals))))
  (compile-body (nthcdr 3 form) (+ lvl 1) globals)
  (output "~&~A}~%" (indent lvl)))

(defun compile-for-each-form (form lvl globals)
  (when (or (< (length form) 4) (not (listp (nth 1 form)))) (error (format nil "wrong for each form ~A" form)))
  (let ((counter (gensym)))
    (set-ast-line (output "~&~Afor (int ~A = 0; ~A < ~A; ~A++) {~%" (indent lvl)
	                      counter counter (compile-form< (nth 3 form) globals) counter))
    (set-ast-line (output "~&~A~A = ~A[~A];~%" (indent (+ lvl 1))
                          (compile-type< (nth 1 form) globals) (nth 2 form) counter)))
  (compile-body (nthcdr 4 form) (+ lvl 1) globals)
  (output "~&~A}~%" (indent lvl)))

(defun compile-let-form (form lvl globals)
  (when (or (< (length form) 2) (not (listp (nth 1 form)))) (error (format nil "wrong let form ~A" form)))
  (let ((is-auto     nil)
	    (is-register nil)
	    (is-static   nil)
	    (dynamics    '())
	    (scope       (gensym "SCOPE"))
	    (locals      (copy-specifiers globals)))
    (output "~&~A{ /* ~A */~%" (indent lvl) scope)
    (dolist (type-desc (nth 1 form))
      (unless (and (not (null type-desc)) (listp type-desc)) (error (format nil "wrong variable definition form ~A" form)))
      (cond ((and (key-eq (car type-desc) '|auto|)     (= (length (cdr type-desc)) 0)) (setq is-auto t))
	        ((and (key-eq (car type-desc) '|register|) (= (length (cdr type-desc)) 0)) (setq is-register t))
	        ((and (key-eq (car type-desc) '|static|)   (= (length (cdr type-desc)) 0)) (setq is-static t))
	        (t (multiple-value-bind (text const typeof modifier const-ptr variable array value)
		           (compile-type-value< type-desc globals t)
		         (when (and (listp value) (key-eq (first value) '|alloc|))
		           (when (or (= (length value) 1) (> (length value) 3))
		             (error (format nil "wrong alloc form ~A" value)))
		           (push variable dynamics)
		           (if (= (length value) 2)
		               (setq value (list '|cast| (list const typeof modifier const-ptr array)
					                     (list '|malloc| (nth 1 value))))
		               (setq value (list '|cast| (list const typeof modifier const-ptr array)
				                         (list '|calloc| (nth 1 value) (nth 2 value))))))
		         (let ((attributes '()))
		           (when is-static   (push '|static|   attributes))
		           (when is-register (push '|register| attributes))
		           (when is-auto     (push '|auto|     attributes))
		           (setf (gethash variable locals)
			             (make-specifier variable '|@VARIABLE| const typeof modifier const-ptr array value attributes)))
		         (set-ast-line (output "~&~A~:[~;static ~]~:[~;register ~]~:[~;auto ~]~A;~%" (indent (+ lvl 1))
		                 is-static is-register is-auto
		                 (format-type-value< const typeof modifier const-ptr variable array value locals))))
	           (setq is-static nil))))
    (dolist (variable (reverse dynamics))
      (set-ast-line (output "~&~Aif (~A == NULL) printf(\"dynamic memory allocation failed! ~A\\n\");~%" (indent (+ lvl 1))
	          variable variable)))
    (compile-body (nthcdr 2 form) (+ lvl 1) locals)
    (dolist (variable dynamics)
      (set-ast-line (output "~&~Afree(~A);~%"(indent (+ lvl 1)) variable)))
    (output "~&~A} /* ~A */~%"(indent lvl) scope)))

(defun compile-body (body lvl globals)
  (dolist (form body)
    (cond ((key-eq form '|nil|) (set-ast-line (output "~&~ANULL;" (indent lvl))))
	      ((symbolp form)       (set-ast-line (output "~&~A~A;" (indent lvl) (compile-form< form globals))))
	      (t (let ((func (car form))
		           (locals (copy-specifiers globals)))
	           (cond ((listp func) (error (format nil "function name or operator is missing ~A" form)))
		             ((and (= (length form) 2) (find func *unaries* :test #'key-eq))
		              (set-ast-line (output "~&~A~A;" (indent lvl) (compile-unary< form locals))))
		             ((and (= (length form) 3) (find func *assignments* :test #'key-eq))
		              (set-ast-line (output "~&~A~A;" (indent lvl) (compile-assignment< form locals))))
		             ((key-eq func '|break|)    (set-ast-line (output "~&~Abreak;"    (indent lvl))))
		             ((key-eq func '|continue|) (set-ast-line (output "~&~Acontinue;" (indent lvl))))
		             ((key-eq func '|return|)   (compile-return-form   form lvl locals))
		             ((key-eq func '|set|)      (compile-set-form      form lvl locals))
		             ((key-eq func '|let|)      (compile-let-form      form lvl locals)) 
		             ((key-eq func '|block|)    (compile-block-form    form lvl locals)) 
		             ((key-eq func '|if|)       (compile-if-form       form lvl locals)) 
		             ((key-eq func '|switch|)   (compile-switch-form   form lvl locals)) 
		             ((key-eq func '|while|)    (compile-while-form    form lvl locals)) 
		             ((key-eq func '|do|)       (compile-do-form       form lvl locals)) 
		             ((key-eq func '|for|)      (compile-for-form      form lvl locals)) 
		             ((key-eq func '|for-each|) (compile-for-each-form form lvl locals)) 
		             (t (set-ast-line (output "~&~A~A;~%" (indent lvl) (compile-form< form locals))))))))))

(defun compile-variable (spec lvl globals)
  (let ((is-auto     nil)
	    (is-register nil)
	    (is-static   nil)
	    (is-extern   nil))
    (dolist (attr (attrs spec))
      (case attr
	    ('|auto|     (setq is-auto t))
	    ('|register| (setq is-register t))
	    ('|static|   (setq is-static t))
	    ('|extern|   (setq is-extern t))))
    (let ((text (compile-spec-type-value< spec globals)))
      (set-ast-line (output "~&~A~:[~;extern ~]~:[~;static ~]~:[~;register ~]~:[~;auto ~]~A;~%"
	          (indent lvl) is-extern is-static is-register is-auto text)))))

(defun compile-function (spec lvl globals)
  (let* ((is-static  nil)
	     (is-declare nil)
	     (is-inline  nil)
	     (is-extern  nil)
         (is-method  (if (key-eq (construct spec) '|@METHOD|) t nil))
	     (name       (name   spec))
	     (params     (params spec))
	     (body       (body   spec))
	     (locals     (copy-specifiers globals))
	     (ret        (format-type< (const spec) (typeof spec) (modifier spec) nil
				                   (const-ptr spec) (array-def spec) locals)))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@PARAMETER| (setf (gethash in-name locals) in-spec))
		           (otherwise nil)))
	         (params spec))
    (dolist (attr (attrs spec))
      (case attr
	    ('|static|  (setq is-static  t))
	    ('|declare| (setq is-declare t))
	    ('|inline|  (setq is-inline  t))
	    ('|extern|  (setq is-extern  t))))
    (set-ast-line (output "~&~A~:[~;extern ~]~:[~;__attribute__((weak)) ~]~:[~;static ~]~A ~A ("
            (indent lvl) is-extern is-inline is-static ret (if is-method (format nil "~A_~A" (car name) (cdr name)) name)))
    (let ((cparams '()))
      (maphash #'(lambda (name param)
		           (push (compile-spec-type-value< param locals) cparams))
	           params)
      (when is-method
        (setf (gethash '|this| locals)
			  (make-specifier '|this| '|@PARAMETER| nil (intern (car name)) '|*| nil nil nil '()))
        (set-ast-line (output "~A * this~:[~;, ~]" (car name) (> (length cparams) 0))))
      (set-ast-line (output "~{~A~^, ~})~:[ {~;;~]~%" (nreverse cparams) is-declare)))
    (if is-declare
	    (progn
	      (set-ast-line (output "~&typedef ~A (*~A_t)" ret (if is-method (format nil "~A_~A" (car name) (cdr name)) name)))
	      (let ((cparams '()))
	        (maphash #'(lambda (name param)
			             (push (format-type< (const spec) (typeof spec) (modifier spec) nil
					                         (const-ptr spec) (array-def spec) locals) cparams))
		             params)
	        (set-ast-line (output " (~{~A~^, ~});~%" (nreverse cparams)))))
        (progn
	      (compile-body body (+ lvl 1) locals)
	      (output "~&~A}~%" (indent lvl))))))

(defun compile-preprocessor (spec lvl globals)
  (let* ((def (body spec))
	     (dir (symbol-name (car def))))
    (setf (char dir 0) #\#)
    (set-ast-line (output "~&~A~:[~; ~A~]~%" dir (> (length def) 1) (compile-form< (cadr def) globals)))))

(defun compile-include (spec lvl globals)
  (let ((header (name spec)))
    (cond ((symbolp header) (set-ast-line (output "~&#include ~A~%" header)))
	      ((stringp header) (set-ast-line (output "~&#include ~S~%" header)))
	      (t (error "wrong inclusion")))))

(defun compile-typedef (spec lvl globals)
  (let ((text (compile-spec-type< spec globals)))
    (set-ast-line (output "~&typedef ~A;~%" text))))

(defun compile-enum (spec lvl globals)
  (let ((name         (name spec))
	    (is-anonymous (anonymous spec))
	    (counter      1)
	    (count        (hash-table-count (inners spec)))
	    (locals       (copy-specifiers globals)))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@VARIABLE| (setf (gethash in-name locals) in-spec))
		           (otherwise nil)))
	         (inners spec))
    (set-ast-line (output "~&~A~:[typedef enum ~A~;enum~] {~%" (indent lvl) is-anonymous name))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@VARIABLE|
		            (set-ast-line (output "~&~A~A~:[ = ~A~;~*~]~:[~;,~]~%"
		                    (indent (+ 1 lvl)) in-name (null (default in-spec))
		                    (compile-form< (default in-spec) locals) (< counter count))))
		           (otherwise nil))
		         (incf counter))
	         (inners spec))
    (set-ast-line (output "~&}~:[ ~A~;~]; /* ~A */~%" is-anonymous name name))))

(defun compile-struct (spec lvl globals)
  (let ((name         (name spec))
	    (is-anonymous (anonymous spec))
	    (declares     '())
	    (locals       (copy-specifiers globals)))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@VARIABLE| (setf (gethash in-name locals) in-spec))
		           ('|@FUNCTION| (setf (gethash in-name locals) in-spec))
		           ('|@ENUM|
		            (unless (anonymous spec) (setf (gethash in-name locals) in-spec))
		            (maphash #'(lambda (k v) (setf (gethash k locals) v)) (inners in-spec)))
		           ('|@STRUCT|
		            (setf (gethash in-name locals) in-spec)
		            (maphash #'(lambda (k v)
				                 (when (eql (construct v) '|@DECLARES|) (setf (gethash k locals) v)))
			                 (inners in-spec)))
		           ('|@UNION|
		            (setf (gethash in-name locals) in-spec)
		            (maphash #'(lambda (k v)
				                 (when (eql (construct v) '|@DECLARES|) (setf (gethash k locals) v)))
			                 (inners in-spec)))
		           (otherwise nil)))
	         (inners spec))
    (set-ast-line (output "~&~A~:[typedef struct ~A~;struct~] {~%" (indent lvl) is-anonymous name))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@PREPROC|  (compile-preprocessor in-spec (+ 1 lvl) locals))
		           ('|@VARIABLE| (compile-variable     in-spec (+ 1 lvl) locals))
		           ('|@FUNCTION| (compile-function     in-spec (+ 1 lvl) locals))
		           ('|@ENUM|     (compile-enum         in-spec (+ 1 lvl) locals))
		           ('|@STRUCT|   (compile-struct       in-spec (+ 1 lvl) locals))
		           ('|@UNION|    (compile-union        in-spec (+ 1 lvl) locals))
		           ('|@DECLARES| (push (name in-spec) declares))
		           (otherwise nil)))
	         (inners spec))
    (set-ast-line (output "~&~A}~:[ ~A~;~*~]~:[ ~;~]" (indent lvl) is-anonymous name (null declares)))
    (set-ast-line (output "~{~A~^, ~}; /* ~A */~%" declares name))))

(defun compile-union (spec lvl globals)
  (let ((name         (name spec))
	    (is-anonymous (anonymous spec))
	    (declares     '())
	    (locals       (copy-specifiers globals)))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@VARIABLE| (setf (gethash in-name locals) in-spec))
		           ('|@STRUCT|
		            (setf (gethash in-name locals) in-spec)
		            (maphash #'(lambda (k v)
				                 (when (eql (construct v) '|@DECLARES|) (setf (gethash k locals) v)))
			                 (inners in-spec)))
		           ('|@UNION|
		            (setf (gethash in-name locals) in-spec)
		            (maphash #'(lambda (k v)
				                 (when (eql (construct v) '|@DECLARES|) (setf (gethash k locals) v)))
			                 (inners in-spec)))
		           (otherwise nil)))
	         (inners spec))
    (set-ast-line (output "~&~A~:[typedef union ~A~;union~] {~%" (indent lvl) is-anonymous name))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@PREPROC|  (compile-preprocessor in-spec (+ 1 lvl) locals))
		           ('|@VARIABLE| (compile-variable     in-spec (+ 1 lvl) locals))
		           ('|@STRUCT|   (compile-struct       in-spec (+ 1 lvl) locals))
		           ('|@UNION|    (compile-union        in-spec (+ 1 lvl) locals))
		           ('|@DECLARES| (push (name in-spec) declares))
		           (otherwise nil)))
	         (inners spec))
    (set-ast-line (output "~&~A}~:[ ~A~;~*~]~:[ ~;~]" (indent lvl) is-anonymous name (null declares)))
    (set-ast-line (output "~{~A~^, ~}; /* ~A */~%" declares name))))

(defun compile-guard (spec lvl globals)
  (let ((name (name spec)))
    (set-ast-line (output "~&#ifndef ~A~%" name))
    (set-ast-line (output "~&#define ~A~%" name))
    (maphash #'(lambda (in-name in-spec)
		         (case (construct in-spec)
		           ('|@PREPROC|  (compile-preprocessor in-spec lvl globals))
		           ('|@INCLUDE|  (compile-include      in-spec lvl globals))
		           ('|@TYPEDEF|  (compile-typedef      in-spec lvl globals))
		           ('|@VARIABLE| (compile-variable     in-spec lvl globals))
		           ('|@FUNCTION| (compile-function     in-spec lvl globals))
		           ('|@METHOD|   (compile-function     in-spec lvl globals))
		           ('|@ENUM|     (compile-enum         in-spec lvl globals))
		           ('|@STRUCT|   (compile-struct       in-spec lvl globals))
		           ('|@UNION|    (compile-union        in-spec lvl globals))
		           ('|@GUARD|    (compile-guard        in-spec lvl globals))
		           (otherwise nil)))
	         (inners spec))    
    (set-ast-line (output "~&#endif /* ~A */ ~%" name))))
