(in-package :cicili)

;; expands all defined macros
(defun expand-macros-expr (def)
  (let* ((func (car def))
         (macro (if (symbolp func) (gethash (symbol-name func) *macros*) nil)))
    (if (or macro (and (symbolp func) (macro-function func)))
        (let ((tmp-expantion *macroexpand*)
              (id (format nil "me: ~D" (funcall *macro-counter*)))
              (result nil))
          (when *debug-macroexpand* (format t "~A ~A~%" id def))
          (setf *macroexpand* t)
          (if (key-eq func '|generic|)
              (let ((symb (eval (macroexpand def))))
                (setq result (specify-nil-expr)))
              (let ((expr (if macro (macroexpand `(,macro ,@(cdr def))) (macroexpand def))))
                (when *debug-macroexpand* (format t "~A ~A~%" id expr))
                (setq result (if (atom expr)
                                 (specify-expr expr)
                                 (if (and (listp expr) (atom (car expr)))
                                     (specify-body (list expr))
                                     (specify-body expr))))))
          (setf *macroexpand* tmp-expantion)
          result)
        (specify-call-expr def))))

;; for type specification only
(defun expand-macros (def)
  (if (atom def) def
      (let* ((func (car def))
             (macro (if (symbolp func) (gethash (symbol-name func) *macros*) nil)))
        (if (or macro (and (symbolp func) (macro-function func)))
            (let ((tmp-expantion *macroexpand*)
                  (id (gensym "me:"))
                  (result nil))
              (when *debug-macroexpand* (format t "~A ~A~%" id def))
              (setf *macroexpand* t)
              (setq result (if macro (macroexpand `(,macro ,@(cdr def))) (macroexpand def)))
              (when *debug-macroexpand* (format t "~A ~A~%" id result))
              (setf *macroexpand* tmp-expantion)
              result)
            def))))

(defun specify-expr (def)
  (cond ((key-eq  def '|nil|) (specify-nil-expr))
        ((atom    def)        (specify-atom-expr def))
        (t (let ((func (car def)))

	         (cond ((key-eq func 'QUASIQUOTE)
                    (specify-expr (eval (car (macroexpand `(,(cadr def) ,@(cddr def)))))))
                   ((key-eq func '|code|)   (specify-code-expr def))
                   ((key-eq func 'FUNCTION) (specify-expr      (cadr def)))
		           ((key-eq func 'QUOTE)
                    (let ((quoted (cadr def)))
                      (cond ((key-eq (car quoted) '|lambda|) ; lambda
                             (let* ((lname (gensym "__ciciliL_"))
                                    (func-spec (specify-function (append (list '|lambda| lname) (cdr quoted)) '())))
                               (add-inner func-spec (if *function-spec* *function-spec* *variable-spec*))
                               (let* ((fname (name func-spec))
                                      (name (if (listp fname)
                                                (intern (make-shared-name (car fname) (cdr fname)))
                                                fname)))
                                 (specify-symbol-expr (if *module-path* (free-name *module-path* lname) name)))))
                            
                            ((key-eq (car quoted) '|lambda*|) ; lambda*
                             (let* ((func-spec (specify-function quoted '())))
                               (add-inner func-spec (if *function-spec* *function-spec* *variable-spec*))
                               (let* ((fname (name func-spec))
                                      (name (if (listp fname)
                                                (intern (make-shared-name (car fname) (cdr fname)))
                                                fname)))
                                 (specify-symbol-expr (if *module-path* (free-name *module-path* name) name)))))

                            ((key-eq (car quoted) '|closure*|) ; closure*
                             (let ((struct-spec (specify-struct (cadr quoted) '())))
                               (add-inner struct-spec (if *function-spec* *function-spec* *variable-spec*))
                               (specify-expr (caddr quoted))))
                            
                            (t (specify-list-expr quoted)))))   ; list
		           ((and (> (length def) 2) (key-eq func '\|) (key-eq (cadr def) '\|))
		            (specify-operator-expr (push '\|\| (cddr def))))
		           ((and (> (length def) 2) (key-eq func '\|)) (specify-operator-expr def))
		           ((and (= (length def) 2) (find func *unaries*   :test #'key-eq)) (specify-unary-expr def))
		           ((and (> (length def) 2) (find func *operators* :test #'key-eq)) (specify-operator-expr def))
		           ((key-eq func '|nth|)    (specify-nth-expr    def))
		           ((key-eq func '|?|)      (specify-?-expr      def)) 
		           ((key-eq func '|cast|)   (specify-cast-expr   def))
                   ((key-eq func '|$|)      (specify-$-expr      def)) ; member access operator
                   ((key-eq func '|->|)     (specify-->-expr     def)) ; method access operator
                   ((key-eq func '|=>|)     (specify-=>-expr     def)) ; member function access operator
                   ((key-eq func '|sizeof|) (specify-sizeof-expr def))
                   ((key-eq func '|typeof|) (specify-typeof-expr def))
                   (t (expand-macros-expr def)))))))

(defun specify-body (def)
  (let ((body-specifier (make-specifier (gensym "cicili#Body") '@|BODY| nil nil nil nil nil nil nil))
        (lbody '())
        (attributes '()))
    (dolist (form def)
      (let ((res
             (cond ((key-eq  form '|nil|) (specify-nil-expr))
                   ((atom    form)        (specify-atom-expr   form))
	               (t (let ((func (car form)))
                        (cond ((and (symbolp func) (find (char (symbol-name func) 0) "@#"))
		                       (specify-preprocessor form '()))
                              ((and (= (length form) 2) (find func *unaries*     :test #'key-eq))
                               (specify-unary-expr form))
		                      ((and (= (length form) 3) (find func *assignments* :test #'key-eq))
                               (specify-assignment-expr form))
		                      ((key-eq func '|macrolet|)  (specify-macrolet      form)) 
		                      ((key-eq func '|let|)       (specify-let           form)) 
		                      ((key-eq func '|letn|)      (specify-let           form t)) 
		                      ((key-eq func '|block|)     (specify-block         form)) 
		                      ((key-eq func '|progn|)     (specify-progn         form)) 
		                      ((key-eq func '|set|)       (specify-set-expr      form))
		                      ((key-eq func '|return|)    (specify-return-expr   form))
		                      ((key-eq func '|break|)     (specify-symbol-expr   (car form)))
		                      ((key-eq func '|continue|)  (specify-symbol-expr   (car form)))
		                      ((key-eq func '|if|)        (specify-if            form)) 
		                      ((key-eq func '|switch|)    (specify-switch        form)) 
		                      ((key-eq func '|while|)     (specify-while         form)) 
		                      ((key-eq func '|do|)        (specify-do            form)) 
		                      ((key-eq func '|for|)       (specify-for           form)) 
		                      ((key-eq func '|cond|)      (specify-cond          form))
		                      ((key-eq func '|static|)       (push form attributes) nil)     
		                      ((key-eq func '|decl|)         (push form attributes) nil)
		                      ((key-eq func '|inline|)       (push form attributes) nil)
		                      ((key-eq func '|register|)     (push form attributes) nil)
		                      ((key-eq func '|extern|)       (push form attributes) nil)
		                      ((key-eq func '|volatile|)     (push form attributes) nil)
		                      ((key-eq func '|thread-local|) (push form attributes) nil)
		                      ((key-eq func '|resolve|)      (push form attributes) nil)
		                      ((key-eq func '|defer|)        (push form attributes) nil)
                              (t (let ((out-res
                                           (cond ((key-eq func '|include|) (specify-include     form attributes))
		                                         ((key-eq func '|typedef|) (specify-typedef     form attributes))
                                                 ((key-eq func '|var|)     (specify-variable    form attributes))
		                                         ((key-eq func '|func|)    (specify-function    form attributes))
		                                         ((key-eq func '|method|)  (specify-function    form attributes))
		                                         ((key-eq func '|enum|)    (specify-enum        form attributes))
		                                         ((key-eq func '|struct|)  (specify-struct      form attributes))
		                                         ((key-eq func '|union|)   (specify-union       form attributes))
		                                         ((key-eq func '|guard|)   (specify-guard       form attributes))
		                                         ((key-eq func '|module|)  (specify-module      form attributes))
		                                         ((key-eq func '|cicili|)
                                                  (compile-ast (cdr form) (or *load-truename* *compile-file-truename*)))
                                                 (t (specify-expr form)))))
                                   (setq attributes '())
                                   out-res))))))))
        (when res (push res lbody))))
    (setf (body body-specifier) (reverse lbody))
    body-specifier))

(defun compile-form (spec lvl globals parent-spec &key from-body)
  (case (construct spec)
      ('|@NIL|     t)
      ('|@SYMBOL|  (compile-atom         spec lvl globals spec))
      ('|@ATOM|    (compile-atom         spec lvl globals spec))
      ('|@CODE|    (compile-code         spec lvl globals spec))
      ('|@LIST|    (compile-list         spec lvl globals spec))
      ('|@UNARY|   (compile-unary        spec lvl globals spec))
      ('|@OPR|     (compile-operator     spec lvl globals spec))
      ('|@NTH|     (compile-nth          spec lvl globals spec))
      ('|@?|       (compile-?            spec lvl globals spec))
      ('|@CAST|    (compile-cast         spec lvl globals spec))
      ('|@$|       (compile-$            spec lvl globals spec))      
      ('|@->|      (compile-->           spec lvl globals spec))
      ('|@=>|      (compile-=>           spec lvl globals spec))
      ('|@SIZEOF|  (compile-sizeof       spec lvl globals spec))
      ('|@TYPEOF|  (compile-typeof       spec lvl globals spec))
      ('|@LET|     (compile-let          spec lvl globals spec))
      ('|@LETN|    (compile-let          spec lvl globals spec t))
      ('|@BLOCK|   (compile-block        spec lvl globals spec))
      ('|@PROGN|   (compile-progn        spec lvl globals spec))
      ('|@PREPROC| (compile-preprocessor spec lvl globals spec)) ; from inside macros 
	  ('|@INCLUDE| (compile-include      spec lvl globals spec))
      ('|@TYPEDEF| (compile-typedef      spec lvl globals spec)) 
      ('|@VAR|     (compile-variable     spec lvl globals spec))
      ('|@PARAM|   (compile-variable     spec lvl globals spec))
      ('|@FUNC|    (compile-function     spec lvl globals spec)) 
      ('|@METHOD|  (compile-function     spec lvl globals spec)) 
      ('|@ENUM|    (compile-enum         spec lvl globals spec :nested (or
                                                                           (key-eq '|@STRUCT| (construct parent-spec))
                                                                         (key-eq '|@UNION| (construct parent-spec))))) 
      ('|@STRUCT|  (compile-struct       spec lvl globals spec :nested (or
                                                                           (key-eq '|@STRUCT| (construct parent-spec))
                                                                         (key-eq '|@UNION| (construct parent-spec))))) 
      ('|@UNION|   (compile-union        spec lvl globals spec :nested (or
                                                                           (key-eq '|@STRUCT| (construct parent-spec))
                                                                         (key-eq '|@UNION| (construct parent-spec)))))
      ('|@GUARD|   (compile-guard        spec lvl globals spec :nested (key-eq '|@GUARD| (construct parent-spec))
                                         :from-body from-body)) 
      ('|@MODULE|  (compile-module       spec lvl globals spec :nested (key-eq '|@MODULE| (construct parent-spec))
                                         :from-body from-body))  ; down here for inside macros 
      ('|@CALL|    (compile-call         spec lvl globals spec))
      ('|@BODY|    (compile-body         spec lvl globals parent-spec))
      (t (error (format nil "expr syntax error ~A" spec)))))

(defun compile-body-form (form lvl globals parent-spec)
  (case (construct form)
	('|@PREPROC| (compile-preprocessor form (1+ lvl) globals parent-spec))
    ('|@ASSIGN|  (compile-assignment   form (1+ lvl) globals parent-spec))
    ('|@CALL|    (compile-call         form (1+ lvl) globals parent-spec))
    ('|@VAR|     (compile-variable     form (1+ lvl) globals parent-spec))
    ('|@LET|     (compile-let          form (1+ lvl) globals parent-spec))
    ('|@LETN|    (compile-let          form (1+ lvl) globals parent-spec t))
    ('|@BLOCK|   (compile-block        form      lvl globals parent-spec))
    ('|@PROGN|   (compile-progn        form (1+ lvl) globals parent-spec))
    ('|@SET|     (compile-set          form (1+ lvl) globals parent-spec))
    ('|@RETURN|  (compile-return       form (1+ lvl) globals parent-spec))
    ('|@IF|      (compile-if           form (1+ lvl) globals parent-spec))
    ('|@SWITCH|  (compile-switch       form (1+ lvl) globals parent-spec))
    ('|@WHILE|   (compile-while        form (1+ lvl) globals parent-spec))
    ('|@FOR|     (compile-for          form (1+ lvl) globals parent-spec))
    ('|@COND|    (compile-cond         form (1+ lvl) globals parent-spec))
    ('|@DO|      (compile-do           form      lvl globals parent-spec))
    ('|@BODY|    (compile-body         form      lvl globals parent-spec))
    (t           (compile-form         form      lvl globals parent-spec :from-body t))))

(defvar *parent-bodies* (list '|@CICILI| '|@TARGET| '|@FUNC| '|@METHOD|
                              '|@LET| '|@LETN| '|@BLOCK| '|@PROGN| '|@STRUCT| '|@UNION|
                              '|@DO| '|@WHILE| '|@FOR| '|@IF| '|@COND| '|@SWITCH|
                              '|@CASE| '|@DEFAULT| '|@GUARD| '|@MODULE|))

(defun compile-body-list (body lvl globals parent-spec)
  (let ((is-parent-bodies (find (construct parent-spec) *parent-bodies* :test #'key-eq)))
    (loop for form in body
          do (progn
               (when (and is-parent-bodies
                       (not (find (construct form)
                                  (list '|@BODY| '|@INCLUDE| '|@PREPROC| '|@TYPEDEF|
                                        '|@ENUM| '|@STRUCT| '|@UNION| '|@FUNC| '|@METHOD|)
                                  :test #'key-eq)))
                 (output "~&~A" (indent lvl)))
               
               (compile-body-form form
                 (if (find (construct form) (list '|@BODY| '|@GUARD| '|@MODULE|) :test #'key-eq)
                     lvl (1+ lvl))
                 globals parent-spec)
               
               (unless (key-eq '|@BODY| (construct form))
                 (if (and is-parent-bodies
                       (not (find (construct form) (list '|@INCLUDE| '|@PREPROC|) :test #'key-eq))
                       (or (find (construct form) (list '|@LETN| '|@PROGN|) :test #'key-eq) ; container with ;
                         (not (find (construct form) *parent-bodies* :test #'key-eq))))
                     (output ";~%")
                     (unless (find (construct form) (list '|@GUARD| '|@MODULE| '|@CALL| '|@CAST|)
                                   :test #'key-eq) ; no ;~%
                       (display "GGGGG" (construct form) (name form) (construct parent-spec) #\Newline)
                       (output "~%"))))))))

(defun compile-body (spec lvl globals parent-spec)
  (unless (key-eq '|@BODY| (construct spec)) (error (format nil "non-body for compile body ~A" spec)))
  (compile-body-list (body spec) lvl globals parent-spec))

(defun compile-body-map (inners lvl globals parent-spec)
  (let ((is-parent-bodies (find (construct parent-spec) *parent-bodies* :test #'key-eq)))
    (maphash #'(lambda (in-name form)
                 (when (and is-parent-bodies
                       (not (find (construct form)
                                  (list '|@BODY| '|@INCLUDE| '|@PREPROC| '|@TYPEDEF|
                                        '|@ENUM| '|@STRUCT| '|@UNION| '|@FUNC| '|@METHOD|)
                                  :test #'key-eq)))
                   (output "~&~A" (indent lvl)))
                 
                 (compile-body-form form
                   (if (find (construct form) (list '|@BODY| '|@GUARD| '|@MODULE|) :test #'key-eq)
                       lvl (1+ lvl))
                   globals parent-spec)

                 (unless (key-eq '|@BODY| (construct form))
                   (if (and is-parent-bodies
                         (not (find (construct form) (list '|@INCLUDE| '|@PREPROC|) :test #'key-eq))
                         (or (find (construct form) (list '|@LETN| '|@PROGN|) :test #'key-eq) ; container with ;
                           (not (find (construct form) *parent-bodies* :test #'key-eq))))
                       (output ";~%")
                       (unless (find (construct form) (list '|@GUARD| '|@MODULE| '|@CALL| '|@CAST|)
                                     :test #'key-eq) ; no ;~%
                         (display "GGGGG" (construct form) (construct parent-spec) #\Newline)
                         (output "~%")))))
	         inners)))
